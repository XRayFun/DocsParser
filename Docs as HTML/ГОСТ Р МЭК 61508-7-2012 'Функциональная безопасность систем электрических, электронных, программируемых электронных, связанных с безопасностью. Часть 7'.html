<style>.base64.sign {display: none;}</style><p id="P0001" class="formattext topleveltext"></p><p id="P0002" class="formattext topleveltext" align="right">ГОСТ Р МЭК 61508-7-2012<br/><br/></p><p id="P0003" class="headertext topleveltext centertext" align="center">НАЦИОНАЛЬНЫЙ СТАНДАРТ РОССИЙСКОЙ ФЕДЕРАЦИИ </p><p id="P0004" class="headertext topleveltext centertext" align="center">     <br/><br/>ФУНКЦИОНАЛЬНАЯ БЕЗОПАСНОСТЬ СИСТЕМ ЭЛЕКТРИЧЕСКИХ, ЭЛЕКТРОННЫХ, ПРОГРАММИРУЕМЫХ ЭЛЕКТРОННЫХ, СВЯЗАННЫХ С БЕЗОПАСНОСТЬЮ </p><p id="P0005" class="headertext topleveltext centertext" align="center">     <br/>Часть 7<br/></p><p id="P0006" class="headertext topleveltext centertext" align="center">Методы и средства </p><p id="P0007" class="headertext topleveltext centertext" align="center">     <br/>Functional safety of electrical electronic programmable electronic safety-related systems. Part 7. Techniques and measures </p><p id="P0008" class="formattext topleveltext indenttext" align="justify"><br/><br/></p><p id="P0008_1" class="formattext topleveltext" align="justify">ОКС 25.040.40,<br/></p><p id="P0008_2" class="formattext topleveltext" align="justify">        35.240.50 <br/><br/></p><p id="P0009" class="formattext topleveltext" align="right">Дата введения 2013-08-01 </p><p id="P000A" class="headertext topleveltext centertext" align="center">     <br/></p><h2 id="P000D" class="headertext topleveltext centertext" align="center" title-level="2">Предисловие </h2><p id="P000E" class="formattext topleveltext empty_line" align="justify"></p><p id="P0010" class="formattext topleveltext indenttext" align="justify">1 ПОДГОТОВЛЕН Обществом с ограниченной ответственностью &quot;Корпоративные электронные системы&quot; и Федеральным бюджетным учреждением &quot;Консультационно-внедренческая фирма в области международной стандартизации и сертификации - &quot;Фирма &quot;Интерстандарт&quot; на основе собственного перевода на русский язык англоязычной версии международного стандарта, указанного в пункте 4<br/><br/></p><p id="P0012" class="formattext topleveltext indenttext" align="justify">2 ВНЕСЕН Техническим комитетом по стандартизации ТК 58 &quot;Функциональная безопасность&quot;<br/><br/></p><p id="P0014" class="formattext topleveltext indenttext" align="justify">3 УТВЕРЖДЕН И ВВЕДЕН В ДЕЙСТВИЕ Приказом Федерального агентства по техническому регулированию и метрологии от 29 октября 2012 г. N 592-ст<br/><br/></p><p id="P0016" class="formattext topleveltext indenttext" align="justify">4 Настоящий стандарт идентичен международному стандарту МЭК 61508-7:2010* &quot;Функциональная безопасность систем электрических, электронных, программируемых электронных, связанных с безопасностью. Часть 7. Методы и средства&quot; (IEC 61508-7:2010 &quot;Functional safety of electrical/electronic/programmable electronic safety-related systems - Part 7: Overview of techniques and measures&quot;, IDT).<br/></p><p id="P0016_1" class="formattext topleveltext" align="justify">________________<br/></p><p id="P0016_2" class="formattext topleveltext indenttext" align="justify">* Доступ к международным и зарубежным документам, упомянутым в тексте, можно получить, обратившись в <a class="document" href="/document/747417966" nd="747417966">Службу поддержки пользователей</a>. - Примечание изготовителя базы данных. <br/><br/><br/></p><p id="P0016_3" class="formattext topleveltext indenttext" align="justify">Наименование настоящего стандарта изменено относительно наименования указанного международного стандарта для приведения в соответствие с <a class="document" href="/document/1200101156#7D20K3" nd="1200101156" context="7D20K3">ГОСТ Р 1.5-2012</a> (пункт 3.5).<br/><br/></p><p id="P0016_4" class="formattext topleveltext indenttext" align="justify">При применении настоящего стандарта рекомендуется использовать вместо ссылочных международных стандартов соответствующие им национальные стандарты, сведения о которых приведены в дополнительном <a class="document" href="/document/1200103242#8QM0M2" nd="1200103242" context="8QM0M2">приложении ДА</a><br/><br/></p><p id="P0018" class="formattext topleveltext indenttext" align="justify">5 ВЗАМЕН <a class="document" href="/document/1200063227#7D20K3" nd="1200063227" context="7D20K3">ГОСТ Р МЭК 61508-7-2007</a><br/><br/></p><p id="P0018_1" class="formattext topleveltext indenttext" align="justify">6 ПЕРЕИЗДАНИЕ. Апрель 2020 г.<br/><br/><br/></p><p id="P0018_2" class="formattext topleveltext indenttext" align="justify"><i>Правила применения настоящего стандарта установлены в </i><a class="document" href="/document/420284277#8Q40M1" nd="420284277" context="8Q40M1">статье 26 Федерального закона от 29 июня 2015 г. N 162-ФЗ &quot;О стандартизации в Российской Федерации&quot;.</a><i> Информация об изменениях к настоящему стандарту публикуется в ежегодном (по состоянию на 1 января текущего года) информационном указателе &quot;Национальные стандарты&quot;, а официальный текст изменений и поправок - в ежемесячном информационном указателе &quot;Национальные стандарты&quot;. В случае пересмотра (замены) или отмены настоящего стандарта соответствующее уведомление будет опубликовано в ближайшем выпуске ежемесячного информационного указателя &quot;Национальные стандарты&quot;. Соответствующая информация, уведомление и тексты размещаются также в информационной системе общего пользования - на официальном сайте Федерального агентства по техническому регулированию и метрологии в сети Интернет (www.gost.ru)</i><br/><br/></p><h2 id="P001B" class="headertext topleveltext centertext" align="center" title-level="2">Введение </h2><p id="P001C" class="formattext topleveltext indenttext" align="justify"><br/></p><p id="P001C_1" class="formattext topleveltext indenttext" align="justify">Системы, состоящие из электрических и/или электронных элементов, в течение многих лет используются для выполнения функций безопасности в большинстве областей применения. Компьютерные системы (обычно называемые &quot;программируемые электронные системы&quot;), применяемые во всех прикладных отраслях для выполнения функций, не связанных с безопасностью, во все более увеличивающихся количествах используются для выполнения функций обеспечения безопасности. Для эффективной и безопасной эксплуатации технологий, основанных на использовании компьютерных систем, чрезвычайно важно, чтобы лица, ответственные за принятие решений, имели в своем распоряжении руководства по вопросам безопасности, которые они могли бы использовать в своей работе.<br/><br/></p><p id="P001C_2" class="formattext topleveltext indenttext" align="justify">Настоящий стандарт устанавливает общий подход к вопросам обеспечения безопасности для всего жизненного цикла систем, состоящих из электрических и/или электронных, и/или программируемых электронных (Э/Э/ПЭ) элементов, которые используются для выполнения функций обеспечения безопасности. Этот унифицированный подход был принят для разработки рациональной и последовательной технической политики для всех электрических систем обеспечения безопасности. При этом основной целью является содействие разработке стандартов для продукции и областей применения на основе стандартов серии МЭК 61508.<br/><br/></p><p id="P001C_3" class="formattext topleveltext indenttext" align="justify">Примечание - Примерами стандартов для продукции и областей применения, разработанных на основе стандартов серии МЭК 61508, являются [1]-[3].<br/><br/><br/></p><p id="P001C_4" class="formattext topleveltext indenttext" align="justify">Обычно безопасность достигается за счет использования нескольких систем, в которых используются различные технологии (например механические, гидравлические, пневматические, электрические, электронные, программируемые электронные). Любая стратегия безопасности должна, следовательно, учитывать не только все элементы, входящие в состав отдельных систем (например, датчики, управляющие устройства и исполнительные механизмы), но также и все подсистемы безопасности, входящие в состав общей системы обеспечения безопасности. Таким образом, хотя настоящий стандарт посвящен в основном Э/Э/ПЭ системам, связанным с безопасностью, он может также предоставлять общий подход, в рамках которого рассматриваются системы, связанные с безопасностью, базирующиеся на других технологиях.<br/><br/></p><p id="P001C_5" class="formattext topleveltext indenttext" align="justify">Признанным фактом является существование огромного разнообразия использования Э/Э/ПЭ систем в различных областях применения, отличающихся различной степенью сложности, возможными рисками и опасностями. В каждом конкретном применении необходимые меры безопасности будут зависеть от многочисленных факторов, специфичных для конкретного применения. Настоящий стандарт, являясь базовым, позволит формулировать такие меры для областей применения будущих международных стандартов, а также для последующих редакций уже существующих стандартов.<br/><br/></p><p id="P001D" class="formattext topleveltext indenttext" align="justify">Настоящий стандарт:<br/><br/></p><p id="P001D_1" class="formattext topleveltext indenttext" align="justify">- рассматривает все соответствующие стадии жизненного цикла безопасности систем в целом, а также подсистем Э/Э/ПЭ системы и программного обеспечения (от первоначальной концепции, через проектирование, внедрение, эксплуатацию и техническое обеспечение до снятия с эксплуатации), в ходе которых Э/Э/ПЭ системы используются для выполнения функций безопасности;<br/><br/></p><p id="P001D_2" class="formattext topleveltext indenttext" align="justify">- был задуман с учетом быстрого развития технологий; его основа является в значительной мере устойчивой и полной для будущих разработок;<br/><br/></p><p id="P001D_3" class="formattext topleveltext indenttext" align="justify">- делает возможной разработку стандартов областей применения, в которых используются Э/Э/ПЭ системы, связанные с безопасностью; разработка стандартов для областей применения в рамках общей структуры, вводимой настоящим стандартом, должна привести к более высокому уровню согласованности (например основных принципов, терминологии и т.д.) как для отдельных областей применения, так и для их совокупностей, что даст преимущества в плане безопасности и экономики;<br/><br/></p><p id="P001D_4" class="formattext topleveltext indenttext" align="justify">- предоставляет метод разработки спецификации требований к безопасности, необходимых для достижения заданной функциональной безопасности Э/Э/ПЭ систем, связанных с безопасностью;<br/><br/></p><p id="P001D_5" class="formattext topleveltext indenttext" align="justify">- использует для определения требований к уровням полноты безопасности подход, основанный на оценке рисков;<br/><br/></p><p id="P001D_6" class="formattext topleveltext indenttext" align="justify">- вводит уровни полноты безопасности для определения целевого уровня полноты безопасности для функций безопасности, которые должны быть реализованы Э/Э/ПЭ системами, связанными с безопасностью.<br/><br/></p><p id="P001D_7" class="formattext topleveltext indenttext" align="justify">Примечание - Настоящий стандарт не устанавливает требований к уровню полноты безопасности для любой функции безопасности и не определяет то, как устанавливается уровень полноты безопасности. Однако настоящий стандарт формирует основанный на риске концептуальный подход и приводит примеры методов;<br/><br/><br/></p><p id="P001D_8" class="formattext topleveltext indenttext" align="justify">- устанавливает целевые меры отказов для функций безопасности, реализуемых Э/Э/ПЭ системами, связанными с безопасностью, и связывает эти меры с уровнями полноты безопасности;<br/><br/></p><p id="P001D_9" class="formattext topleveltext indenttext" align="justify">- устанавливает нижнюю границу для целевых мер отказов для функции безопасности, реализуемой одиночной Э/Э/ПЭ системой, связанной с безопасностью. Для Э/Э/ПЭ систем, связанных с безопасностью, работающих в режиме:<br/><br/></p><p id="P001D_10" class="formattext topleveltext indenttext" align="justify">- низкой интенсивности запросов на обслуживание: нижняя граница для выполнения функции, для которой система предназначена, устанавливается в соответствии со средней вероятностью опасного отказа по запросу, равной 10<img class="base64" src="data:image;base64,R0lGODdhEQAXAIABAAAAAP///ywAAAAAEQAXAAACHoyPqcvtDwOYEcRDr7FapglyWCdCZQN26sq27guzBQA7" width="17" height="23"/>,<br/><br/></p><p id="P001D_11" class="formattext topleveltext indenttext" align="justify">- высокой интенсивности запросов на обслуживание или в непрерывном режиме: нижняя граница устанавливается в соответствии со средней частотой опасных отказов 10<img class="base64" src="data:image;base64,R0lGODdhEQAXAIABAAAAAP///ywAAAAAEQAXAAACIIyPqcvtD4GEARz7cI2XG/1JYjhRmwk6pcm27gvH8gwVADs=" width="17" height="23"/> в час.<br/><br/></p><p id="P001D_12" class="formattext topleveltext indenttext" align="justify">Примечания<br/><br/></p><p id="P001F" class="formattext topleveltext indenttext" align="justify">1 Одиночная Э/Э/ПЭ система, связанная с безопасностью, не обязательно предполагает одноканальную архитектуру.<br/><br/></p><p id="P0021" class="formattext topleveltext indenttext" align="justify">2 В проектах систем, связанных с безопасностью и имеющих низкий уровень сложности, можно достигнуть более низких значений целевой полноты безопасности, но предполагается, что в настоящее время указанные предельные значения целевой полноты безопасности могут быть достигнуты для относительно сложных систем (например программируемые электронные системы, связанные с безопасностью);<br/><br/><br/></p><p id="P0021_1" class="formattext topleveltext indenttext" align="justify">- устанавливает требования по предотвращению и управлению систематическими отказами, основанные на опыте и заключениях из практического опыта. Учитывая, что вероятность возникновения систематических отказов в общем случае, не может быть определена количественно, настоящий стандарт позволяет утверждать для специфицируемой функции безопасности, что целевая мера отказов, связанных с этой функцией, может считаться достигнутой, если все требования стандарта были выполнены;<br/><br/></p><p id="P0021_2" class="formattext topleveltext indenttext" align="justify">- вводит понятие &quot;стойкость к систематическим отказам&quot;, применяемое к элементу, характеризующее уверенность в том, что полнота безопасности, касающаяся систематических отказов элемента, соответствует требованиям заданного уровня полноты безопасности;<br/><br/></p><p id="P0021_3" class="formattext topleveltext indenttext" align="justify">- применяет широкий диапазон принципов, методов и средств для достижения функциональной безопасности Э/Э/ПЭ систем, связанных с безопасностью, но не использует явно понятие &quot;безопасный отказ&quot;. В то же время понятия &quot;безопасный отказ&quot; и &quot;безопасный в своей основе отказ&quot; могут быть использованы, но для этого необходимо обеспечить соответствующие требования в конкретных разделах стандарта, которым эти понятия должны соответствовать.<br/><br/></p><h2 id="P0024" class="headertext topleveltext" align="justify" title-level="2">     1 Область применения </h2><p id="P0025" class="formattext topleveltext empty_line" align="justify"></p><p id="P0027" class="formattext topleveltext indenttext" align="justify">1.1 Настоящий стандарт содержит общее описание различных методов и средств, обеспечивающих выполнение требований МЭК 61508-2 и МЭК 61508-3. Ссылки должны рассматриваться как базовые ссылки на методы и инструменты либо как примеры, и они могут не отражать современное состояние области.<br/><br/></p><p id="P0029" class="formattext topleveltext indenttext" align="justify">1.2 МЭК 61508-1, МЭК 61508-2, МЭК 61508-3 и МЭК 61508-4 являются базовыми стандартами по безопасности, хотя этот статус не применим в контексте Э/Э/ПЭ систем, связанных с безопасностью, имеющих низкую сложность (см. пункт 3.4.3 МЭК 61508-4). В качестве базовых стандартов по безопасности, данные стандарты предназначены для использования техническими комитетами при подготовке стандартов в соответствии с принципами, изложенными в руководстве МЭК 104 и руководстве ИСО/МЭК 51. МЭК 61508-1, МЭК 61508-2, МЭК 61508-3 и МЭК 61508-4 предназначены для использования в качестве самостоятельных стандартов. Функция безопасности настоящего стандарта не применима к медицинскому оборудованию, соответствующему требованиям серии горизонтальных стандартов МЭК 60601 [4].<br/><br/></p><p id="P002B" class="formattext topleveltext indenttext" align="justify">1.3 В круг обязанностей Технического комитета входит использование (там, где это возможно) основополагающих стандартов по безопасности при подготовке собственных стандартов. В этом случае требования, методы проверки или условия проверки настоящего основополагающего стандарта по безопасности не применяют, если на них нет конкретной ссылки или они не включены в стандарты, подготовленные этими техническими комитетами.<br/><br/></p><p id="P002D" class="formattext topleveltext indenttext" align="justify">1.4 На рисунке 1 изображена общая структура стандартов серии МЭК 61508 и показана роль, которую играет настоящий стандарт в достижении функциональной безопасности Э/Э/ПЭ систем, связанных с безопасностью.     <br/><br/></p><p id="P002E" class="formattext topleveltext centertext" align="center"><br/></p><p align="center" id="X58"></p><div element-type="table" class="table-container" id="X59"><style type="text/css">#P0030 .td1 {width: 48.51em}#P0030 .td2 {width: 48.51em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px none black; border-left: 1px none black; border-bottom: 1px none black; border-right: 1px none black; }</style><table align="center" id="P0030" class="wideTable"><tr height="1"><td class="td1"></td></tr><tr><td valign="top" class="td2"><p id="P00300000" class="formattext" align="center"><img class="normal" src="https://api.docs.cntd.ru/img/12/00/10/32/42/135f542c-1dc5-4db8-9c2d-74263b12735c/P003000000000.png" width="620" height="723"/></p></td></tr></table></div><p id="P0031" class="formattext topleveltext centertext" align="center"><br/>Рисунок 1 - Общая структура стандартов серии МЭК 61508<br/><br/></p><h2 id="P0034" class="headertext topleveltext" align="justify" title-level="2">     2 Нормативные ссылки </h2><p id="P0035" class="formattext topleveltext indenttext" align="justify"><br/></p><p id="P0035_1" class="formattext topleveltext indenttext" align="justify">В настоящем стандарте использованы нормативные ссылки на следующие стандарты. Для датированных ссылок применяют только указанное издание ссылочного стандарта, для недатированных - последнее издание (включая все изменения).<br/><br/></p><p id="P0035_2" class="formattext topleveltext indenttext" align="justify">ISO/IEC Guide 51:1999<img class="base64" src="data:image;base64,R0lGODdhDQAXAIABAAAAAP///ywAAAAADQAXAAACIIyPqcvtcKAC0lR0b0w66P5NnIhx1OZ4aZe27gvHclIAADs=" width="13" height="23"/>, Safety aspects - Guidelines for their inclusion in standards (Аспекты безопасности. Руководящие указания по включению в стандарты)<br/></p><p id="P0035_3" class="formattext topleveltext" align="justify">________________<br/></p><p id="P0035_4" class="formattext topleveltext indenttext" align="justify"><img class="base64" src="data:image;base64,R0lGODdhDQAXAIABAAAAAP///ywAAAAADQAXAAACIIyPqcvtcKAC0lR0b0w66P5NnIhx1OZ4aZe27gvHclIAADs=" width="13" height="23"/> Заменен на ISO/IEC Guide 51:2014.<br/><br/><br/></p><p id="P0035_5" class="formattext topleveltext indenttext" align="justify">IEC Guide 104:2010<img class="base64" src="data:image;base64,R0lGODdhEAAXAIABAAAAAP///ywAAAAAEAAXAAACJYyPqcvtb4CMDRwbsMO63qd1SiciYkll3yhNKpRCKEzX9o3ndQEAOw==" width="16" height="23"/>, The preparation of safety publications and the use of basic safety publications and group safety publications (Подготовка публикаций по безопасности и использование базовых публикаций по безопасности и публикаций по безопасности групп)<br/></p><p id="P0035_6" class="formattext topleveltext" align="justify">________________<br/></p><p id="P0035_7" class="formattext topleveltext indenttext" align="justify"><img class="base64" src="data:image;base64,R0lGODdhEAAXAIABAAAAAP///ywAAAAAEAAXAAACJYyPqcvtb4CMDRwbsMO63qd1SiciYkll3yhNKpRCKEzX9o3ndQEAOw==" width="16" height="23"/> Заменен на IEC Guide 104:2019.<br/><br/><br/></p><p id="P0035_8" class="formattext topleveltext indenttext" align="justify">IEC 61508-4:2010, Functional safety of electrical/electronic/programmable electronic safety-related systems - Part 4: Definitions and abbreviations (Функциональная безопасность систем электрических, электронных, программируемых электронных, связанных с безопасностью. Часть 4. Определения и сокращения)<br/><br/></p><h2 id="P0038" class="headertext topleveltext" align="justify" title-level="2">     3 Термины и определения </h2><p id="P0039" class="formattext topleveltext indenttext" align="justify"><br/></p><p id="P0039_1" class="formattext topleveltext indenttext" align="justify">В настоящем стандарте применены термины, определения и сокращения по МЭК 61508-4.<br/></p><p id="P003A" class="formattext topleveltext centertext" align="center"></p><h2 id="P003D" class="formattext topleveltext centertext" align="center" title-level="2">Приложение А<br/>(справочное)<br/></h2><p id="P003E" class="headertext topleveltext centertext" align="center">Анализ методов и средств для Э/Э/ПЭ систем, связанных с безопасностью. Управление случайными отказами технических средств (см. МЭК 61508-2)</p><p id="P003F" class="formattext topleveltext empty_line" align="justify"></p><h3 id="P0042" class="formattext topleveltext indenttext" align="justify" title-level="3"><b>А.1 Электрические</b><br/><br/></h3><p id="P0042_1" class="formattext topleveltext indenttext" align="justify">Главная цель. Управление отказами в электромеханических компонентах.<br/><br/></p><p id="P0044" class="formattext topleveltext indenttext" align="justify"><b>А.1.1 Обнаружение отказов путем мониторинга в режиме онлайн</b><br/><br/></p><p id="P0044_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблицы А.2, А.3, А.7 и А.13-А.18).<br/><br/><br/></p><p id="P0044_2" class="formattext topleveltext indenttext" align="justify">Цель. Обнаружение отказов путем контроля поведения Э/Э/ПЭ системы, связанной с безопасностью, в процессе нормального (в режиме онлайн) функционирования управляемого оборудования (далее - УО).<br/><br/></p><p id="P0044_3" class="formattext topleveltext indenttext" align="justify">Описание. При определенных условиях отказы могут быть обнаружены с помощью информации, например, о поведении во времени УО. Например, если коммутатор, который является частью Э/Э/ПЭ системы, связанной с безопасностью, нормально активизируется со стороны УО и если при этом коммутатор не изменяет состояния в предполагаемое время, то этот отказ может быть обнаружен. Обычными способами невозможно локализовать такой отказ.<br/><br/></p><p id="P0046" class="formattext topleveltext indenttext" align="justify"><b>А.1.2 Мониторинг контактов реле</b><br/><br/></p><p id="P0046_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблицы А.2 и А.14).<br/><br/><br/></p><p id="P0046_2" class="formattext topleveltext indenttext" align="justify">Цель. Обнаружение отказов (например пайки) контактов реле.<br/><br/></p><p id="P0046_3" class="formattext topleveltext indenttext" align="justify">Описание. Активизируемые контактные реле (или положительно управляемые контакты в реле) спроектированы так, что их контакты жестко связаны между собой. Рассмотрим два переключаемых контакта <i>a</i> и <i>b</i>. Если нормально разомкнутый контакт <i>a</i> оказался спаянным (залипшим), то нормально замкнутый контакт <i>b</i> не может замкнуться, если обмотка реле обесточивается. Следовательно, контроль замыкания нормально замкнутого контакта <i>b</i> при обесточенной обмотке реле может быть использован для подтверждения того, что нормально разомкнутый контакт <i>a</i> разомкнут. Отсутствие замыкания нормально замкнутого контакта <i>b</i> указывает на отказ контакта <i>a</i>, поэтому схема контроля должна обеспечить надежное отключение или обеспечить продолжение отключения при любом управлении оборудования контактом <i>a</i>.<br/><br/></p><p><img class="base64 sign" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZIAAAARCAMAAADAD9oKAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MTg4Q0U3ODQ0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MTg4Q0U3ODU0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoxODhDRTc4MjRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDoxODhDRTc4MzRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pos3t18AAAAzUExURfX19SQkJOrq6oeHh7y8vD8/P9/f31RUVMjIyLCwsHh4eJaWlmdnZ6Ojo9TU1AAAAP////kimdMAAAWSSURBVHja7FiJcuQoDAVzGcz1/1+7TwLRuDs9mZ2karZqQ1ViGz90PUngVv1nfMOo9fg2WarnNkf9FGxMHdDkf1jo3bXBg7o0YhIkfrXV0npvBfd48y94HQtV97XWZvBPfbpG29oikGfQ6oeRs4WLb4K2CGNq5wsltpX6B5TQYEa5/u6h9rdn31QdtXS0iKX1WZ360/o9Pl/3NmVq/ahk/cfwZ0X+bSL6T01Kxmq6Fj0MSDNPj+atGzF1+Y17z9IZMRfulHiH+ivMFvE7nm2ffQ26Q5+U0AKLatWUGFm63kU3SJycuwqNLgNJ1ONf6crorUNyEySMStQLlegNgSuSmiT5agizm0YyZwPNbEXLM64y2X0YcGgdN3ytU9FaLDCecHbCyFWVh0kjMvBEHK+rvx/tVIgOWSoTcZrRa+aVJxeOuLc5nG8Oj2cjCzdKDm1Uj9BCSFeO7sKBgKCxRWpXKNAiFtV2njBAGeqm2QBQaZKCjjDCA+vqnZJD802sAzu9q4EwRtde4djUG4kJeFObpsag4cXNNJKJejRY7pVO9EJiQf2XRJLlBEcW1Toooc48FcniBeN2nOALwwzMDXhDJv2CkoKENkS/NKzu0p74rRyOk0vcezgs0iXQhLDixE4J6YAALgUqoEq6VKpih0KosOuUUihxM+eGo6KIA3DEaTI8oJS7UZIybnhmOVX1wCiqLJSYmnr52WjShadTA7Obtsyl2lP22PquxG9kJ1VbSWN2gEXRfF4wlnri36xnTJBYC+R7ShyX17HNDIcXJSg8ddMqDi/p0+HOCGNfKclwPmdHBsVgp9mbHaemuwBMwtvmCK2pQqtwdpakiZIQg7pTAitwc+m6OVWyWFhnzQy9aMrcDZASSAJjgNlMo5R4UIJ1xbhnSsYr+p/LRslS1FfshQFIpb4v06WRvgBky4VfseOmPqy3zaKiZqp/SEmpOqhdqzi8pE+H6/2wu1PiCg9AkvOvlJi0r2ZbS7FooaMpdo8WYy6ixPFRZKcEE9Iz115irhdKWC/y1VquyIpWqU+i5GEapcRWJaGFFN9T4s7foyRQdqmNkqHvGJmn82AtUzed1s9vB63U6jj6ulOCnnbtWsXhJX06/J6S5LbDmKYuy/W11rgbobKpdRvmtNFKGpfS142SqEcL8CE99hIKV+ZmbDnr/NQL2Slx46wxoDSB2U27NS77eN4oGZaj91G6PChZiubzgo2+i9AKJbEd/S5yKA5ZAnCwLL6IcfYe2aHWb1rF4SV9OjwQ9XylZGwwORFSIeLUakYnHEVAgh6U0D7elY49C1OZNrM09pIC8EaJtnyjdHiIqE4qiY+K2YleProNrUcLhk8Lm2k3SgrF/KVKhuUQVUzfKFmK5vOCvVBytMSb69NeolwS66954oXTvnF2en3b3XmlIo3LPXF4SReHXZ5b3zMlCKcpAVse9z38XXh2kvo9htvuppy+LqeP0LgvBo/IpIJ+b/kQrGUDaM4XPvlBR9IPVq3mlkDldKIJ5k0vnGyzNh2myYvdtJ0S3wLtJeZOybT8uEabQ3kPSkSRUDRhs3HpI2uhKwKZKC8elADStJcASJOg7IcrF9BZvVBCPVi0bg6LdHF4IOqNkvmNaVM2iMWBHqoKLD9TvghAE92ecjdXxkxveb8tHElMxB7PblETZ1G2zDe1eNbBMkVEGdsDl4k3d709uAk86RPY3k2b5lZOIzbxnN2c5xk+LM9jv8PZaIBFkSwWBw9CRWwlLJ3fVZPTuYkUyLT+KPP7VBGAQmGev5tHTGMUrbvDU/pyeNn1oOQLQ74d6yeA51Hyfnn6FWDtmF8bueyXvzx+5XB/3d6/4rbfL+8Bz8Ne++X+s4z5pp/QLrtf/vJ47/B3U/L9Q/Fp4P87fn7R/c+NfwQYAFx9eFOvgdoSAAAAAElFTkSuQmCC"/></p><style>.base64.sign {display: none;}</style><p id="P0046_4" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0046_5" class="formattext topleveltext indenttext" align="justify">Zusammenstellung und Bewertung elektromechanischer Sicherheitsschaltungen <img class="base64" src="data:image;base64,R0lGODdhFAAQAIABAAAAAP///ywAAAAAFAAQAAACJoyPqcvtDkCQ8k2rIj11Z1NdU5h0HNiYqLioIlmub8ppMobn+r4UADs=" width="20" height="16"/> Ver-riegelungseinrichtungen. F. Kreutzkampf, W. Hertel, Sicherheitstechnisches Informations- und Arbeitsblatt 330212, BIA-Handbuch. 17. Lfg. X/91, Erich Schmidt Verlag, Bielefeld. www.BGIA-HANDBUCHdigital.de/330212<br/><br/></p><p id="P0048" class="formattext topleveltext indenttext" align="justify"><b>A.1.3 Компаратор</b><br/><br/></p><p id="P0049" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблицы А.2, А.3, А.4).<br/><br/><br/></p><p id="P0049_1" class="formattext topleveltext indenttext" align="justify">Цель. Оперативное обнаружение (не одновременное) отказов в независимом модуле обработки или в компараторе.<br/><br/></p><p id="P0049_2" class="formattext topleveltext indenttext" align="justify">Описание. Сигналы независимых модулей обработки сравнивают циклически или непрерывно компаратором аппаратных средств. Сам компаратор может быть внешне тестируемым или же может использовать самоконтролируемую технологию. Обнаруживаемые компаратором различия в поведении процессоров независимых модулей формируют информацию для сообщений об отказах.<br/><br/></p><p id="P004B" class="formattext topleveltext indenttext" align="justify"><b>А.1.4 Схема голосования по мажоритарному принципу</b><br/><br/></p><p id="P004B_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблицы А.2, А.3 и А.4).<br/><br/><br/></p><p id="P004B_2" class="formattext topleveltext indenttext" align="justify">Цель. Обнаружение и парирование отказов по меньшей мере в одном из трех аппаратных каналов.<br/><br/></p><p id="P004B_3" class="formattext topleveltext indenttext" align="justify">Описание. Модуль голосования, использующий мажоритарный принцип (2 из 3, 3 из 4 или <img class="base64" src="data:image;base64,R0lGODdhEQAPAIABAAAAAP///ywAAAAAEQAPAAACIIyPqcvtnwAwks41c9CK141d39UdJImcJhitFgTH8nwUADs=" width="17" height="15"/> из <img class="base64" src="data:image;base64,R0lGODdhDQAPAIABAAAAAP///ywAAAAADQAPAAACGYyPqcvtAAxksdIYcJqZHo1o1vaBzommSwEAOw==" width="13" height="15"/>), используется для обнаружения и парирования отказов. Сама схема голосования может внешне тестироваться или использовать самоконтролирующие технологии.<br/><br/></p><p id="P004B_4" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P004B_5" class="formattext topleveltext indenttext" align="justify">Guidelines for Safe Automation of Chemical Processes. CCPS, AlChE, New York, 1993, ISBN-10: 0-8169-0554-1, ISBN-13: 978-0-8169-0554-6.<br/><br/></p><p id="P004D" class="formattext topleveltext indenttext" align="justify"><b>A.1.5 Отсутствие питания (отключение энергии)</b><br/><br/></p><p id="P004D_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблица А.16).<br/><br/><br/></p><p id="P004D_2" class="formattext topleveltext indenttext" align="justify">Цель. Выполнение функции безопасности при выключении или отсутствии питания.<br/><br/></p><p id="P004D_3" class="formattext topleveltext indenttext" align="justify">Описание. Функция безопасности выполняется, если контакты реле разомкнуты и ток не проходит. Например, при использовании тормозов для остановки опасного вращения двигателя тормоза отпускаются замыкающими контактами в системах, связанных с безопасностью, и включаются размыкающими контактами в системах, связанных с безопасностью.<br/><br/></p><p id="P004D_4" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P004D_5" class="formattext topleveltext indenttext" align="justify">Guidelines for Safe Automation of Chemical Processes. CCPS, AlChE, New York, 1993, ISBN-10: 0-8169-0554-1, ISBN-13: 978-0-8169-0554-6.<br/><br/></p><h3 id="P0050" class="formattext topleveltext indenttext" align="justify" title-level="3"><b>A.2 Электроника</b><br/><br/></h3><p id="P0051" class="formattext topleveltext indenttext" align="justify">Главная цель. Управление отказами в твердотельных компонентах.<br/><br/></p><p id="P0053" class="formattext topleveltext indenttext" align="justify"><b>А.2.1 Тестирование избыточным оборудованием</b><br/><br/></p><p id="P0053_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблицы А.3, А.15, А.16 и А.18).<br/><br/><br/></p><p id="P0053_2" class="formattext topleveltext indenttext" align="justify">Цель. Обнаружение отказов с использованием избыточных аппаратных средств, то есть с использованием дополнительных аппаратных средств, не требующихся для реализации функций обработки.<br/><br/></p><p id="P0053_3" class="formattext topleveltext indenttext" align="justify">Описание. Избыточные аппаратные средства могут быть использованы для тестирования на соответствующей частоте заданных функций безопасности. Такой подход обычно требуется для реализации положений пунктов А.1.1 или А.2.2.<br/><br/></p><p id="P0055" class="formattext topleveltext indenttext" align="justify"><b>А.2.2 Принципы динамического управления</b><br/><br/></p><p id="P0055_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблица А.3).<br/><br/><br/></p><p id="P0055_2" class="formattext topleveltext indenttext" align="justify">Цель. Обнаружение статических отказов путем динамической обработки сигналов.<br/><br/></p><p id="P0055_3" class="formattext topleveltext indenttext" align="justify">Описание. Принудительное изменение других статических сигналов (генерируемых извне или внутри) помогает обнаруживать статические отказы в компонентах. Этот метод часто ассоциируется с электромеханическими компонентами.<br/><br/></p><p id="P0055_4" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0055_5" class="formattext topleveltext indenttext" align="justify">Elektronik in der Sicherheitstechnik. H. <img class="base64" src="data:image;base64,R0lGODdhHAAQAIABAAAAAP///ywAAAAAHAAQAAACMoyPqcvtDyE4c8Zl77OZBw5kmNGRHtmcH8purfqFSrmyIpXQOt5Ssv8ThW6aovGITCoKADs=" width="28" height="16"/>, D. Reinert, Sicherheitstechnisches Informations- und Arbeitsblatt 330220, BIA-Handbuch, Erich-Schmidt Verlag, Bielefeld, 1993, htpp://www.bgia-handbuchdigital.de/330220.<br/><br/></p><p id="P0057" class="formattext topleveltext indenttext" align="justify"><b>A.2.3 Стандартный тестовый порт доступа и архитектура граничного сканирования</b><br/><br/></p><p id="P0057_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблицы А.3, А.15 и А.18).<br/><br/><br/></p><p id="P0057_2" class="formattext topleveltext indenttext" align="justify">Цель. Управление и наблюдение за происходящим на каждом контакте интегральной схемы (ИС).<br/><br/></p><p id="P0057_3" class="formattext topleveltext indenttext" align="justify">Описание. Тестирование граничного сканирования представляет собой метод построения ИС, который повышает тестируемость ИС, разрешая проблему доступа к внутренним точкам тестируемой схемы. В типичной сканируемой по границам интегральной схеме, содержащей внутренние логические схемы, а также входные и выходные буферы, между внутренними логическими схемами и входными/выходными буферами, соединенными с внешними контактами ИС, размещается ступень сдвигового регистра. Содержимое каждого сдвигового регистра находится в ячейке граничного сканирования. Ячейка граничного сканирования может управлять и наблюдать за происходящим на каждом входном и выходном контакте ИС через стандартный тестовый порт доступа. Тестирование внутренних логических схем ИС проводится путем отключения размещенных на чипе внутренних логических схем от входных сигналов, получаемых от окружающих компонентов, и последующего выполнения внутреннего тестирования. Эти тесты могут быть использованы для обнаружения отказов в ИС.<br/><br/></p><p id="P0057_4" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0058" class="formattext topleveltext indenttext" align="justify">IEEE 1149-1:2001, IEEE standard test access port and boundary-scan architecture, IEEE Computer Society, 2001, ISBN: 0-7381-2944-5.<br/><br/></p><p id="P005A" class="formattext topleveltext indenttext" align="justify"><b>A.2.4</b> (He используется)<br/><br/></p><p id="P005C" class="formattext topleveltext indenttext" align="justify"><b>A.2.5 Избыточный контроль</b><br/><br/></p><p id="P005C_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблица А.3).<br/><br/><br/></p><p id="P005C_2" class="formattext topleveltext indenttext" align="justify">Цель. Обнаружение отказов путем создания нескольких функциональных модулей, контроля поведения каждого из них для обнаружения отказов и последующего инициирования перехода в безопасное состояние при обнаружении какого-либо несоответствия в поведении.<br/><br/></p><p id="P005C_3" class="formattext topleveltext indenttext" align="justify">Описание. Функция безопасности выполняется по меньшей мере двумя аппаратными каналами. Выходы этих каналов контролируются и безопасное состояние инициируется при обнаружении отказа (в случае, если выходные сигналы из всех каналов не идентичны).<br/><br/></p><p id="P005C_4" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P005C_5" class="formattext topleveltext indenttext" align="justify">Elektronik in der Sicherheitstechnik. H. <img class="base64" src="data:image;base64,R0lGODdhHAAQAIABAAAAAP///ywAAAAAHAAQAAACMoyPqcvtDyE4c8Zl77OZBw5kmNGRHtmcH8purfqFSrmyIpXQOt5Ssv8ThW6aovGITCoKADs=" width="28" height="16"/>, D. Reinert, Sicherheitstechnisches Informations- und Arbeitsblatt 330220, BIA-Handbuch, Erich-Schmidt Verlag, Bielefeld, 1993, htpp://www.bgia-handbuchdigital.de/330220.<br/><br/></p><p id="P005C_6" class="formattext topleveltext indenttext" align="justify">Dependability of Critical Computer Systems 1. F.J. Redmill, Elsevier Applied Science, 1988, ISBN 1-85166-203-0.<br/><br/></p><p id="P005E" class="formattext topleveltext indenttext" align="justify"><b>А.2.6 Электрические/электронные компоненты с автоматической проверкой</b><br/><br/></p><p id="P005E_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблица А.3).<br/><br/><br/></p><p id="P005E_2" class="formattext topleveltext indenttext" align="justify">Цель. Обнаружение отказов путем периодической проверки способности выполнения функции безопасности.<br/><br/></p><p id="P005E_3" class="formattext topleveltext indenttext" align="justify">Описание. Аппаратные средства тестируются до запуска процесса и затем тестируются повторно через соответствующие интервалы. УО продолжает работу только при условии успешного прохождения каждого теста.<br/><br/></p><p id="P005E_4" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P005E_5" class="formattext topleveltext indenttext" align="justify">Elektronik in der Sicherheitstechnik. H. <img class="base64" src="data:image;base64,R0lGODdhHAAQAIABAAAAAP///ywAAAAAHAAQAAACMoyPqcvtDyE4c8Zl77OZBw5kmNGRHtmcH8purfqFSrmyIpXQOt5Ssv8ThW6aovGITCoKADs=" width="28" height="16"/>, D. Reinert, Sicherheitstechnisches Informations- und Arbeitsblatt 330220, BIA-Handbuch, Erich-Schmidt Verlag, Bielefeld, 1993,  htpp://www.bgia-handbuchdigital.de/330220.<br/><br/></p><p id="P005E_6" class="formattext topleveltext indenttext" align="justify">Dependability of Critical Computer Systems 1. F.J. Redmill, Elsevier Applied Science, 1988, ISBN 1-85166-203-0.<br/><br/></p><p id="P0060" class="formattext topleveltext indenttext" align="justify"><b>A.2.7 Текущий контроль аналоговых сигналов</b><br/><br/></p><p id="P0060_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблицы А.3 и А.13).<br/><br/></p><p id="P0061" class="formattext topleveltext indenttext" align="justify"><br/></p><p id="P0061_1" class="formattext topleveltext indenttext" align="justify">Цель. Повышение достоверности результатов измерений аналоговых сигналов.<br/><br/></p><p id="P0061_2" class="formattext topleveltext indenttext" align="justify">Описание. Везде, где возможно, используются аналоговые приборы, а не цифровые. В аналоговых приборах отключение или безопасные состояния представляются уровнями аналоговых сигналов обычно с контролем устойчивости уровня этого сигнала. Это обеспечивает непрерывный контроль и высокую степень достоверности передачи сигнала, снижает частоту необходимого гарантийного тестирования функции чувствительности передатчика. Внешние интерфейсы, например импульсные линии, также нуждаются в тестировании.<br/><br/></p><p id="P0063" class="formattext topleveltext indenttext" align="justify"><b>А.2.8 Снижение максимальных значений</b><br/><br/></p><p id="P0063_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2, подпункт 7.4.2.13.<br/><br/><br/></p><p id="P0063_2" class="formattext topleveltext indenttext" align="justify">Цель. Повышение надежности компонентов аппаратных средств.<br/><br/></p><p id="P0063_3" class="formattext topleveltext indenttext" align="justify">Описание. Компоненты аппаратных средств успешно выполняют свои функции на уровнях напряжений, которые определены при проектировании системы и являются более низкими, чем их максимальные значения, определенные в спецификации. Снижение этих значений является обычной практикой, гарантирующей, что при всех нормальных условиях эксплуатации компоненты будут успешно функционировать при уровнях напряжений ниже их максимальных значений.<br/><br/></p><h3 id="P0066" class="formattext topleveltext indenttext" align="justify" title-level="3"><b>А.3 Модули обработки</b><br/><br/></h3><p id="P0066_1" class="formattext topleveltext indenttext" align="justify">Главная цель. Распознавать отказы, которые приводят к неправильным результатам в модулях обработки.<br/><br/></p><p id="P0068" class="formattext topleveltext indenttext" align="justify"><b>А.3.1 Программное самотестирование: предельное количество комбинаций (одноканальное)</b><br/><br/></p><p id="P0068_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблица А.4).<br/><br/><br/></p><p id="P0068_2" class="formattext topleveltext indenttext" align="justify">Цель. Оперативное обнаружение отказов в модулях обработки.<br/><br/></p><p id="P0068_3" class="formattext topleveltext indenttext" align="justify">Описание. Аппаратные средства создаются с использованием стандартных методов, не учитывающих специальных требований к безопасности. Обнаружение отказов реализуется целиком дополнительными программными функциями, которые выполняют самотестирование с использованием по меньшей мере двух дополнительных комбинаций данных (например 55hex и AAhex).<br/><br/></p><p id="P006A" class="formattext topleveltext indenttext" align="justify"><b>А.3.2 Программное самотестирование: блуждающий бит (одноканальное)</b><br/><br/></p><p id="P006B" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблица А.4).<br/><br/><br/></p><p id="P006B_1" class="formattext topleveltext indenttext" align="justify">Цель. Оперативное обнаружение отказов в физической памяти (например в регистрах) и дешифраторе команд процессора.<br/><br/></p><p id="P006B_2" class="formattext topleveltext indenttext" align="justify">Описание. Обнаружение отказов полностью реализуется дополнительными программными функциями, которые выполняют самотестирование с использованием комбинации данных (например комбинации блуждающих битов), которая тестирует физическую память (регистры данных и адресные регистры) и дешифратор команд. Однако диагностический охват составляет только 90%.<br/><br/></p><p id="P006D" class="formattext topleveltext indenttext" align="justify"><b>А.3.3 Самотестирование, обеспечиваемое оборудованием (одноканальное)</b><br/><br/></p><p id="P006D_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблица А.4).<br/><br/><br/></p><p id="P006D_2" class="formattext topleveltext indenttext" align="justify">Цель. Оперативное обнаружение отказов в процессоре с использованием специальных аппаратных средств, которые увеличивают скорость и расширяют область обнаружения отказов.<br/><br/></p><p id="P006D_3" class="formattext topleveltext indenttext" align="justify">Описание. Дополнительные специальные аппаратные средства обеспечивают функции самотестирования для обнаружения отказов. Например, таким средством может быть аппаратный модуль, который циклически контролирует выход на наличие конкретной битовой комбинации, используя механизм сторожевой схемы.<br/><br/></p><p id="P006F" class="formattext topleveltext indenttext" align="justify"><b>А.3.4 Запрограммированная обработка (одноканальная)</b><br/><br/></p><p id="P006F_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблица А.4).<br/><br/><br/></p><p id="P006F_2" class="formattext topleveltext indenttext" align="justify">Цель. Оперативное обнаружение отказов в процессоре.<br/><br/></p><p id="P006F_3" class="formattext topleveltext indenttext" align="justify">Описание. Процессоры могут быть спроектированы со встроенными специальными функциями распознавания или исправления отказов. До сих пор эти функции применялись только в относительно простых схемах и не получили широкого распространения. Однако такие функции не должны исключаться в будущих разработках.<br/><br/></p><p id="P006F_4" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P006F_5" class="formattext topleveltext indenttext" align="justify">Le Processeur <img class="base64" src="data:image;base64,R0lGODdhIQAQAIABAAAAAP///ywAAAAAIQAQAAACO4yPqcvtDyMCDFgZ6NGK8/dViXdtFBlmoqG17Tau6jx78WLTrhX2LKz7NXLBInFSMn14KIzzCY1Kp40CADs=" width="33" height="16"/>: un nouveau concept <img class="normal" src="https://api.docs.cntd.ru/img/12/00/10/32/42/135f542c-1dc5-4db8-9c2d-74263b12735c/P006F0001.png" width="51" height="17"/> a la <img class="normal" src="https://api.docs.cntd.ru/img/12/00/10/32/42/135f542c-1dc5-4db8-9c2d-74263b12735c/P006F0002.png" width="47" height="16"/> des <img class="normal" src="https://api.docs.cntd.ru/img/12/00/10/32/42/135f542c-1dc5-4db8-9c2d-74263b12735c/P006F0003.png" width="56" height="17"/> de transports. Gabriel, Martin, Wartski, Revue <img class="normal" src="https://api.docs.cntd.ru/img/12/00/10/32/42/135f542c-1dc5-4db8-9c2d-74263b12735c/P006F0004.png" width="55" height="16"/> des chemins de fer, No. 6, June 1990.<br/><br/></p><p id="P006F_6" class="formattext topleveltext indenttext" align="justify">Vital Coded Microprocessor Principles и Application for Various Transit Systems. P. Forin, IFAC Control Computers Communications in Transportation, 79-84, 1989.<br/><br/></p><p id="P0071" class="formattext topleveltext indenttext" align="justify"><b>A.3.5 Программное обнаружение несовпадений</b><br/><br/></p><p id="P0072" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблица А.4).<br/><br/><br/></p><p id="P0072_1" class="formattext topleveltext indenttext" align="justify">Цель. Оперативное обнаружение отказов в процессоре путем динамического программного сравнения.<br/><br/></p><p><img class="base64 sign" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZIAAAARCAMAAADAD9oKAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MTg4Q0U3ODQ0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MTg4Q0U3ODU0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoxODhDRTc4MjRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDoxODhDRTc4MzRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pos3t18AAAAzUExURfX19SQkJOrq6oeHh7y8vD8/P9/f31RUVMjIyLCwsHh4eJaWlmdnZ6Ojo9TU1AAAAP////kimdMAAAWSSURBVHja7FiJcuQoDAVzGcz1/1+7TwLRuDs9mZ2karZqQ1ViGz90PUngVv1nfMOo9fg2WarnNkf9FGxMHdDkf1jo3bXBg7o0YhIkfrXV0npvBfd48y94HQtV97XWZvBPfbpG29oikGfQ6oeRs4WLb4K2CGNq5wsltpX6B5TQYEa5/u6h9rdn31QdtXS0iKX1WZ360/o9Pl/3NmVq/ahk/cfwZ0X+bSL6T01Kxmq6Fj0MSDNPj+atGzF1+Y17z9IZMRfulHiH+ivMFvE7nm2ffQ26Q5+U0AKLatWUGFm63kU3SJycuwqNLgNJ1ONf6crorUNyEySMStQLlegNgSuSmiT5agizm0YyZwPNbEXLM64y2X0YcGgdN3ytU9FaLDCecHbCyFWVh0kjMvBEHK+rvx/tVIgOWSoTcZrRa+aVJxeOuLc5nG8Oj2cjCzdKDm1Uj9BCSFeO7sKBgKCxRWpXKNAiFtV2njBAGeqm2QBQaZKCjjDCA+vqnZJD802sAzu9q4EwRtde4djUG4kJeFObpsag4cXNNJKJejRY7pVO9EJiQf2XRJLlBEcW1Toooc48FcniBeN2nOALwwzMDXhDJv2CkoKENkS/NKzu0p74rRyOk0vcezgs0iXQhLDixE4J6YAALgUqoEq6VKpih0KosOuUUihxM+eGo6KIA3DEaTI8oJS7UZIybnhmOVX1wCiqLJSYmnr52WjShadTA7Obtsyl2lP22PquxG9kJ1VbSWN2gEXRfF4wlnri36xnTJBYC+R7ShyX17HNDIcXJSg8ddMqDi/p0+HOCGNfKclwPmdHBsVgp9mbHaemuwBMwtvmCK2pQqtwdpakiZIQg7pTAitwc+m6OVWyWFhnzQy9aMrcDZASSAJjgNlMo5R4UIJ1xbhnSsYr+p/LRslS1FfshQFIpb4v06WRvgBky4VfseOmPqy3zaKiZqp/SEmpOqhdqzi8pE+H6/2wu1PiCg9AkvOvlJi0r2ZbS7FooaMpdo8WYy6ixPFRZKcEE9Iz115irhdKWC/y1VquyIpWqU+i5GEapcRWJaGFFN9T4s7foyRQdqmNkqHvGJmn82AtUzed1s9vB63U6jj6ulOCnnbtWsXhJX06/J6S5LbDmKYuy/W11rgbobKpdRvmtNFKGpfS142SqEcL8CE99hIKV+ZmbDnr/NQL2Slx46wxoDSB2U27NS77eN4oGZaj91G6PChZiubzgo2+i9AKJbEd/S5yKA5ZAnCwLL6IcfYe2aHWb1rF4SV9OjwQ9XylZGwwORFSIeLUakYnHEVAgh6U0D7elY49C1OZNrM09pIC8EaJtnyjdHiIqE4qiY+K2YleProNrUcLhk8Lm2k3SgrF/KVKhuUQVUzfKFmK5vOCvVBytMSb69NeolwS66954oXTvnF2en3b3XmlIo3LPXF4SReHXZ5b3zMlCKcpAVse9z38XXh2kvo9htvuppy+LqeP0LgvBo/IpIJ+b/kQrGUDaM4XPvlBR9IPVq3mlkDldKIJ5k0vnGyzNh2myYvdtJ0S3wLtJeZOybT8uEabQ3kPSkSRUDRhs3HpI2uhKwKZKC8elADStJcASJOg7IcrF9BZvVBCPVi0bg6LdHF4IOqNkvmNaVM2iMWBHqoKLD9TvghAE92ecjdXxkxveb8tHElMxB7PblETZ1G2zDe1eNbBMkVEGdsDl4k3d709uAk86RPY3k2b5lZOIzbxnN2c5xk+LM9jv8PZaIBFkSwWBw9CRWwlLJ3fVZPTuYkUyLT+KPP7VBGAQmGev5tHTGMUrbvDU/pyeNn1oOQLQ74d6yeA51Hyfnn6FWDtmF8bueyXvzx+5XB/3d6/4rbfL+8Bz8Ne++X+s4z5pp/QLrtf/vJ47/B3U/L9Q/Fp4P87fn7R/c+NfwQYAFx9eFOvgdoSAAAAAElFTkSuQmCC"/></p><style>.base64.sign {display: none;}</style><p id="P0072_2" class="formattext topleveltext indenttext" align="justify">Описание. Два модуля взаимно обмениваются данными (включая результаты, промежуточные результаты и тестируемые данные). Если при сравнении данных, выдаваемых с использованием программных средств в каждом модуле, обнаруживаются различия, то это приводит к выдаче сообщений об отказе.<br/><br/></p><h3 id="P0075" class="formattext topleveltext indenttext" align="justify" title-level="3"><b>А.4 Постоянная память</b><br/><br/></h3><p id="P0075_1" class="formattext topleveltext indenttext" align="justify">Главная цель. Выявление модификаций информации в постоянной памяти.<br/><br/></p><p id="P0077" class="formattext topleveltext indenttext" align="justify"><b>А.4.1 Сохранение слов с многобитовой избыточностью (например контроль ROM с модифицированным кодом Хэмминга)</b><br/><br/></p><p id="P0077_1" class="formattext topleveltext indenttext" align="justify">Примечание - См. также А.5.6 и С.3.2. Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблица А.5).<br/><br/><br/></p><p id="P0077_2" class="formattext topleveltext indenttext" align="justify">Цель. Обнаружение всех однобитовых отказов, всех двухбитовых отказов и некоторых отказов во всех битах в 16-битовом слове.<br/><br/></p><p id="P0077_3" class="formattext topleveltext indenttext" align="justify">Описание. Каждое слово в памяти расширяется несколькими избыточными битами для формирования модифицированного кода Хэмминга с расстоянием, равным 4 (по меньшей мере). При каждом считывании слова проверка избыточных битов может указывать, произошло ли искажение. При обнаружении различия вырабатывается сообщение об отказе. Эта процедура может также использоваться для обнаружения ошибок адресации путем вычисления избыточных битов для объединения слова данных с его адресом.<br/><br/></p><p id="P0077_4" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0077_5" class="formattext topleveltext indenttext" align="justify"><img class="normal" src="https://api.docs.cntd.ru/img/12/00/10/32/42/135f542c-1dc5-4db8-9c2d-74263b12735c/P00770000.png" width="51" height="16"/> und korrigierbare Codes. W.W. Peterson, <img class="normal" src="https://api.docs.cntd.ru/img/12/00/10/32/42/135f542c-1dc5-4db8-9c2d-74263b12735c/P00770001.png" width="53" height="16"/>, Oldenburg, 1967.<br/><br/></p><p id="P0077_6" class="formattext topleveltext indenttext" align="justify">Error detecting and error correcting codes. R. W. Hemming, The Bell System Technical Journal 29 (2), 147-160, 1950.<br/><br/></p><p id="P0079" class="formattext topleveltext indenttext" align="justify"><b>A.4.2 Модифицируемая контрольная сумма</b><br/><br/></p><p id="P0079_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблица А.5).<br/><br/><br/></p><p id="P0079_2" class="formattext topleveltext indenttext" align="justify">Цель. Обнаружение всех отказов нечетных битов, то есть приблизительно 50% всех возможных битовых отказов.<br/><br/></p><p id="P0079_3" class="formattext topleveltext indenttext" align="justify">Описание. Контрольная сумма блока памяти образуется соответствующим алгоритмом, который обрабатывает все слова в блоке памяти. Эта контрольная сумма может храниться как дополнительное слово в ROM, либо может быть добавлена как дополнительное слово в блок памяти для того, чтобы алгоритм контрольной суммы выработал заранее заданное значение. В последнем тестировании памяти контрольная сумма создается снова с использованием того же алгоритма, и результат сравнивается с запомненным или заданным значением. При обнаружении различий вырабатывается сообщение об ошибке.<br/><br/></p><p id="P007B" class="formattext topleveltext indenttext" align="justify"><b>А.4.3 Сигнатура из одного слова (8 бит)</b><br/><br/></p><p id="P007C" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблица А.5).<br/><br/><br/></p><p id="P007C_1" class="formattext topleveltext indenttext" align="justify">Цель. Обнаружение всех однобитовых отказов и всех многобитовых ошибок в слове при достижении приблизительно 99,6% всех возможных битовых отказов.<br/><br/></p><p id="P007C_2" class="formattext topleveltext indenttext" align="justify">Описание. Содержимое блока памяти сжимается (с использованием аппаратных или программных средств) в одно слово памяти с использованием алгоритма контроля с помощью избыточного циклического кода (CRC). Типичный алгоритм CRC рассматривает все содержимое блока памяти как побайтовый или побитовый последовательный поток данных, в котором выполняется непрерывное полиномиальное деление с использованием полиномиального генератора. Остаток от деления сохраняется и представляет собой сжатое содержимое памяти - &quot;сигнатуру&quot; памяти. Сигнатура вычисляется каждый раз при последующем тестировании и сравнивается с уже запомненным значением. При обнаружении различий выдается сообщение об ошибке.<br/><br/></p><p id="P007E" class="formattext topleveltext indenttext" align="justify"><b>А.4.4 Сигнатура из двух слов (16 бит)</b><br/><br/></p><p id="P007E_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблица А.5).<br/><br/><br/></p><p id="P007E_2" class="formattext topleveltext indenttext" align="justify">Цель. Обнаружение всех однобитовых ошибок и всех многобитовых ошибок в слове составляет примерно 99,998% всех возможных битовых ошибок.<br/><br/></p><p id="P007E_3" class="formattext topleveltext indenttext" align="justify">Описание. Данная процедура вычисляет сигнатуру с использованием алгоритма контроля с помощью CRC, однако длина результирующего значения составляет по меньшей мере два слова. Расширенная сигнатура заносится в память, повторно вычисляется и сравнивается как одно слово. При обнаружении различий между сохраненной и повторно вычисленной сигнатурами выдается сообщение об ошибке.<br/><br/></p><p id="P0080" class="formattext topleveltext indenttext" align="justify"><b>А.4.5 Дублирование блока (например дублирование ROM в аппаратном и программном исполнении)</b><br/><br/></p><p id="P0080_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблица А.5).<br/><br/><br/></p><p id="P0080_2" class="formattext topleveltext indenttext" align="justify">Цель. Обнаружение всех битовых ошибок.<br/><br/></p><p id="P0080_3" class="formattext topleveltext indenttext" align="justify">Описание. Адресное пространство дублируется в двух областях памяти. Первая область памяти работает в нормальном режиме. Вторая содержит ту же информацию и доступна параллельно с первой. Их выходы сравниваются, и при обнаружении различий выдается сообщение об ошибке. Для обнаружения некоторых видов битовых ошибок данные должны запоминаться инверсно в одной из двух областей памяти и инвертироваться обратно при чтении.<br/><br/></p><h3 id="P0083" class="formattext topleveltext indenttext" align="justify" title-level="3"><b>А.5 Память с произвольным доступом</b><br/><br/></h3><p id="P0083_1" class="formattext topleveltext indenttext" align="justify">Главная цель. Обнаружение отказов во время адресации, записи, запоминания и считывания.<br/><br/></p><p id="P0083_2" class="formattext topleveltext indenttext" align="justify">Примечание - Случайные сбои, перечисленные в МЭК 61508-2, таблица А.1, являются отказами, которые должны быть обнаружены в процессе эксплуатации или должны быть проанализированы при выводе доли безопасных отказов. Причинами случайных ошибок являются: (1) альфа-частицы, образовавшиеся в результате процесса распада, (2) нейтроны, (3) внешний источник электромагнитного излучения и (4) внутренние перекрестные помехи. Внешний источник электромагнитного излучения должен соответствовать другим требованиям настоящего стандарта.<br/><br/><br/></p><p id="P0083_3" class="formattext topleveltext indenttext" align="justify">Результаты воздействия альфа-частиц и нейтронов могут быть обработаны функционирующими средствами обеспечения полноты безопасности. Но такие средства обеспечения полноты безопасности эффективны для случайных отказов аппаратных средств и не эффективны для случайных сбоев, например тесты для ОЗУ, такие как &quot;блуждающая траектория&quot;, GALPAT и т.д., не являются эффективными, тогда как методы, использующие контроль четности и коды с исправлением ошибок, возвращающие содержимое ячеек памяти, являются эффективными.<br/><br/></p><p id="P0083_4" class="formattext topleveltext indenttext" align="justify">Случайный сбой происходит, когда излучение вызывает такой заряд, который может изменить состояние или переключить с низкого уровня напряжения на высокий ячейку полупроводниковой памяти, регистр, защелку или триггер. Такую случайную ошибку называют &quot;исправимой&quot;, потому что сама схема излучением не повреждается. Такие ошибки разделяют на однобитовые нарушения (SBU) или однособытийные нарушения (SEU) и многобитовые нарушения (MBU).<br/><br/></p><p id="P0083_5" class="formattext topleveltext indenttext" align="justify">Если схема, в которой произошел сбой, является запоминающим элементом, таким как ячейка памяти или триггер, то ее состояние сохранится до следующей (намеченной) операции записи. Новые данные будут храниться правильно. В комбинаторной схеме это приведет скорее к незначительному сбою, потому что существует постоянный поток энергии из компонента, управляющего этим узлом. Влияние на соединительные провода и линии связи также может быть незначительным. Однако из-за большей емкости воздействие на них альфа-частиц и нейтронов считают незначительным.<br/><br/></p><p id="P0083_6" class="formattext topleveltext indenttext" align="justify">Такие случайные сбои могут происходить в переменной памяти любого вида, то есть в DRAM, SRAM, регистровой памяти в MP, кэш-памяти, конвейерах, регистрах конфигурации устройств, таких как АDС, DMA, MMU, контроллер прерываний, сложные таймеры. Чувствительность к альфа-частицам и нейтронам зависит от напряжения питания и геометрии. Небольшие конфигурации с напряжением питания 2,5 В и особенно ниже 1,8 В потребуют более серьезной оценки и более эффективных мер защиты.<br/><br/></p><p id="P0084" class="formattext topleveltext indenttext" align="justify">Интенсивность случайных сбоев для (встроенной) памяти находится в диапазоне от 700 Fit/MBit до 1200 Fit/MBit [см. перечисления а) и i) ниже]). Это эталонное значение для сравнения с данными, полученными для устройств, реализованных на основе кремниевой технологии. До недавнего времени полагали, что SBU были доминирующими, но последний прогноз (см. перечисление а) ниже) показывает растущий процент MBU в общей интенсивности случайных сбоев (SEP) для технологий менее 65 нм.<br/><br/></p><p id="P0084_1" class="formattext topleveltext indenttext" align="justify">Более подробная информация о случайных сбоях дана в следующих источниках:<br/><br/></p><p id="P0086" class="formattext topleveltext indenttext" align="justify">a) Altitude SEE Test European Platform (ASTEP) and First Results in CMOS 130 nm SRAM. J.-L. Autran, P. Roche, С. Sudre et al. Nuclear Science, IEEE Transactions on Volume 54, Issue 4, Aug. 2007 Page(s):1002-1009;<br/><br/></p><p id="P0088" class="formattext topleveltext indenttext" align="justify">b) Radiation-Induced Soft Errors in Advanced Semiconductor Technologies, Robert С. Baumann, Fellow, IEEE, IEEE TRANSACTIONS ON DEVICE AND MATERIALS RELIABILITY, VOL. 5, NO. 3, SEPTEMBER 2005;<br/><br/></p><p id="P008A" class="formattext topleveltext indenttext" align="justify">c) Soft errors' impact on system reliability, Ritesh Mastipuram and Edwin С Wee, Cypress Semiconductor, 2004;<br/><br/></p><p id="P008C" class="formattext topleveltext indenttext" align="justify">d) Trends And Challenges In VLSI Circuit Reliability, С. Costantinescu, Intel, 2003, IEEE Computer Society;<br/><br/></p><p id="P008E" class="formattext topleveltext indenttext" align="justify">e) Basic mechanisms and modeling of single-event upset in digital microelectronics, P.E. Dodd and L.W. Massengill, IEEE Trans. Nucl. Sci., vol. 50, no. 3, pp.583-602, Jun. 2003;<br/><br/></p><p id="P0090" class="formattext topleveltext indenttext" align="justify">f) Destructive single-event effects in semiconductor devices and ICs, F.W. Sexton, IEEE Trans. Nucl. Sci., vol. 50, no. 3, pp.603-621, Jun. 2003;<br/><br/></p><p id="P0092" class="formattext topleveltext indenttext" align="justify">g) Coming Challenges in Microarchitecture and Architecture, Ronen, Mendelson, Proceedings of the IEEE, Volume 89, Issue 3, Mar 2001 Page(s):325-340;<br/><br/></p><p id="P0094" class="formattext topleveltext indenttext" align="justify">h) Scaling and Technology Issues for Soft Error Rates, A Johnston, 4th Annual Research Conference on Reliability Stanford University, October 2000;<br/><br/></p><p id="P0096" class="formattext topleveltext indenttext" align="justify">i) International Technology Roadmap for Semiconductors (ITRS), several papers.<br/><br/></p><p id="P0098" class="formattext topleveltext indenttext" align="justify"><b>A.5.1 Тесты &quot;шахматная доска&quot; или &quot;марш&quot; для памяти с произвольным доступом</b><br/><br/></p><p id="P0098_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблица А.6).<br/><br/><br/></p><p id="P0098_2" class="formattext topleveltext indenttext" align="justify">Цель. Обнаружение преимущественно статических битовых ошибок.<br/><br/></p><p id="P0098_3" class="formattext topleveltext indenttext" align="justify">Описание. Расположенная в шахматном порядке битовая комбинация нулей и единиц записывается в ячейки памяти с битовой организацией. Затем эти ячейки анализируются попарно с тем, чтобы убедиться в их одинаковости и правильности. Адрес первой ячейки такой пары является переменным, а адрес второй ячейки этой пары образуется путем битового инвертирования первого адреса. При первом прохождении диапазон адресов памяти проходят в направлении более высоких адресов переменных адресов, а при втором прохождении - в направлении более низких адресов. После этого оба прохождения повторяются с заранее заданным инвертированием. При обнаружении какого-либо различия выдается сообщение об отказе.<br/><br/></p><p id="P0098_4" class="formattext topleveltext indenttext" align="justify">При &quot;маршевом&quot; тестировании памяти с произвольным доступом ячейки памяти с битовой организацией инициализируются унифицированным потоком битов. При первом прохождении ячейки анализируются в нисходящей последовательности; проверяется правильность содержимого каждой ячейки и ее содержимое инвертируется. Основа, созданная в первом прохождении, рассматривается при втором прохождении в убывающем порядке и так же обрабатывается. Первые прохождения повторяются с инвертируемыми предварительными значениями в третьем и четвертом прохождениях. При обнаружении различий выдается сообщение об отказе.<br/><br/></p><p id="P009A" class="formattext topleveltext indenttext" align="justify"><b>А.5.2 Тест &quot;блуждающая траектория&quot; для памяти с произвольным доступом</b><br/><br/></p><p id="P009A_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблица А.6).<br/><br/><br/></p><p id="P009A_2" class="formattext topleveltext indenttext" align="justify">Цель. Обнаружение статических и динамических ошибочных битов и перекрестных помех между ячейками памяти.<br/><br/></p><p id="P009A_3" class="formattext topleveltext indenttext" align="justify">Описание. Тестируемая область памяти инициализируется унифицированным потоком битов. Затем первая ячейка инвертируется, и остальная часть памяти анализируется на правильность. После этого первая ячейка повторно инвертируется для возврата в исходное значение, и вся процедура повторяется для следующей ячейки. Второе прохождение &quot;модели блуждающего бита&quot; осуществляется при инверсии всех первоначально назначенных значений памяти. При обнаружении различий выдается сообщение об ошибке.<br/><br/></p><p id="P009C" class="formattext topleveltext indenttext" align="justify"><b>А.5.3 Тест &quot;GALPAT&quot; или &quot;Прозрачный GALPAT&quot; для памяти с произвольным доступом</b><br/><br/></p><p id="P009C_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблица А.6).<br/><br/><br/></p><p id="P009C_2" class="formattext topleveltext indenttext" align="justify">Цель. Обнаружение статических битовых отказов и большой части динамических связей.<br/><br/></p><p id="P009C_3" class="formattext topleveltext indenttext" align="justify">Описание. При тестировании памяти с произвольным доступом &quot;попарной записью-считыванием&quot; выбранная область памяти сначала инициализируется унифицированно (то есть все 0 или все 1). После этого первая ячейка памяти тестируется и затем инвертируется, и все остальные ячейки анализируются на правильность содержимого. После каждого доступа по чтению к одной из оставшихся ячеек инвертированная ячейка также проверяется. Эта процедура повторяется для каждой ячейки в выбранной области памяти. Второе прохождение выполняется противоположно первому. Любые различия приводят к выдаче сообщения об ошибке.<br/><br/></p><p id="P009C_4" class="formattext topleveltext indenttext" align="justify">Тестирование &quot;прозрачной попарной записью-считыванием&quot; представляет собой вариацию описанной выше процедуры: вместо инициализации всех ячеек в выбранной области памяти существующее содержимое остается неизменным, а для сравнения содержимого набора ячеек используются контрольные суммы (сигнатуры). Выбирается первая тестируемая ячейка области памяти и вычисляется и сохраняется сигнатура S1 всех оставшихся ячеек области. Затем тестируемые ячейки инвертируются, и повторно вычисляется сигнатура S2. (После каждого доступа по чтению к одной из оставшихся ячеек инвертируемая ячейка также проверяется.) Сигнатура S2 сравнивается с сигнатурой S1 и при любом различии выдается сообщение об ошибке. Тестируемая ячейка повторно инвертируется для повторного установления исходного содержимого и сигнатура S3 всех оставшихся ячеек повторно вычисляется и сравнивается с сигнатурой S1. Любые различия приводят к выдаче сообщения об ошибке. Все ячейки памяти в выбранной области тестируются тем же способом.<br/><br/></p><p id="P009E" class="formattext topleveltext indenttext" align="justify"><b>А.5.4 Тест &quot;Абраам&quot; для памяти с произвольным доступом</b><br/><br/></p><p id="P009E_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблица А.6).<br/><br/><br/></p><p id="P009E_2" class="formattext topleveltext indenttext" align="justify">Цель. Обнаружение всех постоянных отказов и отказов в соединениях между ячейками памяти.<br/><br/></p><p id="P009E_3" class="formattext topleveltext indenttext" align="justify">Описание. Диагностический охват выше, чем при тесте &quot;попарная запись-считывание&quot;. Число операций, необходимых для выполнения всего тестирования памяти, составляет примерно 30<img class="base64" src="data:image;base64,R0lGODdhDQAPAIABAAAAAP///ywAAAAADQAPAAACGYyPqcvtAAxksdIYcJqZHo1o1vaBzommSwEAOw==" width="13" height="15"/>, где <img class="base64" src="data:image;base64,R0lGODdhDQAPAIABAAAAAP///ywAAAAADQAPAAACGYyPqcvtAAxksdIYcJqZHo1o1vaBzommSwEAOw==" width="13" height="15"/> - число ячеек памяти. Тестирование может быть &quot;прозрачным&quot; при выполнении запоминания и тестирования в различных временных сегментах в периоде рабочего цикла.<br/><br/></p><p id="P009E_4" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P009E_5" class="formattext topleveltext indenttext" align="justify">Efficient Algorithms for Testing Semiconductor Random-Access Memories. R. Nair, S.M. Thatte, J.A. Abraham, IEEE Trans. Comput. C-27 (6), 572-576, 1978.<br/><br/></p><p id="P00A0" class="formattext topleveltext indenttext" align="justify"><b>A.5.5 Однобитовая избыточность (например контроль памяти с произвольным доступом с помощью бита четности)</b><br/><br/></p><p id="P00A0_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблица А.6).<br/><br/><br/></p><p id="P00A0_2" class="formattext topleveltext indenttext" align="justify">Цель. Обнаружение 50% всех возможных битовых отказов в тестируемой области памяти.<br/><br/></p><p id="P00A0_3" class="formattext topleveltext indenttext" align="justify">Описание. Каждое слово в памяти расширяется на один бит (бит четности), который дополняет каждое слово до четного или нечетного числа логических единиц. Четность слова данных проверяется при каждом чтении. При обнаружении ложного числа единиц выдается сообщение об ошибке. Выбор четности или нечетности должен осуществляться так, чтобы всякий раз в случае отказа не выдавалось ничего, кроме нулевого (0) и единичного (1) слова, вырабатывалось уведомление о том, что это слово неправильно закодировано. Контроль четности также может быть использован для обнаружения ошибок адресации, если четность определяется для объединения слова данных с его адресом.<br/><br/></p><p id="P00A2" class="formattext topleveltext indenttext" align="justify"><b>А.5.6 Контроль памяти с произвольным доступом с помощью модифицированного кода Хэмминга или обнаружение ошибок данных с помощью кодов обнаружения и исправления ошибок (EDC)</b><br/><br/></p><p id="P00A2_1" class="formattext topleveltext indenttext" align="justify">Примечание - См. также А.4.1 и С.3.2. Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблица А.6).<br/><br/><br/></p><p id="P00A2_2" class="formattext topleveltext indenttext" align="justify">Цель. Обнаружение всех нечетных битовых отказов, всех двухбитовых отказов, некоторых трехбитовых отказов и некоторых многобитовых отказов.<br/><br/></p><p id="P00A2_3" class="formattext topleveltext indenttext" align="justify">Описание. Каждое слово в памяти расширяется несколькими избыточными битами для выработки модифицированного кода Хэмминга с расстоянием Хэмминга, равным по меньшей мере 4. При каждом считывании слова проверка избыточных битов может указывать, произошло ли искажение. При обнаружении различий выдается сообщение об отказе. Эта процедура может быть также использована для обнаружения ошибок адресации при вычислении избыточных битов для объединения данных с его адресом.<br/><br/></p><p id="P00A2_4" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P00A2_5" class="formattext topleveltext indenttext" align="justify"><img class="normal" src="https://api.docs.cntd.ru/img/12/00/10/32/42/135f542c-1dc5-4db8-9c2d-74263b12735c/P00A20000.png" width="51" height="16"/> und korrigierbare Codes. W.W. Peterson, <img class="normal" src="https://api.docs.cntd.ru/img/12/00/10/32/42/135f542c-1dc5-4db8-9c2d-74263b12735c/P00A20001.png" width="53" height="16"/>, Oldenburg, 1967.<br/><br/></p><p id="P00A2_6" class="formattext topleveltext indenttext" align="justify">Error detecting и error correcting codes. R.W. Hamming, The Bell System Technical Journal 29 (2), 147-160, 1950.<br/><br/></p><p><img class="base64 sign" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZIAAAARCAMAAADAD9oKAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MTg4Q0U3ODQ0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MTg4Q0U3ODU0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoxODhDRTc4MjRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDoxODhDRTc4MzRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pos3t18AAAAzUExURfX19SQkJOrq6oeHh7y8vD8/P9/f31RUVMjIyLCwsHh4eJaWlmdnZ6Ojo9TU1AAAAP////kimdMAAAWSSURBVHja7FiJcuQoDAVzGcz1/1+7TwLRuDs9mZ2karZqQ1ViGz90PUngVv1nfMOo9fg2WarnNkf9FGxMHdDkf1jo3bXBg7o0YhIkfrXV0npvBfd48y94HQtV97XWZvBPfbpG29oikGfQ6oeRs4WLb4K2CGNq5wsltpX6B5TQYEa5/u6h9rdn31QdtXS0iKX1WZ360/o9Pl/3NmVq/ahk/cfwZ0X+bSL6T01Kxmq6Fj0MSDNPj+atGzF1+Y17z9IZMRfulHiH+ivMFvE7nm2ffQ26Q5+U0AKLatWUGFm63kU3SJycuwqNLgNJ1ONf6crorUNyEySMStQLlegNgSuSmiT5agizm0YyZwPNbEXLM64y2X0YcGgdN3ytU9FaLDCecHbCyFWVh0kjMvBEHK+rvx/tVIgOWSoTcZrRa+aVJxeOuLc5nG8Oj2cjCzdKDm1Uj9BCSFeO7sKBgKCxRWpXKNAiFtV2njBAGeqm2QBQaZKCjjDCA+vqnZJD802sAzu9q4EwRtde4djUG4kJeFObpsag4cXNNJKJejRY7pVO9EJiQf2XRJLlBEcW1Toooc48FcniBeN2nOALwwzMDXhDJv2CkoKENkS/NKzu0p74rRyOk0vcezgs0iXQhLDixE4J6YAALgUqoEq6VKpih0KosOuUUihxM+eGo6KIA3DEaTI8oJS7UZIybnhmOVX1wCiqLJSYmnr52WjShadTA7Obtsyl2lP22PquxG9kJ1VbSWN2gEXRfF4wlnri36xnTJBYC+R7ShyX17HNDIcXJSg8ddMqDi/p0+HOCGNfKclwPmdHBsVgp9mbHaemuwBMwtvmCK2pQqtwdpakiZIQg7pTAitwc+m6OVWyWFhnzQy9aMrcDZASSAJjgNlMo5R4UIJ1xbhnSsYr+p/LRslS1FfshQFIpb4v06WRvgBky4VfseOmPqy3zaKiZqp/SEmpOqhdqzi8pE+H6/2wu1PiCg9AkvOvlJi0r2ZbS7FooaMpdo8WYy6ixPFRZKcEE9Iz115irhdKWC/y1VquyIpWqU+i5GEapcRWJaGFFN9T4s7foyRQdqmNkqHvGJmn82AtUzed1s9vB63U6jj6ulOCnnbtWsXhJX06/J6S5LbDmKYuy/W11rgbobKpdRvmtNFKGpfS142SqEcL8CE99hIKV+ZmbDnr/NQL2Slx46wxoDSB2U27NS77eN4oGZaj91G6PChZiubzgo2+i9AKJbEd/S5yKA5ZAnCwLL6IcfYe2aHWb1rF4SV9OjwQ9XylZGwwORFSIeLUakYnHEVAgh6U0D7elY49C1OZNrM09pIC8EaJtnyjdHiIqE4qiY+K2YleProNrUcLhk8Lm2k3SgrF/KVKhuUQVUzfKFmK5vOCvVBytMSb69NeolwS66954oXTvnF2en3b3XmlIo3LPXF4SReHXZ5b3zMlCKcpAVse9z38XXh2kvo9htvuppy+LqeP0LgvBo/IpIJ+b/kQrGUDaM4XPvlBR9IPVq3mlkDldKIJ5k0vnGyzNh2myYvdtJ0S3wLtJeZOybT8uEabQ3kPSkSRUDRhs3HpI2uhKwKZKC8elADStJcASJOg7IcrF9BZvVBCPVi0bg6LdHF4IOqNkvmNaVM2iMWBHqoKLD9TvghAE92ecjdXxkxveb8tHElMxB7PblETZ1G2zDe1eNbBMkVEGdsDl4k3d709uAk86RPY3k2b5lZOIzbxnN2c5xk+LM9jv8PZaIBFkSwWBw9CRWwlLJ3fVZPTuYkUyLT+KPP7VBGAQmGev5tHTGMUrbvDU/pyeNn1oOQLQ74d6yeA51Hyfnn6FWDtmF8bueyXvzx+5XB/3d6/4rbfL+8Bz8Ne++X+s4z5pp/QLrtf/vJ47/B3U/L9Q/Fp4P87fn7R/c+NfwQYAFx9eFOvgdoSAAAAAElFTkSuQmCC"/></p><style>.base64.sign {display: none;}</style><p id="P00A4" class="formattext topleveltext indenttext" align="justify"><b>A.5.7 Дублирование со сравнением памяти с произвольным доступом с аппаратными или программными средствами и тестирование чтением/записью</b><br/><br/></p><p id="P00A4_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблица А.6).<br/><br/><br/></p><p id="P00A4_2" class="formattext topleveltext indenttext" align="justify">Цель. Обнаружение всех битовых отказов.<br/><br/></p><p id="P00A4_3" class="formattext topleveltext indenttext" align="justify">Описание. Адресное пространство содержит две части. Первая часть памяти функционирует в нормальном режиме. Вторая часть памяти содержит ту же информацию и доступна параллельно с первой. Выходы этих частей памяти сравниваются. При обнаружении различий выдается сообщение об ошибке. Для обнаружения некоторых видов битовых ошибок данные должны сохраняться инверсно в одной из двух частей памяти и обратно инвертироваться при чтении.<br/><br/></p><h3 id="P00A7" class="formattext topleveltext indenttext" align="justify" title-level="3"><b>А.6 Устройства ввода-вывода и интерфейсы (внешний обмен)</b><br/><br/></h3><p id="P00A7_1" class="formattext topleveltext indenttext" align="justify">Главная цель. Обнаружение отказов на устройствах ввода и вывода (цифровые, аналоговые, последовательные или параллельные) и предотвращение дальнейшей передачи недопустимых выходных данных.<br/><br/></p><p id="P00A9" class="formattext topleveltext indenttext" align="justify"><b>А.6.1 Тестирующая комбинация</b><br/><br/></p><p id="P00A9_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблицы А.7, А.13 и А.14).<br/><br/><br/></p><p id="P00A9_2" class="formattext topleveltext indenttext" align="justify">Цель. Обнаружение статических отказов (константные отказы) и перекрестных помех.<br/><br/></p><p id="P00A9_3" class="formattext topleveltext indenttext" align="justify">Описание. Этот метод реализует независимое от потока данных циклическое тестирование входных и выходных элементов. В нем используются определенные тестирующие комбинации для сравнения с соответствующими этим тестирующим комбинациям предполагаемыми значениями. Информация тестирующей комбинации, восприятие и оценка тестирующей комбинации должны быть независимы друг от друга. Тестирующие комбинации не должны неблагоприятно влиять на операции УО.<br/><br/></p><p id="P00AB" class="formattext topleveltext indenttext" align="justify"><b>А.6.2 Кодовая защита</b><br/><br/></p><p id="P00AB_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблицы А.7, А.15, А.16 и А.18).<br/><br/><br/></p><p id="P00AB_2" class="formattext topleveltext indenttext" align="justify">Цель. Обнаружение случайных отказов аппаратных средств и систематических ошибок в потоке ввода/вывода данных.<br/><br/></p><p id="P00AB_3" class="formattext topleveltext indenttext" align="justify">Описание. Процедура, реализующая кодовую защиту, защищает вводимую и выводимую информацию от систематических и случайных отказов аппаратных средств. Кодовая защита обеспечивает зависимое от потока данных обнаружение отказов входных и выходных модулей, основываясь на избыточности информации и/или временной избыточности. Обычно избыточная информация налагается на входные и/или выходные данные; тем самым обеспечиваются средства для мониторинга правильности операций входных и выходных схем. Возможно применение многих методов - например, сигнал несущей частоты может налагаться на выходной сигнал датчика. После этого логический модуль может проверить наличие частоты несущей, либо на выходе канала могут быть добавлены избыточные кодовые биты для контроля действительности прохождения сигнала между логическим модулем и оконечным исполнительным механизмом.<br/><br/></p><p id="P00AD" class="formattext topleveltext indenttext" align="justify"><b>А.6.3 Многоканальное параллельное выходное устройство</b><br/><br/></p><p id="P00AD_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблица А.7).<br/><br/><br/></p><p id="P00AD_2" class="formattext topleveltext indenttext" align="justify">Цель. Обнаружение случайных отказов аппаратных средств (константные отказы), отказов, обусловленных внешними воздействиями, временных сбоев, отказов адресации, постепенных отказов и самоустраняющихся отказов.<br/><br/></p><p id="P00AD_3" class="formattext topleveltext indenttext" align="justify">Описание. Это зависимое от потока данных многоканальное параллельное выходное устройство с независимыми выходами для обнаружения случайных аппаратных отказов. Обнаружение отказов осуществляется с помощью внешних компараторов. При появлении отказа УО непосредственно отключается. Это устройство действует только в том случае, если поток данных изменяется в интервале диагностического тестирования.<br/><br/></p><p id="P00AF" class="formattext topleveltext indenttext" align="justify"><b>А.6.4 Средство контроля выходов</b><br/><br/></p><p id="P00AF_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблица А.7).<br/><br/><br/></p><p id="P00AF_2" class="formattext topleveltext indenttext" align="justify">Цель. Обнаружение случайных отказов, отказов, обусловленных внешними воздействиями, временных сбоев, отказов адресации, постепенных отказов (для аналоговых сигналов) и самоустраняющихся отказов.<br/><br/></p><p id="P00AF_3" class="formattext topleveltext indenttext" align="justify">Описание. Это устройство, зависимое от потока данных, сравнивает выходные данные с независимыми входными данными для обеспечения совместимости с областью допустимых значений (время, диапазон). Обнаруженный отказ не всегда относится к неправильному выходному сигналу. Это устройство действует только в том случае, если поток данных изменяется в интервале диагностического тестирования.<br/><br/></p><p id="P00B1" class="formattext topleveltext indenttext" align="justify"><b>А.6.5 Сравнение/голосование входных данных</b><br/><br/></p><p id="P00B1_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблицы А.7 и А.13).<br/><br/><br/></p><p id="P00B1_2" class="formattext topleveltext indenttext" align="justify">Цель. Обнаружение случайных отказов, отказов, обусловленных внешними воздействиями, временных сбоев, отказов адресации, постепенных отказов (для аналоговых сигналов) и самоустраняющихся отказов.<br/><br/></p><p id="P00B1_3" class="formattext topleveltext indenttext" align="justify">Описание. Это устройство, зависимое от потока данных, сравнивает выходные данные с независимыми входными данными для обеспечения совместимости с областью допустимых значений (время, диапазон). Реализуемая избыточность может быть 1 из 2, 2 из 3 или более высокая. Это устройство действует только в том случае, если поток данных изменяется в интервале диагностического тестирования.<br/><br/></p><h3 id="P00B4" class="formattext topleveltext indenttext" align="justify" title-level="3"><b>А.7. Маршруты данных (внутренний обмен)</b><br/><br/></h3><p id="P00B4_1" class="formattext topleveltext indenttext" align="justify">Главная цель. Обнаружение отказов, обусловленных искажениями при передаче информации.<br/><br/></p><p id="P00B6" class="formattext topleveltext indenttext" align="justify"><b>А.7.1 Однобитовая аппаратная избыточность</b><br/><br/></p><p id="P00B6_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблица А.8).<br/><br/><br/></p><p id="P00B6_2" class="formattext topleveltext indenttext" align="justify">Цель. Обнаружение всех нечетно-битовых ошибок, то есть 50% всех возможных битовых ошибок в потоке данных.<br/><br/></p><p id="P00B6_3" class="formattext topleveltext indenttext" align="justify">Описание. Шина расширяется на одну линию (бит) и эта дополнительная линия (бит) используется для обнаружения отказов путем проверки на четность.<br/><br/></p><p id="P00B8" class="formattext topleveltext indenttext" align="justify"><b>А.7.2 Многобитовая аппаратная избыточность</b><br/><br/></p><p id="P00B8_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблица А.8).<br/><br/><br/></p><p id="P00B8_2" class="formattext topleveltext indenttext" align="justify">Цель. Обнаружение отказов в процессе передачи по шине и в последовательных каналах связи.<br/><br/></p><p id="P00B8_3" class="formattext topleveltext indenttext" align="justify">Описание. Шина расширяется на две или более линий (битов) и эти дополнительные линии (биты) используются для обнаружения отказов методом кода Хэмминга.<br/><br/></p><p id="P00BA" class="formattext topleveltext indenttext" align="justify"><b>А.7.3 Полная аппаратная избыточность</b><br/><br/></p><p id="P00BA_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблица А.8).<br/><br/><br/></p><p id="P00BA_2" class="formattext topleveltext indenttext" align="justify">Цель. Обнаружение отказов в процессе передачи данных путем сравнения сигналов двух шин.<br/><br/></p><p id="P00BA_3" class="formattext topleveltext indenttext" align="justify">Описание. Шина дублируется и дополнительные линии (биты) используются для обнаружения отказов.<br/><br/></p><p id="P00BC" class="formattext topleveltext indenttext" align="justify"><b>А.7.4 Анализ с использованием тестирующих комбинаций</b><br/><br/></p><p id="P00BC_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблица А.8).<br/><br/><br/></p><p id="P00BC_2" class="formattext topleveltext indenttext" align="justify">Цель. Обнаружение статических отказов (постоянных отказов) и перекрестных помех.<br/><br/></p><p id="P00BC_3" class="formattext topleveltext indenttext" align="justify">Описание. Осуществляется независимое от потока данных циклическое тестирование маршрутов данных. Используется определенная тестирующая комбинация для сравнения наблюдаемых значений с соответствующими предполагаемыми значениями.<br/><br/></p><p id="P00BC_4" class="formattext topleveltext indenttext" align="justify">Восприятие информации о тестирующей комбинации и ее оценка должны быть независимы друг от друга. Тестирующие комбинации не должны неблагоприятно влиять на операции УО.<br/><br/></p><p id="P00BE" class="formattext topleveltext indenttext" align="justify"><b>А.7.5 Избыточность при передаче</b><br/><br/></p><p id="P00BE_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблица А.8).<br/><br/><br/></p><p id="P00BE_2" class="formattext topleveltext indenttext" align="justify">Цель. Обнаружение самоустраняющихся отказов в обмене по шине.<br/><br/></p><p id="P00BE_3" class="formattext topleveltext indenttext" align="justify">Описание. Информация передается последовательно несколько раз. Повторение осуществляется только для обнаружения самоустраняющихся отказов.<br/><br/></p><p id="P00C0" class="formattext topleveltext indenttext" align="justify"><b>А.7.6 Информационная избыточность</b><br/><br/></p><p id="P00C0_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблица А.8).<br/><br/><br/></p><p id="P00C0_2" class="formattext topleveltext indenttext" align="justify">Цель. Обнаружение отказов в обмене по шине.<br/><br/></p><p id="P00C0_3" class="formattext topleveltext indenttext" align="justify">Описание. Данные передаются блоками наряду с вычислениями контрольной суммы для каждого блока. После этого приемник повторно вычисляет контрольную сумму полученных данных. Результат сравнивается с полученной контрольной суммой.<br/><br/></p><h3 id="P00C3" class="formattext topleveltext indenttext" align="justify" title-level="3"><b>А.8 Источник питания</b><br/><br/></h3><p id="P00C3_1" class="formattext topleveltext indenttext" align="justify">Главная цель. Обнаружение или устойчивость к отказам, обусловленным источником питания.<br/><br/></p><p id="P00C5" class="formattext topleveltext indenttext" align="justify"><b>А.8.1 Защита от броска напряжения с помощью безопасного выключения</b><br/><br/></p><p id="P00C5_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблица А.9).<br/><br/><br/></p><p id="P00C5_2" class="formattext topleveltext indenttext" align="justify">Цель. Защита систем, связанных с безопасностью, от броска напряжения.<br/><br/></p><p id="P00C5_3" class="formattext topleveltext indenttext" align="justify">Описание. Бросок напряжения обнаруживается достаточно рано с тем, чтобы все выходы могли быть переключены в безопасное состояние процедурой отключения питания или переключились на второй блок питания.<br/><br/></p><p id="P00C5_4" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P00C5_5" class="formattext topleveltext indenttext" align="justify">Guidelines for Safe Automation of Chemical Processes. CCPS, AlChE, New York, 1993, ISBN-10: 0-8169-0554-1, ISBN-13: 978-0-8169-0554-6.<br/><br/></p><p id="P00C7" class="formattext topleveltext indenttext" align="justify"><b>A.8.2 Управление напряжением (вторичным)</b><br/><br/></p><p id="P00C7_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблица А.9).<br/><br/><br/></p><p id="P00C7_2" class="formattext topleveltext indenttext" align="justify">Цель. Контроль вторичных напряжений и инициализация безопасного состояния, если значение напряжения не находится в заданном диапазоне.<br/><br/></p><p id="P00C7_3" class="formattext topleveltext indenttext" align="justify">Описание. Вторичное напряжение контролируется и питание отключается, либо происходит переключение на второй блок питания, если напряжение не находится в заданном диапазоне.<br/><br/></p><p id="P00C9" class="formattext topleveltext indenttext" align="justify"><b>А.8.3 Отключение системы безопасности при снижении питания</b><br/><br/></p><p id="P00C9_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблица А.9).<br/><br/><br/></p><p id="P00C9_2" class="formattext topleveltext indenttext" align="justify">Цель. Отключение питания с сохранением системой безопасности имеющейся информации.<br/><br/></p><p id="P00C9_3" class="formattext topleveltext indenttext" align="justify">Описание. Заранее выявляется бросок напряжения или слишком низкое напряжение питания для того, чтобы процедура отключения питания успела сохранить внутреннее состояние в неэнергозависимой памяти (при необходимости) и тем самым установить все выходы в безопасное состояние, или же все выходы переключить в безопасное состояние, либо происходит переключение на второй блок питания.<br/><br/></p><h3 id="P00CC" class="formattext topleveltext indenttext" align="justify" title-level="3"><b>А.9 Временной и логический контроль последовательности выполнения программ</b><br/><br/></h3><p id="P00CC_1" class="formattext topleveltext indenttext" align="justify">Примечание - На эту группу методов или средств даны ссылки в МЭК 61508-2 (см. приложение А, таблицы А.15, А.16 и А.18).<br/><br/><br/></p><p id="P00CC_2" class="formattext topleveltext indenttext" align="justify">Главная цель. Обнаружение искаженных программных последовательностей. Искаженная программная последовательность появляется, если отдельные элементы программы (например программные модули, подпрограммы или команды) обрабатываются в неправильной последовательности, или в несоответствующий период времени, или если сбилась тактовая частота процессора.<br/><br/></p><p id="P00CE" class="formattext topleveltext indenttext" align="justify"><b>А.9.1 Контрольный датчик времени с отдельной временной базой без временного окна</b><br/><br/></p><p id="P00CE_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблицы А.10 и А.11).<br/><br/><br/></p><p id="P00CE_2" class="formattext topleveltext indenttext" align="justify">Цель. Контроль поведения и последовательности выполнения программ.<br/><br/></p><p id="P00CE_3" class="formattext topleveltext indenttext" align="justify">Описание. Внешние средства определения времени с отдельной базой времени (например контрольный датчик времени) периодически переключаются для контроля поведения компьютера и последовательности выполнения программ. Важно, чтобы моменты переключения были правильно расположены в программе. Контрольный датчик времени не переключается с некоторым фиксированным периодом, однако задается максимальный интервал.<br/><br/></p><p id="P00D0" class="formattext topleveltext indenttext" align="justify"><b>А.9.2 Контрольный датчик времени с отдельной временной базой и временным окном</b><br/><br/></p><p id="P00D0_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблицы А.10 и А.11).<br/><br/><br/></p><p id="P00D0_2" class="formattext topleveltext indenttext" align="justify">Цель. Контроль поведения и последовательности выполнения программ.<br/><br/></p><p id="P00D0_3" class="formattext topleveltext indenttext" align="justify">Описание. Внешние средства определения времени с отдельной базой времени (например контрольный датчик времени) периодически переключаются для контроля поведения компьютера и последовательности выполнения программ. Важно, чтобы моменты переключения были правильно расположены в программе. Контрольный датчик времени не переключается с некоторым фиксированным периодом, однако задается максимальный интервал. Если последовательности программ выполняются больше или меньше ожидаемого времени, то выполняется действие чрезвычайного случая.<br/><br/></p><p id="P00D2" class="formattext topleveltext indenttext" align="justify"><b>А.9.3 Логический контроль последовательности выполнения программ</b><br/><br/></p><p id="P00D2_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблицы А.10 и А.11).<br/><br/><br/></p><p id="P00D2_2" class="formattext topleveltext indenttext" align="justify">Цель. Контроль правильной последовательности выполнения отдельных частей программы.<br/><br/></p><p id="P00D2_3" class="formattext topleveltext indenttext" align="justify">Описание. Правильная последовательность выполнения отдельных частей программы контролируется с помощью программных средств (процедур учета, ключевых процедур) или с использованием внешних средств контроля. Важно, чтобы точки проверки располагались в программе правильно.<br/><br/></p><p id="P00D4" class="formattext topleveltext indenttext" align="justify"><b>А.9.4 Комбинация временного и логического контроля последовательности выполнения программ</b><br/><br/></p><p><img class="base64 sign" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZIAAAARCAMAAADAD9oKAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MTg4Q0U3ODQ0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MTg4Q0U3ODU0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoxODhDRTc4MjRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDoxODhDRTc4MzRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pos3t18AAAAzUExURfX19SQkJOrq6oeHh7y8vD8/P9/f31RUVMjIyLCwsHh4eJaWlmdnZ6Ojo9TU1AAAAP////kimdMAAAWSSURBVHja7FiJcuQoDAVzGcz1/1+7TwLRuDs9mZ2karZqQ1ViGz90PUngVv1nfMOo9fg2WarnNkf9FGxMHdDkf1jo3bXBg7o0YhIkfrXV0npvBfd48y94HQtV97XWZvBPfbpG29oikGfQ6oeRs4WLb4K2CGNq5wsltpX6B5TQYEa5/u6h9rdn31QdtXS0iKX1WZ360/o9Pl/3NmVq/ahk/cfwZ0X+bSL6T01Kxmq6Fj0MSDNPj+atGzF1+Y17z9IZMRfulHiH+ivMFvE7nm2ffQ26Q5+U0AKLatWUGFm63kU3SJycuwqNLgNJ1ONf6crorUNyEySMStQLlegNgSuSmiT5agizm0YyZwPNbEXLM64y2X0YcGgdN3ytU9FaLDCecHbCyFWVh0kjMvBEHK+rvx/tVIgOWSoTcZrRa+aVJxeOuLc5nG8Oj2cjCzdKDm1Uj9BCSFeO7sKBgKCxRWpXKNAiFtV2njBAGeqm2QBQaZKCjjDCA+vqnZJD802sAzu9q4EwRtde4djUG4kJeFObpsag4cXNNJKJejRY7pVO9EJiQf2XRJLlBEcW1Toooc48FcniBeN2nOALwwzMDXhDJv2CkoKENkS/NKzu0p74rRyOk0vcezgs0iXQhLDixE4J6YAALgUqoEq6VKpih0KosOuUUihxM+eGo6KIA3DEaTI8oJS7UZIybnhmOVX1wCiqLJSYmnr52WjShadTA7Obtsyl2lP22PquxG9kJ1VbSWN2gEXRfF4wlnri36xnTJBYC+R7ShyX17HNDIcXJSg8ddMqDi/p0+HOCGNfKclwPmdHBsVgp9mbHaemuwBMwtvmCK2pQqtwdpakiZIQg7pTAitwc+m6OVWyWFhnzQy9aMrcDZASSAJjgNlMo5R4UIJ1xbhnSsYr+p/LRslS1FfshQFIpb4v06WRvgBky4VfseOmPqy3zaKiZqp/SEmpOqhdqzi8pE+H6/2wu1PiCg9AkvOvlJi0r2ZbS7FooaMpdo8WYy6ixPFRZKcEE9Iz115irhdKWC/y1VquyIpWqU+i5GEapcRWJaGFFN9T4s7foyRQdqmNkqHvGJmn82AtUzed1s9vB63U6jj6ulOCnnbtWsXhJX06/J6S5LbDmKYuy/W11rgbobKpdRvmtNFKGpfS142SqEcL8CE99hIKV+ZmbDnr/NQL2Slx46wxoDSB2U27NS77eN4oGZaj91G6PChZiubzgo2+i9AKJbEd/S5yKA5ZAnCwLL6IcfYe2aHWb1rF4SV9OjwQ9XylZGwwORFSIeLUakYnHEVAgh6U0D7elY49C1OZNrM09pIC8EaJtnyjdHiIqE4qiY+K2YleProNrUcLhk8Lm2k3SgrF/KVKhuUQVUzfKFmK5vOCvVBytMSb69NeolwS66954oXTvnF2en3b3XmlIo3LPXF4SReHXZ5b3zMlCKcpAVse9z38XXh2kvo9htvuppy+LqeP0LgvBo/IpIJ+b/kQrGUDaM4XPvlBR9IPVq3mlkDldKIJ5k0vnGyzNh2myYvdtJ0S3wLtJeZOybT8uEabQ3kPSkSRUDRhs3HpI2uhKwKZKC8elADStJcASJOg7IcrF9BZvVBCPVi0bg6LdHF4IOqNkvmNaVM2iMWBHqoKLD9TvghAE92ecjdXxkxveb8tHElMxB7PblETZ1G2zDe1eNbBMkVEGdsDl4k3d709uAk86RPY3k2b5lZOIzbxnN2c5xk+LM9jv8PZaIBFkSwWBw9CRWwlLJ3fVZPTuYkUyLT+KPP7VBGAQmGev5tHTGMUrbvDU/pyeNn1oOQLQ74d6yeA51Hyfnn6FWDtmF8bueyXvzx+5XB/3d6/4rbfL+8Bz8Ne++X+s4z5pp/QLrtf/vJ47/B3U/L9Q/Fp4P87fn7R/c+NfwQYAFx9eFOvgdoSAAAAAElFTkSuQmCC"/></p><style>.base64.sign {display: none;}</style><p id="P00D4_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблицы А.10 и А.11).<br/><br/><br/></p><p id="P00D4_2" class="formattext topleveltext indenttext" align="justify">Цель. Контроль поведения и правильной последовательности выполнения отдельных частей программы.<br/><br/></p><p id="P00D4_3" class="formattext topleveltext indenttext" align="justify">Описание. Средство определения времени (например контрольный датчик времени), контролирующее программную последовательность, вновь запускается только в случае, если последовательность модулей программы выполняется правильно.<br/><br/></p><p id="P00D6" class="formattext topleveltext indenttext" align="justify"><b>А.9.5 Первоначальный тест при включении</b><br/><br/></p><p id="P00D6_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблицы А.10 и А.11).<br/><br/><br/></p><p id="P00D6_2" class="formattext topleveltext indenttext" align="justify">Цель. Обнаружение отказов при первоначальном тесте.<br/><br/></p><p id="P00D6_3" class="formattext topleveltext indenttext" align="justify">Описание. При запуске проводится первоначальный тест. Запуск возможен только в случае, если первоначальный тест прошел успешно. Например, датчик температуры может быть проверен нагретым резистором при запуске.<br/><br/></p><h3 id="P00D9" class="formattext topleveltext indenttext" align="justify" title-level="3"><b>А.10 Вентиляция и температура</b><br/><br/></h3><p id="P00D9_1" class="formattext topleveltext indenttext" align="justify">Примечание - На эту группу методов и средств дана ссылка в МЭК 61508-2 (см. приложение А, таблицы А.16 и А.17).<br/><br/><br/></p><p id="P00D9_2" class="formattext topleveltext indenttext" align="justify">Главная цель. Управление отказами в системах вентиляции и температурных приборах и/или их контроль, если они связаны с безопасностью.<br/><br/></p><p id="P00DB" class="formattext topleveltext indenttext" align="justify"><b>А.10.1 Датчик температуры</b><br/><br/></p><p id="P00DB_1" class="formattext topleveltext indenttext" align="justify">Цель. Обнаружение температурного перегрева или недогрева до того, как система начнет действовать вне заданных требований.<br/><br/></p><p id="P00DB_2" class="formattext topleveltext indenttext" align="justify">Описание. Датчик температуры контролирует температуру в наиболее критических точках Э/Э/ПЭ системы, связанной с безопасностью. Прежде чем температура выйдет из заданного диапазона, происходит аварийное действие.<br/><br/></p><p id="P00DD" class="formattext topleveltext indenttext" align="justify"><b>А.10.2 Управление вентиляцией</b><br/><br/></p><p id="P00DD_1" class="formattext topleveltext indenttext" align="justify">Цель. Обнаружение отказов в работе вентилятора.<br/><br/></p><p id="P00DD_2" class="formattext topleveltext indenttext" align="justify">Описание. Работа вентиляторов контролируется. Если вентилятор находится в нерабочем состоянии, то предпринимаются действия по восстановлению его рабочего состояния (или его аварийному отключению).<br/><br/></p><p id="P00DF" class="formattext topleveltext indenttext" align="justify"><b>А.10.3 Безопасное выключение с использованием плавкого предохранителя</b><br/><br/></p><p id="P00DF_1" class="formattext topleveltext indenttext" align="justify">Цель. Выключение системы, связанной с безопасностью, до того как параметры системы выйдут из заданных температурных режимов.<br/><br/></p><p id="P00DF_2" class="formattext topleveltext indenttext" align="justify">Описание. Плавкий предохранитель используется для выключения систем, связанных с безопасностью. В ПЭ системе выключение осуществляется процедурой отключения питания, которая хранит информацию, необходимую при аварийных действиях.<br/><br/></p><p id="P00E1" class="formattext topleveltext indenttext" align="justify"><b>А.10.4 Пороговые сообщения от термодатчиков и условная тревога</b><br/><br/></p><p id="P00E1_1" class="formattext topleveltext indenttext" align="justify">Цель. Показать, что система, связанная с безопасностью, работает также за пределами допусков по температуре.<br/><br/></p><p id="P00E1_2" class="formattext topleveltext indenttext" align="justify">Описание. Измеряется температура, а при ее выходе из заданного диапазона выдается аварийный сигнал.<br/><br/></p><p id="P00E3" class="formattext topleveltext indenttext" align="justify"><b>А.10.5 Соединение устройства принудительного охлаждения воздуха и индикатора состояний</b><br/><br/></p><p id="P00E3_1" class="formattext topleveltext indenttext" align="justify">Цель. Не допустить перегрева путем искусственного воздушного охлаждения.<br/><br/></p><p id="P00E3_2" class="formattext topleveltext indenttext" align="justify">Описание. Измеряется температура. Если температура превышает заданный предел, то включается искусственное воздушное охлаждение. Пользователь информируется об измеренном значении температуры.<br/><br/></p><h3 id="P00E6" class="formattext topleveltext indenttext" align="justify" title-level="3"><b>А.11 Обмен и запоминающее устройство большой емкости</b><br/><br/></h3><p id="P00E6_1" class="formattext topleveltext indenttext" align="justify">Главная цель. Контроль отказов в процессе обмена между внешними источниками и запоминающим устройством большой емкости.<br/><br/></p><p id="P00E8" class="formattext topleveltext indenttext" align="justify"><b>А.11.1 Разделение линий электрического питания и линий передачи информации</b><br/><br/></p><p id="P00E8_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблица А.16).<br/><br/><br/></p><p id="P00E8_2" class="formattext topleveltext indenttext" align="justify">Цель. Минимизировать перекрестные помехи информационных линий, индуцируемые сильным током системы питания.<br/><br/></p><p id="P00E8_3" class="formattext topleveltext indenttext" align="justify">Описание. Линии, обеспечивающие электрическое питание, отделяются от линий, переносящих информацию. Электрическое поле, которое может индуцировать на информационных линиях всплески напряжения, уменьшается с увеличением расстояния.<br/><br/></p><p id="P00EA" class="formattext topleveltext indenttext" align="justify"><b>А.11.2 Пространственное разделение групповых линий</b><br/><br/></p><p id="P00EA_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблица А.16).<br/><br/><br/></p><p id="P00EA_2" class="formattext topleveltext indenttext" align="justify">Цель. Минимизировать перекрестные помехи, индуцируемые током системы питания в групповых линиях.<br/><br/></p><p id="P00EA_3" class="formattext topleveltext indenttext" align="justify">Описание. Линии с дублирующими сигналами отделяются друг от друга. Электрическое поле, которое могут индуцировать броски напряжений в групповых линиях, уменьшается с увеличением расстояния. Это отделение линий снижает также отказы по общей причине.<br/><br/></p><p id="P00EC" class="formattext topleveltext indenttext" align="justify"><b>А.11.3 Повышение устойчивости к электромагнитным воздействиям</b><br/><br/></p><p id="P00EC_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблицы А.16 и А.18).<br/><br/><br/></p><p id="P00EC_2" class="formattext topleveltext indenttext" align="justify">Цель. Минимизировать электромагнитные влияния на систему, связанную с безопасностью.<br/><br/></p><p id="P00EC_3" class="formattext topleveltext indenttext" align="justify">Описание. Создание таких методов, как экранирование и фильтрация, для уменьшения чувствительности систем, связанных с безопасностью, к электромагнитным полям, которые могут наводиться на линии питания или сигнальные линии, либо возникать в результате электростатических разрядов.<br/><br/></p><p id="P00EC_4" class="formattext topleveltext indenttext" align="justify">Примечание - Требования к устойчивости систем, связанных с безопасностью, и оборудования при выполнении функций, связанных с безопасностью (функциональная безопасность), для промышленных применений см. в [5] и [6].<br/><br/><br/></p><p id="P00EC_5" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P00EC_6" class="formattext topleveltext indenttext" align="justify">IEC/TR 61000-5-2:1997, Electromagnetic compatibility (EMC) - Part 5: Installation and mitigation guidelines - Section 2: Earthing and cabling.<br/><br/></p><p id="P00EC_7" class="formattext topleveltext indenttext" align="justify">Principles and Techniques of Electromagnetic Compatibility, Second Edition, С. Christopoulos, CRC Press, 2007, ISBN-10: 0849370353, ISBN-13: 978-0849370359.<br/><br/></p><p id="P00EC_8" class="formattext topleveltext indenttext" align="justify">Noise Reduction Techniques in Electronic Systems. H.W. Ott, John Wiley Interscience, 2nd Edition, 1988.<br/><br/></p><p id="P00EC_9" class="formattext topleveltext indenttext" align="justify">EMC for Product Designers. Tim Williams, Newnes, 2007, ISBN 0750681705.<br/><br/></p><p id="P00EC_10" class="formattext topleveltext indenttext" align="justify">Grounding and Shielding Techniques in Instrumentation, 3 edition, R. Morrison Wiley-lnterscience, New York, 1986, ISBN-10: 0471838055, ISBN-13: 978-0471838050.<br/><br/></p><p id="P00EE" class="formattext topleveltext indenttext" align="justify"><b>A.11.4 Передача неэквивалентных сигналов</b><br/><br/></p><p id="P00EE_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблицы А.7 и А.16).<br/><br/><br/></p><p id="P00EE_2" class="formattext topleveltext indenttext" align="justify">Цель. Обнаружение одинаковых индуцированных напряжений в групповых линиях передачи сигналов.<br/><br/></p><p id="P00EE_3" class="formattext topleveltext indenttext" align="justify">Описание. Вся дублируемая информация передается с неэквивалентными сигналами (например логические 1 и 0). Ошибки по общей причине (например вызванные электромагнитными излучениями) могут быть обнаружены неэквивалентным компаратором.<br/><br/></p><p id="P00EE_4" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P00EE_5" class="formattext topleveltext indenttext" align="justify">Elektronik in der Sicherheitstechnik. H. <img class="base64" src="data:image;base64,R0lGODdhHAAQAIABAAAAAP///ywAAAAAHAAQAAACMoyPqcvtDyE4c8Zl77OZBw5kmNGRHtmcH8purfqFSrmyIpXQOt5Ssv8ThW6aovGITCoKADs=" width="28" height="16"/>, D. Reinert, Sicherheitstechnisches Informations- und Arbeitsblatt 330220, BIA-Handbuch. 20. Lfg. V/93, Erich Schmidt Verlag, Bielefeld, htpp://www.bgia-handbuchdigital.de/330220.<br/><br/></p><h3 id="P00F1" class="formattext topleveltext indenttext" align="justify" title-level="3"><b>А.12 Датчики</b><br/><br/></h3><p id="P00F1_1" class="formattext topleveltext indenttext" align="justify">Главная цель. Управление отказами в датчиках систем, связанных с безопасностью.<br/><br/></p><p id="P00F3" class="formattext topleveltext indenttext" align="justify"><b>А.12.1 Эталонный датчик</b><br/><br/></p><p id="P00F3_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблица А.13).<br/><br/><br/></p><p id="P00F3_2" class="formattext topleveltext indenttext" align="justify">Цель. Обнаружение отказа датчика.<br/><br/></p><p id="P00F3_3" class="formattext topleveltext indenttext" align="justify">Описание. Для контроля работоспособности датчика используется независимый эталонный датчик. Все входные сигналы в подходящие временные интервалы проверяются эталонным датчиком для обнаружения отказов в работе проверяемого датчика.<br/><br/></p><p id="P00F3_4" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P00F3_5" class="formattext topleveltext indenttext" align="justify">Guidelines for Safe Automation of Chemical Processes. CCPS, AlChE, New York, 1993, ISBN-10: 0-8169-0554-1, ISBN-13: 978-0-8169-0554-6.<br/><br/></p><p id="P00F5" class="formattext topleveltext indenttext" align="justify"><b>A.12.2 Положительно управляемый переключатель</b><br/><br/></p><p id="P00F5_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблица А.14).<br/><br/><br/></p><p id="P00F5_2" class="formattext topleveltext indenttext" align="justify">Цель. Разомкнуть контакт с помощью непосредственного механического соединения между кулачком переключателя и контактом.<br/><br/></p><p id="P00F5_3" class="formattext topleveltext indenttext" align="justify">Описание. Положительно управляемый переключатель размыкает свои обычно замкнутые контакты непосредственным механическим соединением между кулачком переключателя и контактом. Разомкнутость контактов переключателя обеспечивается всякий раз, когда кулачок переключателя находится в рабочем положении.<br/><br/></p><p id="P00F5_4" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P00F5_5" class="formattext topleveltext indenttext" align="justify">Verriegelung beweglicher Schutzeinrichtungen. F.Kreutzkampf, K.Becker, Sicherheitstechnisches Informations- und Arbeitsblatt 330210, BIA-Handbuch. 1. Lfg. IX/85, Erich Schmidt Verlag, Bielefeld.<br/><br/></p><h3 id="P00F8" class="formattext topleveltext indenttext" align="justify" title-level="3"><b>A.13 Исполнительные элементы (приводы)</b><br/><br/></h3><p id="P00F8_1" class="formattext topleveltext indenttext" align="justify">Главная цель. Управление отказами в исполнительных элементах систем, связанных с безопасностью.<br/><br/></p><p id="P00FA" class="formattext topleveltext indenttext" align="justify"><b>А.13.1 Мониторинг</b><br/><br/></p><p id="P00FA_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблица А.14).<br/><br/><br/></p><p id="P00FA_2" class="formattext topleveltext indenttext" align="justify">Цель. Обнаружение отказа привода.<br/><br/></p><p id="P00FA_3" class="formattext topleveltext indenttext" align="justify">Описание. Операции привода контролируются (например положительно управляемыми контактами реле; см. контроль контактов реле в А.1.2). Избыточность, вносимая этим контролем, может быть использована для переключения на аварийный режим.<br/><br/></p><p id="P00FA_4" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P00FA_5" class="formattext topleveltext indenttext" align="justify">Guidelines for Safe Automation of Chemical Processes. CCPS, AlChE, New York, 1993, ISBN-10: 0-8169-0554-1, ISBN-13: 978-0-8169-0554-6.<br/><br/></p><p id="P00FA_6" class="formattext topleveltext indenttext" align="justify">Zusammenstellung und Bewertung elektromechanischer Sicherheitschaltungen <img class="base64" src="data:image;base64,R0lGODdhFAAQAIABAAAAAP///ywAAAAAFAAQAAACJoyPqcvtDkCQ8k2rIj11Z1NdU5h0HNiYqLioIlmub8ppMobn+r4UADs=" width="20" height="16"/> Ver-riegelungseinrichtungen. F. Kreutzkampf, W. Hertel, Sicherheitstechnisches Informations- und Arbeitsblatt 330212, BIA-Handbuch. 17. Lfg. X/91, Erich Schmidt Verlag, Bielefeld.<br/><br/></p><p id="P00FC" class="formattext topleveltext indenttext" align="justify"><b>A.13.2 Перекрестный контроль групповых приводов</b><br/><br/></p><p id="P00FC_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблица А.14).<br/><br/><br/></p><p id="P00FC_2" class="formattext topleveltext indenttext" align="justify">Цель. Обнаружение отказов в приводах путем сравнения результатов контроля.<br/><br/></p><p id="P00FC_3" class="formattext topleveltext indenttext" align="justify">Описание. Каждый групповой привод контролируется своим аппаратным каналом. При обнаружении различий вырабатывается аварийное действие.<br/><br/></p><h3 id="P00FF" class="formattext topleveltext indenttext" align="justify" title-level="3"><b>А.14 Средства против физического воздействия окружающей среды</b><br/><br/></h3><p id="P00FF_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (см. приложение А, таблицы А.16 и А.18).<br/><br/><br/></p><p id="P00FF_2" class="formattext topleveltext indenttext" align="justify">Цель. Предотвратить влияние физической окружающей среды (влажности, пыли, коррозийных субстанций), вызывающей отказы.<br/><br/></p><p id="P00FF_3" class="formattext topleveltext indenttext" align="justify">Описание. Покрытие оборудования должно противостоять чрезмерным внешним воздействиям.<br/><br/></p><p id="P00FF_4" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P00FF_5" class="formattext topleveltext indenttext" align="justify">IEC 60529:1989, Degrees of protection provided by enclosures (IP Code).<br/></p><p id="P0100" class="formattext topleveltext centertext" align="center"></p><h2 id="P0103" class="formattext topleveltext centertext" align="center" title-level="2">Приложение В<br/>(справочное)<br/></h2><p id="P0104" class="headertext topleveltext centertext" align="center">Анализ методов и средств для Э/Э/ПЭ систем, связанных с безопасностью. Предотвращение систематических отказов (см. МЭК 61508-2 и МЭК 61508-3)</p><p id="P0105" class="formattext topleveltext indenttext" align="justify"><br/></p><p id="P0105_1" class="formattext topleveltext indenttext" align="justify">Примечание - Многие методы, представленные в данном приложении, относятся и к программным средствам, но в приложении С они не описаны.<br/><br/></p><h3 id="P0108" class="formattext topleveltext indenttext" align="justify" title-level="3"><b>В.1 Общие методы и средства</b><br/><br/></h3><p id="P010A" class="formattext topleveltext indenttext" align="justify"><b>В.1.1 Управление проектами</b><br/><br/></p><p><img class="base64 sign" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZIAAAARCAMAAADAD9oKAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MTg4Q0U3ODQ0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MTg4Q0U3ODU0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoxODhDRTc4MjRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDoxODhDRTc4MzRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pos3t18AAAAzUExURfX19SQkJOrq6oeHh7y8vD8/P9/f31RUVMjIyLCwsHh4eJaWlmdnZ6Ojo9TU1AAAAP////kimdMAAAWSSURBVHja7FiJcuQoDAVzGcz1/1+7TwLRuDs9mZ2karZqQ1ViGz90PUngVv1nfMOo9fg2WarnNkf9FGxMHdDkf1jo3bXBg7o0YhIkfrXV0npvBfd48y94HQtV97XWZvBPfbpG29oikGfQ6oeRs4WLb4K2CGNq5wsltpX6B5TQYEa5/u6h9rdn31QdtXS0iKX1WZ360/o9Pl/3NmVq/ahk/cfwZ0X+bSL6T01Kxmq6Fj0MSDNPj+atGzF1+Y17z9IZMRfulHiH+ivMFvE7nm2ffQ26Q5+U0AKLatWUGFm63kU3SJycuwqNLgNJ1ONf6crorUNyEySMStQLlegNgSuSmiT5agizm0YyZwPNbEXLM64y2X0YcGgdN3ytU9FaLDCecHbCyFWVh0kjMvBEHK+rvx/tVIgOWSoTcZrRa+aVJxeOuLc5nG8Oj2cjCzdKDm1Uj9BCSFeO7sKBgKCxRWpXKNAiFtV2njBAGeqm2QBQaZKCjjDCA+vqnZJD802sAzu9q4EwRtde4djUG4kJeFObpsag4cXNNJKJejRY7pVO9EJiQf2XRJLlBEcW1Toooc48FcniBeN2nOALwwzMDXhDJv2CkoKENkS/NKzu0p74rRyOk0vcezgs0iXQhLDixE4J6YAALgUqoEq6VKpih0KosOuUUihxM+eGo6KIA3DEaTI8oJS7UZIybnhmOVX1wCiqLJSYmnr52WjShadTA7Obtsyl2lP22PquxG9kJ1VbSWN2gEXRfF4wlnri36xnTJBYC+R7ShyX17HNDIcXJSg8ddMqDi/p0+HOCGNfKclwPmdHBsVgp9mbHaemuwBMwtvmCK2pQqtwdpakiZIQg7pTAitwc+m6OVWyWFhnzQy9aMrcDZASSAJjgNlMo5R4UIJ1xbhnSsYr+p/LRslS1FfshQFIpb4v06WRvgBky4VfseOmPqy3zaKiZqp/SEmpOqhdqzi8pE+H6/2wu1PiCg9AkvOvlJi0r2ZbS7FooaMpdo8WYy6ixPFRZKcEE9Iz115irhdKWC/y1VquyIpWqU+i5GEapcRWJaGFFN9T4s7foyRQdqmNkqHvGJmn82AtUzed1s9vB63U6jj6ulOCnnbtWsXhJX06/J6S5LbDmKYuy/W11rgbobKpdRvmtNFKGpfS142SqEcL8CE99hIKV+ZmbDnr/NQL2Slx46wxoDSB2U27NS77eN4oGZaj91G6PChZiubzgo2+i9AKJbEd/S5yKA5ZAnCwLL6IcfYe2aHWb1rF4SV9OjwQ9XylZGwwORFSIeLUakYnHEVAgh6U0D7elY49C1OZNrM09pIC8EaJtnyjdHiIqE4qiY+K2YleProNrUcLhk8Lm2k3SgrF/KVKhuUQVUzfKFmK5vOCvVBytMSb69NeolwS66954oXTvnF2en3b3XmlIo3LPXF4SReHXZ5b3zMlCKcpAVse9z38XXh2kvo9htvuppy+LqeP0LgvBo/IpIJ+b/kQrGUDaM4XPvlBR9IPVq3mlkDldKIJ5k0vnGyzNh2myYvdtJ0S3wLtJeZOybT8uEabQ3kPSkSRUDRhs3HpI2uhKwKZKC8elADStJcASJOg7IcrF9BZvVBCPVi0bg6LdHF4IOqNkvmNaVM2iMWBHqoKLD9TvghAE92ecjdXxkxveb8tHElMxB7PblETZ1G2zDe1eNbBMkVEGdsDl4k3d709uAk86RPY3k2b5lZOIzbxnN2c5xk+LM9jv8PZaIBFkSwWBw9CRWwlLJ3fVZPTuYkUyLT+KPP7VBGAQmGev5tHTGMUrbvDU/pyeNn1oOQLQ74d6yeA51Hyfnn6FWDtmF8bueyXvzx+5XB/3d6/4rbfL+8Bz8Ne++X+s4z5pp/QLrtf/vJ47/B3U/L9Q/Fp4P87fn7R/c+NfwQYAFx9eFOvgdoSAAAAAElFTkSuQmCC"/></p><style>.base64.sign {display: none;}</style><p id="P010A_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (таблицы В.1-В.6).<br/><br/><br/></p><p id="P010A_2" class="formattext topleveltext indenttext" align="justify">Цель. Устранение отказов с использованием организационной модели, правил и средств по разработке и тестированию систем, связанных с безопасностью.<br/><br/></p><p id="P010A_3" class="formattext topleveltext indenttext" align="justify">Описание. Наиболее значимыми и лучшими средствами являются:<br/><br/></p><p id="P010A_4" class="formattext topleveltext indenttext" align="justify">- создание организационной модели в основном для обеспечения качества, описанное во многих работах по обеспечению качества, и<br/><br/></p><p id="P010A_5" class="formattext topleveltext indenttext" align="justify">- установление правил и определение средств для создания и подтверждения соответствия систем, связанных с безопасностью, в руководствах по взаимосвязанным и отдельным проектам.<br/><br/></p><p id="P010A_6" class="formattext topleveltext indenttext" align="justify">Для управления проектами установлены следующие важные базовые принципы:<br/><br/></p><p id="P010A_7" class="formattext topleveltext indenttext" align="justify">- при выборе проектной организации определяются:<br/><br/></p><p id="P010A_8" class="formattext topleveltext indenttext" align="justify">- задачи и ответственности подразделений конкретной организации,<br/><br/></p><p id="P010A_9" class="formattext topleveltext indenttext" align="justify">- полномочия департаментов по обеспечению качества,<br/><br/></p><p id="P010A_10" class="formattext topleveltext indenttext" align="justify">- независимость гарантии качества (при выполнении внутренней проверки) от разработки;<br/><br/></p><p id="P010A_11" class="formattext topleveltext indenttext" align="justify">- план последовательных действий (модель действий) формируется как:<br/><br/></p><p id="P010A_12" class="formattext topleveltext indenttext" align="justify">- определение действий по выполнению проекта, включая внутренние проверки и график их проведения,<br/><br/></p><p id="P010A_13" class="formattext topleveltext indenttext" align="justify">- обновление проекта;<br/><br/></p><p id="P010A_14" class="formattext topleveltext indenttext" align="justify">- стандартная последовательность для внутренней проверки определяется как:<br/><br/></p><p id="P010A_15" class="formattext topleveltext indenttext" align="justify">- планирование, проведение и контроль проверки (теория проверки),<br/><br/></p><p id="P010A_16" class="formattext topleveltext indenttext" align="justify">- использование различных механизмов проверок для составных частей,<br/><br/></p><p id="P010A_17" class="formattext topleveltext indenttext" align="justify">- сохранение результатов повторных проверок;<br/><br/></p><p id="P010A_18" class="formattext topleveltext indenttext" align="justify">- управление конфигурацией реализуется как:<br/><br/></p><p id="P010A_19" class="formattext topleveltext indenttext" align="justify">- администрирование и проверка версий,<br/><br/></p><p id="P010A_20" class="formattext topleveltext indenttext" align="justify">- выявление результатов модификаций,<br/><br/></p><p id="P010A_21" class="formattext topleveltext indenttext" align="justify">- проверки согласованности после модификаций;<br/><br/></p><p id="P010A_22" class="formattext topleveltext indenttext" align="justify">- вводятся количественные оценки для средств обеспечения качества в виде:<br/><br/></p><p id="P010A_23" class="formattext topleveltext indenttext" align="justify">- установления требований,<br/><br/></p><p id="P010B" class="formattext topleveltext indenttext" align="justify">- статистики отказов;<br/><br/></p><p id="P010B_1" class="formattext topleveltext indenttext" align="justify">- вводятся автоматизированные универсальные методы, инструменты и средства обучения персонала.<br/><br/></p><p id="P010B_2" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P010B_3" class="formattext topleveltext indenttext" align="justify">ISO 9001:2008, Quality management systems - Requirements.<br/><br/></p><p id="P010B_4" class="formattext topleveltext indenttext" align="justify">ISO/IEC 15504 (all parts), Information technology - Process assessment.<br/><br/></p><p id="P010B_5" class="formattext topleveltext indenttext" align="justify">CMMI: Guidelines for Process Integration and Product Improvement, 2nd Edition. M.B. Chrissis, M. Konrad, S. Shrum, Addison-Wesley Professional, 2006, ISBN-10: 0-3212-7967-0, ISBN-13: 978-0-3212-7967-5.<br/><br/></p><p id="P010B_6" class="formattext topleveltext indenttext" align="justify">Guidelines for Safe Automation of Chemical Processes. CCPS, AlChE, New York, 1993, ISBN-10: 0-8169-0554-1, ISBN-13: 978-0-8169-0554-6.<br/><br/></p><p id="P010B_7" class="formattext topleveltext indenttext" align="justify">Dependability of Critical Computer Systems 1. F.J. Redmill, Elsevier Applied Science, 1988, ISBN 1-85166-203-0.<br/><br/></p><p id="P010D" class="formattext topleveltext indenttext" align="justify"><b>B.1.2 Документация</b><br/><br/></p><p id="P010D_1" class="formattext topleveltext indenttext" align="justify">Примечания<br/><br/></p><p id="P010F" class="formattext topleveltext indenttext" align="justify">1 Ссылка на данный метод/средство приведена в МЭК 61508-2 (таблицы В.1-В.6).<br/><br/></p><p id="P0111" class="formattext topleveltext indenttext" align="justify">2 См. также МЭК 61508-1 (раздел 5 и приложение А).<br/><br/><br/></p><p id="P0111_1" class="formattext topleveltext indenttext" align="justify">Цель. Предотвращение отказов и упрощение процедуры оценки безопасности с помощью систем документирования каждого шага процесса разработки.<br/><br/></p><p id="P0111_2" class="formattext topleveltext indenttext" align="justify">Описание. Во время процедуры оценки, наряду со всеми составляющими, включенными в разработку, необходимо также уделять внимание эксплуатационным характеристикам и безопасности. В процессе разработки и обеспечения в любой момент времени проверки доказательств безопасности особое внимание уделяется документации на систему.<br/><br/></p><p id="P0111_3" class="formattext topleveltext indenttext" align="justify">Основными общими подходами к документированию являются введение руководящих принципов создания документов и использование автоматизации, в том числе:<br/><br/></p><p id="P0111_4" class="formattext topleveltext indenttext" align="justify">- руководящие принципы:<br/><br/></p><p id="P0111_5" class="formattext topleveltext indenttext" align="justify">- определяют структуру документа,<br/><br/></p><p id="P0111_6" class="formattext topleveltext indenttext" align="justify">- используют таблицы контрольных проверок для формирования содержания документа и<br/><br/></p><p id="P0111_7" class="formattext topleveltext indenttext" align="justify">- определяют формат документа;<br/><br/></p><p id="P0111_8" class="formattext topleveltext indenttext" align="justify">- автоматизация управляет документированием и создается структурированная библиотека проекта.<br/><br/></p><p id="P0111_9" class="formattext topleveltext indenttext" align="justify">К конкретным методам создания документов относятся:<br/><br/></p><p id="P0111_10" class="formattext topleveltext indenttext" align="justify">- разделение в документации описаний:<br/><br/></p><p id="P0111_11" class="formattext topleveltext indenttext" align="justify">- требований,<br/><br/></p><p id="P0112" class="formattext topleveltext indenttext" align="justify">- системы (документация пользователя) и<br/><br/></p><p id="P0112_1" class="formattext topleveltext indenttext" align="justify">- разработки (включая внутреннюю проверку);<br/><br/></p><p id="P0112_2" class="formattext topleveltext indenttext" align="justify">- группирование разработанной документации в соответствии с жизненным циклом безопасности;<br/><br/></p><p id="P0112_3" class="formattext topleveltext indenttext" align="justify">- определение стандартных модулей документации, из которых могут быть скомпилированы документы;<br/><br/></p><p id="P0112_4" class="formattext topleveltext indenttext" align="justify">- ясная идентификация составных частей документа;<br/><br/></p><p id="P0112_5" class="formattext topleveltext indenttext" align="justify">- формализованное обновление версий;<br/><br/></p><p id="P0112_6" class="formattext topleveltext indenttext" align="justify">- выбор ясных и понятных средств описания:<br/><br/></p><p id="P0112_7" class="formattext topleveltext indenttext" align="justify">- формализованная нотация для определений,<br/><br/></p><p id="P0112_8" class="formattext topleveltext indenttext" align="justify">- естественный язык для введений, обоснований и представления намерений,<br/><br/></p><p id="P0112_9" class="formattext topleveltext indenttext" align="justify">- графическое представление для описания примеров,<br/><br/></p><p id="P0112_10" class="formattext topleveltext indenttext" align="justify">- семантическое определение для графических элементов и<br/><br/></p><p id="P0112_11" class="formattext topleveltext indenttext" align="justify">- терминологические справочники.<br/><br/></p><p id="P0112_12" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0112_13" class="formattext topleveltext indenttext" align="justify">IEC 61506:1997, Industrial-process measurement and control - Documentation of application software.<br/><br/></p><p id="P0112_14" class="formattext topleveltext indenttext" align="justify">Guidelines for Safe Automation of Chemical Processes. CCPS, AlChE, New York, 1993, ISBN-10: 0-8169-0554-1, ISBN-13: 978-0-8169-0554-6.<br/><br/></p><p id="P0114" class="formattext topleveltext indenttext" align="justify"><b>B.1.3 Разделение систем, связанных с безопасностью, и систем, не связанных с безопасностью</b><br/><br/></p><p id="P0114_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (таблицы В.1 и В.6).<br/><br/><br/></p><p id="P0114_2" class="formattext topleveltext indenttext" align="justify">Цель. Предотвращение влияния систем, связанных с безопасностью, на системы, не связанные с безопасностью, в непредвиденных ситуациях.<br/><br/></p><p id="P0114_3" class="formattext topleveltext indenttext" align="justify">Описание. В спецификации должно быть определено, возможно ли разделение систем, связанных и не связанных с безопасностью. Должны быть установлены четкие спецификации взаимодействия между системами, связанными и не связанными с безопасностью. Четкое их разделение снижает затраты на тестирование систем, связанных с безопасностью.<br/><br/></p><p id="P0114_4" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0114_5" class="formattext topleveltext indenttext" align="justify">Guidelines for Safe Automation of Chemical Processes. CCPS, AlChE, New York, 1993, ISBN-10: 0-8169-0554-1, ISBN-13: 978-0-8169-0554-6.<br/><br/></p><p id="P0116" class="formattext topleveltext indenttext" align="justify"><b>B.1.4 Разнообразие аппаратных средств</b><br/><br/></p><p id="P0116_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (таблицы А.15, А.16 и А.18).<br/><br/></p><p id="P0117" class="formattext topleveltext indenttext" align="justify">Цель. Обнаружение систематических отказов при выполнении операций УО с использованием разнообразных компонентов с различными частотами и типами отказов.<br/><br/></p><p id="P0117_1" class="formattext topleveltext indenttext" align="justify">Описание. Для разнообразных каналов системы, связанной с безопасностью, используются различные типы компонентов. Это снижает вероятность отказов по общей причине (например увеличение напряжения по сравнению с номиналом, электромагнитные влияния) и повышает вероятность обнаружения таких отказов.<br/><br/></p><p id="P0117_2" class="formattext topleveltext indenttext" align="justify">Существование различных средств выполнения требуемой функции, например, применение других физических принципов, предполагает возможность использования других способов решения проблемы обнаружения систематических отказов. Возникает разнообразие типов используемых способов. Это функциональное разнообразие дает возможность использовать различные подходы для достижения одного и того же результата.<br/><br/></p><p id="P0117_3" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0117_4" class="formattext topleveltext indenttext" align="justify">Guidelines for Safe Automation of Chemical Processes. CCPS, AlChE, New York, 1993, ISBN-10: 0-8169-0554-1, ISBN-13: 978-0-8169-0554-6.<br/><br/></p><h3 id="P011A" class="formattext topleveltext indenttext" align="justify" title-level="3"><b>B.2 Спецификация требований к проектированию Э/Э/ПЭ системы</b><br/><br/></h3><p id="P011A_1" class="formattext topleveltext indenttext" align="justify">Главная цель. Создание спецификации, которая по возможности была бы полна, свободна от ошибок, противоречий и проста для проверки.<br/><br/></p><p id="P011C" class="formattext topleveltext indenttext" align="justify"><b>В.2.1 Структурирование спецификации</b><br/><br/></p><p id="P011C_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (таблицы В.1 и В.6).<br/><br/><br/></p><p id="P011C_2" class="formattext topleveltext indenttext" align="justify">Цель. Уменьшение сложности путем создания иерархической структуры частичных требований. Предотвращение ошибок взаимосвязи между требованиями.<br/><br/></p><p id="P011C_3" class="formattext topleveltext indenttext" align="justify">Описание. Данный метод разделяет функциональную спецификацию на частичные требования так, чтобы между ними существовали по возможности простейшие отношения. Этот метод применяется последовательно до тех пор, пока не будут получены небольшие четкие частичные требования. В результате получается иерархическая структура частичных требований, которая создает основу для спецификации полных требований. Данный метод выделяет взаимосвязи между частичными требованиями и особенно эффективен при его использовании для исключения ошибок в этих взаимосвязях.<br/><br/></p><p id="P011C_4" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P011D" class="formattext topleveltext indenttext" align="justify">ESA PSS 05-02, Guide to the user requirements definition phase, Issue 1, Revision 1, ESA Board for Software Standardisation and Control (BSSC), ESA, Paris, March 1995, ftp;//ftp.estec.esa.nl/pub/wm/wme/bssc/PSS0502.pdf.<br/><br/></p><p id="P011D_1" class="formattext topleveltext indenttext" align="justify">Structured Analysis and System Specification. T. De Marco, Yourdon Press, Englewood Cliffs, 1979, ISBN-10: 0138543801, ISBN-13: 978-0138543808.<br/><br/></p><p id="P011F" class="formattext topleveltext indenttext" align="justify"><b>B.2.2 Формальные методы</b><br/><br/></p><p id="P011F_1" class="formattext topleveltext indenttext" align="justify">Примечания<br/><br/></p><p id="P0121" class="formattext topleveltext indenttext" align="justify">1 Подробные сведения о конкретных формальных методах приведены в С.2.4.<br/><br/></p><p id="P0123" class="formattext topleveltext indenttext" align="justify">2 Ссылка на данный метод/средство приведена в МЭК 61508-2 (таблицы В.1, В.2 и В.6).<br/><br/><br/></p><p id="P0123_1" class="formattext topleveltext indenttext" align="justify">Цель. Формальные методы позволяют строить спецификации и реализации технических систем на принципах математического рассуждения, что повышает завершенность, непротиворечивость или корректность спецификации или реализации.<br/><br/></p><p id="P0123_2" class="formattext topleveltext indenttext" align="justify">Описание. Формальные методы обеспечивают средства разработки описания системы на конкретном этапе ее спецификации или проектирования. Такие формальные описания являются математическими моделями функции и/или структуры системы.<br/><br/></p><p id="P0123_3" class="formattext topleveltext indenttext" align="justify">Поэтому может быть обеспечено однозначное описание системы (например любое состояние автомата описано его начальным состоянием, входами и уравнениями перехода автомата из одного состояния в другое), которое увеличивает понимание основной системы.<br/><br/></p><p id="P0123_4" class="formattext topleveltext indenttext" align="justify">Выбор подходящего формального метода является трудной задачей, требующей полного понимания системы, ее процесса разработки и уровня используемых математических моделей (см. примечания).<br/><br/></p><p id="P0123_5" class="formattext topleveltext indenttext" align="justify">Примечания<br/><br/></p><p id="P0125" class="formattext topleveltext indenttext" align="justify">1 Теоремы модели (описывающие свойства) гарантированно представляют описание системы, которое обеспечивает гораздо большее доверие, чем моделирование, заключающееся в наблюдении отдельных действий системы.<br/><br/></p><p id="P0127" class="formattext topleveltext indenttext" align="justify">2 Недостатками формальных методов могут быть:<br/><br/></p><p><img class="base64 sign" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZIAAAARCAMAAADAD9oKAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MTg4Q0U3ODQ0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MTg4Q0U3ODU0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoxODhDRTc4MjRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDoxODhDRTc4MzRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pos3t18AAAAzUExURfX19SQkJOrq6oeHh7y8vD8/P9/f31RUVMjIyLCwsHh4eJaWlmdnZ6Ojo9TU1AAAAP////kimdMAAAWSSURBVHja7FiJcuQoDAVzGcz1/1+7TwLRuDs9mZ2karZqQ1ViGz90PUngVv1nfMOo9fg2WarnNkf9FGxMHdDkf1jo3bXBg7o0YhIkfrXV0npvBfd48y94HQtV97XWZvBPfbpG29oikGfQ6oeRs4WLb4K2CGNq5wsltpX6B5TQYEa5/u6h9rdn31QdtXS0iKX1WZ360/o9Pl/3NmVq/ahk/cfwZ0X+bSL6T01Kxmq6Fj0MSDNPj+atGzF1+Y17z9IZMRfulHiH+ivMFvE7nm2ffQ26Q5+U0AKLatWUGFm63kU3SJycuwqNLgNJ1ONf6crorUNyEySMStQLlegNgSuSmiT5agizm0YyZwPNbEXLM64y2X0YcGgdN3ytU9FaLDCecHbCyFWVh0kjMvBEHK+rvx/tVIgOWSoTcZrRa+aVJxeOuLc5nG8Oj2cjCzdKDm1Uj9BCSFeO7sKBgKCxRWpXKNAiFtV2njBAGeqm2QBQaZKCjjDCA+vqnZJD802sAzu9q4EwRtde4djUG4kJeFObpsag4cXNNJKJejRY7pVO9EJiQf2XRJLlBEcW1Toooc48FcniBeN2nOALwwzMDXhDJv2CkoKENkS/NKzu0p74rRyOk0vcezgs0iXQhLDixE4J6YAALgUqoEq6VKpih0KosOuUUihxM+eGo6KIA3DEaTI8oJS7UZIybnhmOVX1wCiqLJSYmnr52WjShadTA7Obtsyl2lP22PquxG9kJ1VbSWN2gEXRfF4wlnri36xnTJBYC+R7ShyX17HNDIcXJSg8ddMqDi/p0+HOCGNfKclwPmdHBsVgp9mbHaemuwBMwtvmCK2pQqtwdpakiZIQg7pTAitwc+m6OVWyWFhnzQy9aMrcDZASSAJjgNlMo5R4UIJ1xbhnSsYr+p/LRslS1FfshQFIpb4v06WRvgBky4VfseOmPqy3zaKiZqp/SEmpOqhdqzi8pE+H6/2wu1PiCg9AkvOvlJi0r2ZbS7FooaMpdo8WYy6ixPFRZKcEE9Iz115irhdKWC/y1VquyIpWqU+i5GEapcRWJaGFFN9T4s7foyRQdqmNkqHvGJmn82AtUzed1s9vB63U6jj6ulOCnnbtWsXhJX06/J6S5LbDmKYuy/W11rgbobKpdRvmtNFKGpfS142SqEcL8CE99hIKV+ZmbDnr/NQL2Slx46wxoDSB2U27NS77eN4oGZaj91G6PChZiubzgo2+i9AKJbEd/S5yKA5ZAnCwLL6IcfYe2aHWb1rF4SV9OjwQ9XylZGwwORFSIeLUakYnHEVAgh6U0D7elY49C1OZNrM09pIC8EaJtnyjdHiIqE4qiY+K2YleProNrUcLhk8Lm2k3SgrF/KVKhuUQVUzfKFmK5vOCvVBytMSb69NeolwS66954oXTvnF2en3b3XmlIo3LPXF4SReHXZ5b3zMlCKcpAVse9z38XXh2kvo9htvuppy+LqeP0LgvBo/IpIJ+b/kQrGUDaM4XPvlBR9IPVq3mlkDldKIJ5k0vnGyzNh2myYvdtJ0S3wLtJeZOybT8uEabQ3kPSkSRUDRhs3HpI2uhKwKZKC8elADStJcASJOg7IcrF9BZvVBCPVi0bg6LdHF4IOqNkvmNaVM2iMWBHqoKLD9TvghAE92ecjdXxkxveb8tHElMxB7PblETZ1G2zDe1eNbBMkVEGdsDl4k3d709uAk86RPY3k2b5lZOIzbxnN2c5xk+LM9jv8PZaIBFkSwWBw9CRWwlLJ3fVZPTuYkUyLT+KPP7VBGAQmGev5tHTGMUrbvDU/pyeNn1oOQLQ74d6yeA51Hyfnn6FWDtmF8bueyXvzx+5XB/3d6/4rbfL+8Bz8Ne++X+s4z5pp/QLrtf/vJ47/B3U/L9Q/Fp4P87fn7R/c+NfwQYAFx9eFOvgdoSAAAAAElFTkSuQmCC"/></p><style>.base64.sign {display: none;}</style><p id="P0127_1" class="formattext topleveltext indenttext" align="justify">- фиксированный уровень абстракции;<br/><br/></p><p id="P0127_2" class="formattext topleveltext indenttext" align="justify">- ограничения в получении всей функциональности, которая относится к данному этапу;<br/><br/></p><p id="P0127_3" class="formattext topleveltext indenttext" align="justify">- трудность понимания модели инженерами, которые ее реализуют;<br/><br/></p><p id="P0127_4" class="formattext topleveltext indenttext" align="justify">- значительные усилия, необходимые для разработки, анализа и поддержки модели на всем жизненном цикле системы;<br/><br/></p><p id="P0127_5" class="formattext topleveltext indenttext" align="justify">- недостаток эффективных инструментов, которые поддерживают создание и анализ модели;<br/><br/></p><p id="P0128" class="formattext topleveltext indenttext" align="justify">- недостаток персонала, способного разрабатывать и анализировать модель.<br/><br/></p><p id="P012A" class="formattext topleveltext indenttext" align="justify">3 Интерес сообщества, занимающегося формальными методами, был явно направлен на моделирование целевой функции системы, часто преуменьшая роль проблемы отказоустойчивости системы. Поэтому должны выбираться соответствующие формальные методы, включающие возможность решения проблемы устойчивости системы.<br/><br/><br/></p><p id="P012A_1" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P012A_2" class="formattext topleveltext indenttext" align="justify">Formal Specification: Techniques and Applications. N. Nissanke, Springer-Verlag Telos, 1999, ISBN-10: 1852330023.<br/><br/></p><p id="P012C" class="formattext topleveltext indenttext" align="justify"><b>B.2.3 Полуформальные методы</b><br/><br/></p><p id="P012C_1" class="formattext topleveltext indenttext" align="justify">Примечание - В отличие от приведенного ниже в МЭК 61508-3, таблица В.7, представлен список полуформальных методов, расширенный методами, связанными с программным обеспечением:<br/><br/></p><p id="P012C_2" class="formattext topleveltext indenttext" align="justify">- логические диаграммы/диаграммы функциональных блоков описаны в [7];<br/><br/></p><p id="P012C_3" class="formattext topleveltext indenttext" align="justify">- циклограммы описаны в [7];<br/><br/></p><p id="P012C_4" class="formattext topleveltext indenttext" align="justify">- диаграммы потоков данных: см. С.2.2;<br/><br/></p><p id="P012C_5" class="formattext topleveltext indenttext" align="justify">- конечные автоматы/диаграммы переходов см. В.2.3.2;<br/><br/></p><p id="P012C_6" class="formattext topleveltext indenttext" align="justify">- временные сети Петри см. В.2.3.3;<br/><br/></p><p id="P012C_7" class="formattext topleveltext indenttext" align="justify">- модели данных &quot;сущность - связь - атрибут&quot; см. В.2.4.4;<br/><br/></p><p id="P012C_8" class="formattext topleveltext indenttext" align="justify">- диаграммы последовательности сообщений см. С.2.14;<br/><br/></p><p id="P012C_9" class="formattext topleveltext indenttext" align="justify">- таблицы решений/таблицы истинности см. С.6.1.<br/><br/><br/></p><p id="P012C_10" class="formattext topleveltext indenttext" align="justify">Цель. Создание недвусмысленных и согласованных частей спецификации в целях обнаружения ошибок, пропусков и неправильного поведения.<br/><br/></p><p id="P012C_11" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (таблицы В.1, В.2 и В.6) и в МЭК 61508-3 (таблицы А.1, А.2, А.4, В.7, С.1, С.2, С.4 и С.17).<br/><br/></p><p id="P012E" class="formattext topleveltext indenttext" align="justify">В.2.3.1 Общие положения<br/><br/></p><p id="P012E_1" class="formattext topleveltext indenttext" align="justify">Цель. Убедиться в том, что проект соответствует своей спецификации.<br/><br/></p><p id="P012E_2" class="formattext topleveltext indenttext" align="justify">Описание. Полуформальные методы обеспечивают средства создания описания системы на стадиях ее разработки (например спецификации, проектирования или кодирования). Описание может быть в некоторых случаях проанализировано на ЭВМ или для отображения различных аспектов поведения системы использована анимация. Анимация может придать дополнительную уверенность в том, что система соответствует как реальным, так и специфицированным требованиям.<br/><br/></p><p id="P012E_3" class="formattext topleveltext indenttext" align="justify">В следующих пунктах настоящего приложения описаны два полуформальных метода.<br/><br/></p><p id="P0130" class="formattext topleveltext indenttext" align="justify">В.2.3.2 Конечные автоматы/диаграммы переходов<br/><br/></p><p id="P0130_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблицы В.5, В.7, С.15 и С.17).<br/><br/><br/></p><p id="P0130_2" class="formattext topleveltext indenttext" align="justify">Цель. Проведение моделирования, специфицирование или реализация структуры управления системы.<br/><br/></p><p id="P0130_3" class="formattext topleveltext indenttext" align="justify">Описание. Многие системы могут быть описаны в терминах их состояний, входов и действий. Таким образом, находясь в состоянии <i>S</i>1 и при получении входа /, система может выполнить действие <i>А</i> и перейти в состояние <i>S</i>2. Путем описания действий системы для каждого входа в каждом состоянии можно полностью описать систему. Такая модель системы называется машиной с конечными состояниями (или конечными автоматами). Ее часто изображают в виде так называемой диаграммы переходов, которая показывает, как система переходит из одного состояния в другое, или в виде матрицы, в которой для каждого состояния и входа задаются действия по переходу в новое состояние.<br/><br/></p><p id="P0130_4" class="formattext topleveltext indenttext" align="justify">В случае если система усложняется или имеет естественную структуру, то это может быть отражено в уровневой структуре конечного автомата. Диаграмма состояний - тип диаграммы переходов, в которой разрешены вложенные состояния (состояние объекта разделяется на два или больше подсостояний, которые могут развиваться параллельно, и, возможно, в некоторый момент могут опять объединиться в одно состояние); это добавляет выразительные возможности нотации переходов, но добавляет и дополнительную сложность, которая может быть нежелательной для системы, связанной с безопасностью. Диаграммы состояний имеют формальную (математическую) спецификацию. Диаграммы переходов могут применяться ко всей системе или к ее некоторому объекту или элементу.<br/><br/></p><p id="P0130_5" class="formattext topleveltext indenttext" align="justify">Спецификация или проект, выраженные в виде конечного автомата, могут быть проверены на:<br/><br/></p><p id="P0130_6" class="formattext topleveltext indenttext" align="justify">- полноту (система или объект должны иметь действие и новое состояние для каждого входа в каждом состоянии);<br/><br/></p><p id="P0130_7" class="formattext topleveltext indenttext" align="justify">- согласованность (возможно только одно состояние для каждой пары состояние/вход);<br/><br/></p><p id="P0130_8" class="formattext topleveltext indenttext" align="justify">- достижимость (возможно или нет перейти из одного состояния в другое с помощью некоторой последовательности входов) и<br/><br/></p><p id="P0130_9" class="formattext topleveltext indenttext" align="justify">- отсутствие бесконечных циклов и тупиковых состояний и т.д.<br/><br/></p><p id="P0130_10" class="formattext topleveltext indenttext" align="justify">Эти свойства являются важными для критических систем, так как легко разработать инструменты для обеспечения таких проверок, используя различные модели, основанные на теории конечных автоматов (формальные языки, сети Петри, графы Маркова и т.д.). Существуют также алгоритмы, позволяющие автоматически генерировать тестовые примеры для верификации реализаций конечных автоматов или анимации модели конечного автомата. Диаграммы переходов и диаграммы состояний широко поддерживаются инструментальными средствами, которые позволяют сформировать и проверить диаграммы, а также сгенерировать программный код для реализации описанного конечного автомата.<br/><br/></p><p id="P0130_11" class="formattext topleveltext indenttext" align="justify">Они могут также использоваться для вычислений вероятности отказа, см. В.6 и С.6.<br/><br/></p><p id="P0130_12" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0130_13" class="formattext topleveltext indenttext" align="justify">Introduction to Automata Theory, Languages, and Computation (3rd Edition). J. Hopcroft, R. Motwani, J. Ullman, Addison-Wesley Longman Publishing Co, 2006, ISBN: 0321462254.<br/><br/></p><p id="P0130_14" class="formattext topleveltext indenttext" align="justify"><img class="normal" src="https://api.docs.cntd.ru/img/12/00/10/32/42/135f542c-1dc5-4db8-9c2d-74263b12735c/P01300000.png" width="71" height="16"/> des architectures informatiques. Jean-Louis Boulanger, <img class="normal" src="https://api.docs.cntd.ru/img/12/00/10/32/42/135f542c-1dc5-4db8-9c2d-74263b12735c/P01300001.png" width="47" height="16"/> - Lavoisier, 2009, ISBN: 978-2-7462-1991-5.<br/><br/></p><p id="P0132" class="formattext topleveltext indenttext" align="justify">B.2.3.3 Моделирование во времени сетями Петри<br/><br/></p><p id="P0132_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблицы В.5, В.7, С.15 и С.17).<br/><br/><br/></p><p id="P0132_2" class="formattext topleveltext indenttext" align="justify">Цель. Моделирование соответствующих аспектов поведения системы, оценка и, возможно, повышение безопасности и эксплуатационных требований путем анализа и повторного проектирования.<br/><br/></p><p id="P0132_3" class="formattext topleveltext indenttext" align="justify">Описание. Метод сетей Петри является частным случаем метода конечных автоматов. Сети Петри относятся к классу моделей, описываемых теорией графов, и используются для представления информации и управления потоками в системах, в которых процессы конкурентны и асинхронны.<br/><br/></p><p id="P0132_4" class="formattext topleveltext indenttext" align="justify">Сеть Петри - это сеть позиций и переходов. Позиции могут быть &quot;маркированными&quot; или &quot;немаркированными&quot;. Переход считают &quot;активизированным&quot;, если все его входы маркированы. В активизированном состоянии позиции разрешается (но не требуется) быть &quot;возбужденной&quot;. Если позиция &quot;возбуждена&quot;, то вход, поступающий на переход, становится немаркированным, а вместо него каждый выход из перехода оказывается маркированным.<br/><br/></p><p id="P0132_5" class="formattext topleveltext indenttext" align="justify">Потенциальные опасности могут быть представлены в виде конкретных состояний (маркировок) в модели сети Петри. Модель может быть расширена с тем, чтобы обеспечить возможности моделирования систем во времени. И хотя &quot;классические&quot; сети Петри концентрируются на моделировании потоков управления, существуют некоторые расширения модели сети Петри, в которых моделируются потоки данных.<br/><br/></p><p id="P0132_6" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0132_7" class="formattext topleveltext indenttext" align="justify">Timed Petri Nets: Theory and Application. Jiacun Wang, Springer, 1998, ISBN 0792382706.<br/><br/></p><p id="P0132_8" class="formattext topleveltext indenttext" align="justify"><img class="normal" src="https://api.docs.cntd.ru/img/12/00/10/32/42/135f542c-1dc5-4db8-9c2d-74263b12735c/P01320000.png" width="71" height="16"/> des architectures informatiques. Jean-Louis Boulanger, <img class="normal" src="https://api.docs.cntd.ru/img/12/00/10/32/42/135f542c-1dc5-4db8-9c2d-74263b12735c/P01320001.png" width="47" height="16"/> - Lavoisier, 2009, ISBN: 978-2-7462-1991-5.<br/><br/></p><p id="P0134" class="formattext topleveltext indenttext" align="justify"><b>В.2.4 Автоматизированные средства разработки спецификации</b><br/><br/></p><p id="P0134_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (таблицы В.1 и В.6) и в МЭК 61508-3 (таблицы А.1, А.2, С.1 и С.2).<br/><br/></p><p id="P0136" class="formattext topleveltext indenttext" align="justify">В.2.4.1 Общие положения<br/><br/></p><p id="P0136_1" class="formattext topleveltext indenttext" align="justify">Цель. Использование формальных методов спецификации для упрощения автоматического обнаружения неоднозначностей и полноты.<br/><br/></p><p id="P0136_2" class="formattext topleveltext indenttext" align="justify">Описание. Данный метод создает спецификацию в виде базы данных, которая может автоматически анализироваться для оценки согласованности и полноты. Инструмент спецификации может в интересах пользователя использовать анимацию различных аспектов специфицированной системы. В общем случае данный метод поддерживает создание не только спецификаций, но и этап проектирования, а также другие этапы жизненного цикла. Инструменты спецификаций могут быть классифицированы в соответствии со следующими пунктами настоящего приложения.<br/><br/></p><p id="P0138" class="formattext topleveltext indenttext" align="justify">В.2.4.2 Инструменты, не ориентированные на конкретный метод<br/><br/></p><p id="P0138_1" class="formattext topleveltext indenttext" align="justify">Цель. Помощь пользователю в составлении правильной спецификации, применяя подсказки и формируя связи между соответствующими частями.<br/><br/></p><p id="P0138_2" class="formattext topleveltext indenttext" align="justify">Описание. Инструмент спецификаций освобождает пользователя от некоторой рутинной процедуры, поддерживает управление проектом и не представляет собой какую-либо конкретную методологию разработки спецификаций. Относительная независимость пользователей от метода позволяет быть более свободными при выборе конкретного метода и дает немного специальной поддержки, необходимой при создании спецификаций, что усложняет освоение системы.<br/><br/></p><p id="P013A" class="formattext topleveltext indenttext" align="justify"><b>В.2.4.3 Процедура, ориентированная на модель с иерархическим анализом</b><br/><br/></p><p id="P013A_1" class="formattext topleveltext indenttext" align="justify">Цель. Предотвратить неполноту, неоднозначность и противоречивость в спецификации, например, помогая пользователю в создании правильной спецификации, обеспечении согласованности между описаниями процессов и данных на различных уровнях абстрагирования.<br/><br/></p><p id="P013A_2" class="formattext topleveltext indenttext" align="justify">Описание. Данный метод дает функциональное представление о необходимой системе (структурный анализ) на различных уровнях абстрагирования (степень точности). Существует огромный арсенал таких моделей: конечные автоматы - класс таких моделей, широко используемых для описания построения дискретных/цифровых систем. Дифференциальные уравнения подобны по духу и целям для описания непрерывных/аналоговых систем. Структурный анализ проводится на различных уровнях абстрагирования как с процессами, так и с данными. Оценка неоднозначности и полноты возможна между иерархическими уровнями, а также между двумя функциональными единицами (модулями) на одном и том же уровне (например любое состояние модели системы описывается ее начальным состоянием, входами и уравнениями перехода автомата из одного состояния в другое).<br/><br/></p><p id="P013A_3" class="formattext topleveltext indenttext" align="justify">Примечание - Проблемами при описании, основанном на моделях, могут быть: уровень абстракции; ограничения для получения всей функциональности, относящейся к данному этапу; трудности понимания модели практиками (от чтения синтаксиса до ее правильной интерпретации); значительные усилия, затрачиваемые на разработку, анализ и поддержку модели на всем жизненном цикле системы; доступность эффективных инструментов, поддерживающих создание и анализ модели (разработка таких инструментов, конечно, требует больших усилий); и наличие специалистов, способных разрабатывать и анализировать модели.<br/><br/><br/></p><p id="P013A_4" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P013A_5" class="formattext topleveltext indenttext" align="justify">System requirements analysis. Jeffrey О. Grady, Academic Press, 2006, ISBN 012088514X, 9780120885145.<br/><br/></p><p id="P013C" class="formattext topleveltext indenttext" align="justify">B.2.4.4 Модели данных &quot;сущность - связь - атрибут&quot;<br/><br/></p><p id="P013C_1" class="formattext topleveltext indenttext" align="justify">Цель. Помощь пользователю в создании правильной спецификации на основе использования при описании системы сущностей и отношений между ними.<br/><br/></p><p id="P013C_2" class="formattext topleveltext indenttext" align="justify">Описание. Описание проектируемой системы в виде совокупности объектов и отношений между ними позволяет определять, какие отношения могут интерпретироваться системой. В общем случае эти отношения позволяют описывать иерархическую структуру объектов, поток данных, отношения между данными и данные, зависимые от конкретных производственных процессов. Этот классический подход расширен применением управления процессами. Возможности обследования и поддержка пользователя зависят от разнообразия проиллюстрированных отношений. Но множество возможностей представления усложняет применение этого метода.<br/><br/></p><p id="P013C_3" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P013C_4" class="formattext topleveltext indenttext" align="justify">Software Requirements: Practical Techniques for Gathering and Managing Requirements Throughout the Product Development Cycle. Karl Eugene Wiegers, Microsoft Press, 2003, ISBN 0735618798, 9780735618794.<br/><br/></p><p id="P013E" class="formattext topleveltext indenttext" align="justify">B.2.4.5 Стимул и ответ<br/><br/></p><p id="P013E_1" class="formattext topleveltext indenttext" align="justify">Цель. Помощь пользователю в создании правильной спецификации путем идентификации взаимоотношений &quot;стимул - ответ&quot;.<br/><br/></p><p id="P013E_2" class="formattext topleveltext indenttext" align="justify">Описание. Взаимоотношения между объектами системы определены в нотации &quot;стимулы&quot; и &quot;ответы&quot;. Используется простой и легко расширяемый язык, который содержит элементы языка, представляющие объекты, взаимоотношения, характеристики и структуры.<br/><br/></p><p id="P0140" class="formattext topleveltext indenttext" align="justify"><b>В.2.5 Таблица контрольных проверок</b><br/><br/></p><p id="P0140_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (таблицы В.1, В.2 и В.6) и в МЭК 61508-3 (таблицы А.10, В.8, С.10 и С.18).<br/><br/><br/></p><p id="P0140_2" class="formattext topleveltext indenttext" align="justify">Цель. Рассмотрение и управление критическими оценками всех важных аспектов системы на этапе жизненного цикла безопасности, обеспечивая исчерпывающий охват без установления точных требований.<br/><br/></p><p id="P0140_3" class="formattext topleveltext indenttext" align="justify">Описание. Специалист, заполняющий таблицу контрольных проверок, должен дать ответ на ряд вопросов. Многие вопросы носят общий характер, и он должен интерпретировать их как наиболее подходящие к конкретной оцениваемой системе. Таблицы контрольных проверок допускается использовать на всех этапах полного жизненного цикла безопасности, жизненного цикла безопасности Э/Э/ПЭ системы и жизненного цикла безопасности программного обеспечения. Такие таблицы, в частности, полезны в качестве инструмента для оценки функциональной безопасности.<br/><br/></p><p id="P0140_4" class="formattext topleveltext indenttext" align="justify">Для сокращения широкого разнообразия проходящих подтверждение соответствия систем большинство таблиц контрольных проверок содержат вопросы, которые применимы ко многим типам систем. Поэтому в используемой таблице контрольных проверок может оказаться множество вопросов, которые не уместны для конкретной системы и должны игнорироваться. Кроме того, может также возникнуть необходимость дополнить стандартную таблицу контрольных проверок вопросами, специально ориентированными на конкретную систему.<br/><br/></p><p id="P0140_5" class="formattext topleveltext indenttext" align="justify">Использование таблицы контрольных проверок в большой степени зависит от экспертной оценки и суждения специалиста, который выбирает и применяет таблицу контрольных проверок. Принятые им решения относительно выбранных(ой) таблиц(ы) контрольных проверок и любые дополнительные или игнорируемые вопросы должны быть полностью документально оформлены и обоснованы. Необходимо стремиться к тому, что если применение таблиц контрольных проверок пересматривается, то гарантируется получение одних и тех же результатов, если только не используются различные критерии.<br/><br/></p><p id="P0140_6" class="formattext topleveltext indenttext" align="justify">Описание системы в заполненной таблице контрольных проверок должно быть как можно более кратким. При необходимости исчерпывающего обоснования оно должно быть дано в виде ссылок на дополнительные документы. Для документирования результатов каждого вопроса должен использоваться ответ &quot;успешно&quot;, &quot;неуспешно&quot; или &quot;не завершено&quot;, либо аналогичный набор ответов. Эта лаконичность значительно упрощает процедуру оформления общего заключения результатов оценки в виде таблицы контрольных проверок.<br/><br/></p><p id="P0140_7" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0140_8" class="formattext topleveltext indenttext" align="justify">IEC 60880:2006, Nuclear power plants - Instrumentation and control systems important to safety - Software aspects for computer-based systems performing category A functions.<br/><br/></p><p id="P0140_9" class="formattext topleveltext indenttext" align="justify">The Art of Software Testing, Second Edition. G. Myers et al., Wiley &amp; Sons, New York, 2004, ISBN 0471469122, 9780471469124.<br/><br/></p><p><img class="base64 sign" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZIAAAARCAMAAADAD9oKAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MTg4Q0U3ODQ0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MTg4Q0U3ODU0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoxODhDRTc4MjRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDoxODhDRTc4MzRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pos3t18AAAAzUExURfX19SQkJOrq6oeHh7y8vD8/P9/f31RUVMjIyLCwsHh4eJaWlmdnZ6Ojo9TU1AAAAP////kimdMAAAWSSURBVHja7FiJcuQoDAVzGcz1/1+7TwLRuDs9mZ2karZqQ1ViGz90PUngVv1nfMOo9fg2WarnNkf9FGxMHdDkf1jo3bXBg7o0YhIkfrXV0npvBfd48y94HQtV97XWZvBPfbpG29oikGfQ6oeRs4WLb4K2CGNq5wsltpX6B5TQYEa5/u6h9rdn31QdtXS0iKX1WZ360/o9Pl/3NmVq/ahk/cfwZ0X+bSL6T01Kxmq6Fj0MSDNPj+atGzF1+Y17z9IZMRfulHiH+ivMFvE7nm2ffQ26Q5+U0AKLatWUGFm63kU3SJycuwqNLgNJ1ONf6crorUNyEySMStQLlegNgSuSmiT5agizm0YyZwPNbEXLM64y2X0YcGgdN3ytU9FaLDCecHbCyFWVh0kjMvBEHK+rvx/tVIgOWSoTcZrRa+aVJxeOuLc5nG8Oj2cjCzdKDm1Uj9BCSFeO7sKBgKCxRWpXKNAiFtV2njBAGeqm2QBQaZKCjjDCA+vqnZJD802sAzu9q4EwRtde4djUG4kJeFObpsag4cXNNJKJejRY7pVO9EJiQf2XRJLlBEcW1Toooc48FcniBeN2nOALwwzMDXhDJv2CkoKENkS/NKzu0p74rRyOk0vcezgs0iXQhLDixE4J6YAALgUqoEq6VKpih0KosOuUUihxM+eGo6KIA3DEaTI8oJS7UZIybnhmOVX1wCiqLJSYmnr52WjShadTA7Obtsyl2lP22PquxG9kJ1VbSWN2gEXRfF4wlnri36xnTJBYC+R7ShyX17HNDIcXJSg8ddMqDi/p0+HOCGNfKclwPmdHBsVgp9mbHaemuwBMwtvmCK2pQqtwdpakiZIQg7pTAitwc+m6OVWyWFhnzQy9aMrcDZASSAJjgNlMo5R4UIJ1xbhnSsYr+p/LRslS1FfshQFIpb4v06WRvgBky4VfseOmPqy3zaKiZqp/SEmpOqhdqzi8pE+H6/2wu1PiCg9AkvOvlJi0r2ZbS7FooaMpdo8WYy6ixPFRZKcEE9Iz115irhdKWC/y1VquyIpWqU+i5GEapcRWJaGFFN9T4s7foyRQdqmNkqHvGJmn82AtUzed1s9vB63U6jj6ulOCnnbtWsXhJX06/J6S5LbDmKYuy/W11rgbobKpdRvmtNFKGpfS142SqEcL8CE99hIKV+ZmbDnr/NQL2Slx46wxoDSB2U27NS77eN4oGZaj91G6PChZiubzgo2+i9AKJbEd/S5yKA5ZAnCwLL6IcfYe2aHWb1rF4SV9OjwQ9XylZGwwORFSIeLUakYnHEVAgh6U0D7elY49C1OZNrM09pIC8EaJtnyjdHiIqE4qiY+K2YleProNrUcLhk8Lm2k3SgrF/KVKhuUQVUzfKFmK5vOCvVBytMSb69NeolwS66954oXTvnF2en3b3XmlIo3LPXF4SReHXZ5b3zMlCKcpAVse9z38XXh2kvo9htvuppy+LqeP0LgvBo/IpIJ+b/kQrGUDaM4XPvlBR9IPVq3mlkDldKIJ5k0vnGyzNh2myYvdtJ0S3wLtJeZOybT8uEabQ3kPSkSRUDRhs3HpI2uhKwKZKC8elADStJcASJOg7IcrF9BZvVBCPVi0bg6LdHF4IOqNkvmNaVM2iMWBHqoKLD9TvghAE92ecjdXxkxveb8tHElMxB7PblETZ1G2zDe1eNbBMkVEGdsDl4k3d709uAk86RPY3k2b5lZOIzbxnN2c5xk+LM9jv8PZaIBFkSwWBw9CRWwlLJ3fVZPTuYkUyLT+KPP7VBGAQmGev5tHTGMUrbvDU/pyeNn1oOQLQ74d6yeA51Hyfnn6FWDtmF8bueyXvzx+5XB/3d6/4rbfL+8Bz8Ne++X+s4z5pp/QLrtf/vJ47/B3U/L9Q/Fp4P87fn7R/c+NfwQYAFx9eFOvgdoSAAAAAElFTkSuQmCC"/></p><style>.base64.sign {display: none;}</style><p id="P0140_10" class="formattext topleveltext indenttext" align="justify">Software Quality Assurance: From Theory to Implementation. Daniel Galin, Pearson Education, 2004, ISBN 0201709457, 9780201709452.<br/><br/></p><p id="P0140_11" class="formattext topleveltext indenttext" align="justify">IEC 61346 (all parts), Industrial systems, installations and equipment and industrial products - Structuring principles and reference designation.<br/><br/></p><p id="P0140_12" class="formattext topleveltext indenttext" align="justify">Guidelines for Safe Automation of Chemical Processes. CCPS, AlChE, New York, 1993, ISBN-10: 0-8169-0554-1, ISBN-13: 978-0-8169-0554-6.<br/><br/></p><p id="P0140_13" class="formattext topleveltext indenttext" align="justify">Risk Assessment and Risk Management for the Chemical Process Industry. H.R. Greenberg, J.J. Cramer, John Wiley and Sons, 1991, ISBN 0471288829, 9780471288824.<br/><br/></p><p id="P0142" class="formattext topleveltext indenttext" align="justify"><b>B.2.6 Экспертиза спецификации</b><br/><br/></p><p id="P0142_1" class="formattext topleveltext indenttext" align="justify">Примечаниe - Ссылка на данный метод/средство приведена в МЭК 61508-2 (таблицы В.1 и В.6).<br/><br/><br/></p><p id="P0142_2" class="formattext topleveltext indenttext" align="justify">Цель. Исключить некомплектность и противоречивость спецификации.<br/><br/></p><p id="P0142_3" class="formattext topleveltext indenttext" align="justify">Описание. Общий метод анализа спецификации для ее оценки с различных сторон независимой командой экспертов. Такая команда задает вопросы разработчику, который должен дать ей удовлетворительные ответы. Анализ должен (по возможности) проводиться командой экспертов, которая не принимала участия в создании спецификации. Требуемая степень независимости оценки определяется уровнями полноты безопасности, задаваемыми для системы. Команда независимых экспертов должна быть способна реконструировать эксплуатационную функцию системы бесспорным способом без ссылок на любые последующие спецификации. Специалисты команды независимых экспертов должны также убедиться в том, что охвачены все уместные аспекты безопасности и технические аспекты в эксплуатационных и организационных средствах. Общий метод экспертизы спецификации доказал свою высокую эффективность на практике.<br/><br/></p><p id="P0142_4" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0142_5" class="formattext topleveltext indenttext" align="justify">IEC 61160:2005, Design review<br/><br/></p><p id="P0142_6" class="formattext topleveltext indenttext" align="justify">The Art of Software Testing, Second Edition. G. Myers et al., Wiley &amp; Sons, New York, 2004, ISBN 0471469122, 9780471469124.<br/><br/></p><p id="P0142_7" class="formattext topleveltext indenttext" align="justify">Software Quality Assurance: From Theory to Implementation. D. Galin, Pearson Education, 2004, ISBN 0201709457, 9780201709452.<br/><br/></p><h3 id="P0145" class="formattext topleveltext indenttext" align="justify" title-level="3"><b>В.3 Проектирование и разработка Э/Э/ПЭ системы</b><br/><br/></h3><p id="P0145_1" class="formattext topleveltext indenttext" align="justify">Главная цель. Создание устойчивого проекта системы, связанной с безопасностью, в соответствии со спецификацией.<br/><br/></p><p id="P0147" class="formattext topleveltext indenttext" align="justify"><b>В.3.1 Соблюдение руководящих материалов и стандартов</b><br/><br/></p><p id="P0147_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (таблица В.2).<br/><br/><br/></p><p id="P0147_2" class="formattext topleveltext indenttext" align="justify">Цель. Рассмотрение стандартов сектора применения (не рассматриваемых в настоящем стандарте).<br/><br/></p><p id="P0147_3" class="formattext topleveltext indenttext" align="justify">Описание. Во время проектирования системы, связанной с безопасностью, должны составляться руководящие материалы, которые должны, во-первых, приводить к созданию систем, связанных с безопасностью, и быть практически свободны от ошибок и, во-вторых, упрощать последующее подтверждение соответствия безопасности. Такие руководящие материалы могут быть универсальными, специальными для проекта или специальными только для отдельного этапа проекта.<br/><br/></p><p id="P0147_4" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0147_5" class="formattext topleveltext indenttext" align="justify">Guidelines for Safe Automation of Chemical Processes. CCPS, AlChE, New York, 1993, ISBN-10: 0-8169-0554-1, ISBN-13: 978-0-8169-0554-6.<br/><br/></p><p id="P0149" class="formattext topleveltext indenttext" align="justify"><b>B.3.2 Структурное проектирование</b><br/><br/></p><p id="P0149_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (таблицы В.2 и В.6).<br/><br/><br/></p><p id="P0149_2" class="formattext topleveltext indenttext" align="justify">Цель. Снижение сложности проектирования путем создания иерархической структуры частичных требований. Исключение ошибок взаимосвязей между требованиями. Упрощение верификации.<br/><br/></p><p id="P0149_3" class="formattext topleveltext indenttext" align="justify">Описание. При проектировании аппаратных средств должны использоваться конкретные критерии или методы. Например, может потребоваться:<br/><br/></p><p id="P0149_4" class="formattext topleveltext indenttext" align="justify">- проектирование иерархически структурированных схем;<br/><br/></p><p id="P0149_5" class="formattext topleveltext indenttext" align="justify">- использование изготовленных и проверенных частей схем.<br/><br/></p><p id="P0149_6" class="formattext topleveltext indenttext" align="justify">При проектировании программных средств использование структурных схем также позволяет создать однозначную структуру программных модулей. Данная структура показывает взаимосвязь модулей друг с другом, конкретные данные, которые передаются между модулями, и конкретное управление, существующее между модулями.<br/><br/></p><p id="P0149_7" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0149_8" class="formattext topleveltext indenttext" align="justify">IEC 61346 (all parts), Industrial systems, installations and equipment and industrial products - Structuring principles and reference designation.<br/><br/></p><p id="P0149_9" class="formattext topleveltext indenttext" align="justify">Software Engineering for Real-time Systems. J.E. Cooling, Pearson Education, 2003, ISBN 0201596202, 9780201596205.<br/><br/></p><p id="P0149_10" class="formattext topleveltext indenttext" align="justify">Software Design. D. Budgen, Pearson Education, 2003, ISBN 0201722194, 9780201722192.<br/><br/></p><p id="P0149_11" class="formattext topleveltext indenttext" align="justify">An Overview of JSD, J.R. Cameron, IEEE Trans SE-12 No. 2, February 1986.<br/><br/></p><p id="P0149_12" class="formattext topleveltext indenttext" align="justify">Structured Development for Real-Time Systems (3 Volumes). P.T. Yourdon, P.T. Yourdon Press, 1985.<br/><br/></p><p id="P0149_13" class="formattext topleveltext indenttext" align="justify">Structured Development for Real-Time Systems (3 Volumes). P.T. Ward, S.J. Mellor, Yourdon Press, 1985.<br/><br/></p><p id="P0149_14" class="formattext topleveltext indenttext" align="justify">Applications and Extensions of SADT. D.T Ross, Computer, 25-34, April 1985.<br/><br/></p><p id="P0149_15" class="formattext topleveltext indenttext" align="justify">Essential Systems Analysis. St. M. McMenamin, F. Palmer, Yourdon Inc, 1984.<br/><br/></p><p id="P0149_16" class="formattext topleveltext indenttext" align="justify">Structured Analysis (SA): A language for communicating ideas. D.T. Ross, IEEE Trans. Software Eng, Vol. SE-3 (1), 16-34.<br/><br/></p><p id="P014B" class="formattext topleveltext indenttext" align="justify"><b>D.3.3* Использование достоверно испытанных компонентов</b><br/></p><p id="P014B_1" class="formattext topleveltext" align="justify">________________<br/></p><p id="P014B_2" class="formattext topleveltext indenttext" align="justify">* Нумерация соответствует оригиналу. - Примечание изготовителя базы данных.<br/><br/><br/></p><p id="P014B_3" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (таблицы В.2 и В.6).<br/><br/><br/></p><p id="P014B_4" class="formattext topleveltext indenttext" align="justify">Цель. Снижение риска многих оригинальных и необнаруживаемых отказов путем использования компонентов с конкретными характеристиками.<br/><br/></p><p id="P014B_5" class="formattext topleveltext indenttext" align="justify">Описание. Выбор достоверно испытанных компонентов для целей безопасности выполняется производителем в соответствии с надежностью компонентов (например использование эксплуатационно-тестируемых физических модулей для удовлетворения высоких требований безопасности или хранение относящихся к безопасности программ только в безопасной памяти). Обеспечение безопасности памяти может касаться устранения несанкционированного доступа, влияний несанкционированной среды (электромагнитная совместимость, радиация и т.д.), а также отклика компонентов в случае обнаружения отказов.<br/><br/></p><p id="P014B_6" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P014B_7" class="formattext topleveltext indenttext" align="justify">IEC 61163-1:2006, Reliability stress screening - Part 1: Repairable assemblies manufactured in lots.<br/><br/></p><p id="P014D" class="formattext topleveltext indenttext" align="justify"><b>D.3.4* Модульное проектирование</b><br/></p><p id="P014D_1" class="formattext topleveltext" align="justify">________________<br/></p><p id="P014D_2" class="formattext topleveltext indenttext" align="justify">* Нумерация соответствует оригиналу. - Примечание изготовителя базы данных.<br/><br/><br/></p><p id="P014D_3" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (таблицы В.2 и В.6).<br/><br/><br/></p><p id="P014D_4" class="formattext topleveltext indenttext" align="justify">Цель. Снижение сложности и исключение ошибок, связанных с интерфейсами между подсистемами.<br/><br/></p><p id="P014D_5" class="formattext topleveltext indenttext" align="justify">Описание. Каждая подсистема на всех уровнях проектирования четко определена и ограничена по размеру (только небольшим набором функций). Интерфейсы между подсистемами выполняются максимально простыми и пересечения (разделяемые данные, обмен информацией) минимизированы. Сложность отдельных подсистем также ограничивается.<br/><br/></p><p id="P014D_6" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P014D_7" class="formattext topleveltext indenttext" align="justify">The Art of Software Testing, Second Edition. G. Myers et al., Wiley &amp; Sons, New York, 2004, ISBN 0471469122, 9780471469124.<br/><br/></p><p id="P014D_8" class="formattext topleveltext indenttext" align="justify">Software Engineering for Real-time Systems. J.E. Cooling, Pearson Education, 2003, ISBN 0201596202, 9780201596205.<br/><br/></p><p id="P014D_9" class="formattext topleveltext indenttext" align="justify">Software Reliability - Principles and Practices. G.J. Myers, Wiley-lnterscience, New York, 1976, ISBN-10: 0471627658, ISBN-13: 978-0471627654.<br/><br/></p><p id="P014F" class="formattext topleveltext indenttext" align="justify"><b>B.3.5 Средства автоматизированного проектирования</b><br/><br/></p><p id="P014F_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (таблицы В.2 и В.6) и в МЭК 61508-3 (таблица А.4).<br/><br/><br/></p><p id="P014F_2" class="formattext topleveltext indenttext" align="justify">Цель. Более систематическое выполнение процедуры проектирования. Включение в проект подходящих автоматически сконструированных элементов, уже созданных и проверенных.<br/><br/></p><p id="P014F_3" class="formattext topleveltext indenttext" align="justify">Описание. Инструменты автоматизированного проектирования (CAD) должны использоваться в процессе проектирования как аппаратных, так и программных средств, если они доступны и их использование обосновано сложностью системы. Корректность использования таких инструментов должна быть продемонстрирована конкретным тестированием, обширной предысторией удовлетворительного использования, либо независимой верификацией их результата для конкретной проектируемой системы, связанной с безопасностью.<br/><br/></p><p id="P014F_4" class="formattext topleveltext indenttext" align="justify">Инструменты поддержки должны быть выбраны в соответствии с их уровнем интегрируемости. Инструменты считаются интегрируемыми, если они совместно работают так, что выходные данные одного инструмента по содержанию и формату подходят для автоматического ввода следующего инструментального средства, таким образом, минимизируя возможность внесения ошибки человеком в процессе его работы с промежуточными результатами.<br/><br/></p><p id="P014F_5" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P014F_6" class="formattext topleveltext indenttext" align="justify">Overview of Technology Computer-Aided Design Tools and Applications in Technology Development, Manufacturing and Design. W. Fichtner, Journal of Computational and Theoretical Nanoscience, Volume 5, Number 6, June 2008, pp.1089-1105(17).<br/><br/></p><p id="P014F_7" class="formattext topleveltext indenttext" align="justify">The Electromagnetic Data Exchange: Much more than a Common Data Format. P. E. Frandsen et al. In Proceeding of the 2nd European Conference on Antennas and Propagation. The Institution of Engineering and Technology (IET), 2007, ISBN 978-0-86341-842-6.<br/><br/></p><p id="P014F_8" class="formattext topleveltext indenttext" align="justify">Software engineering: Update. Ian Sommerville, Addison-Wesley Longman, Amsterdam; 8<img class="base64" src="data:image;base64,R0lGODdhDwAXAIABAAAAAP///ywAAAAADwAXAAACJIyPqcvtHwBw01R2r5J1apR5S2aNR2eW0ehJ0QfF8kzX9o0fBQA7" width="15" height="23"/> ed., 2006, ISBN 0321313798, 9780321313799.<br/><br/></p><p id="P014F_9" class="formattext topleveltext indenttext" align="justify">Software Engineering. Ian Sommerville, Pearson Studium, 8. Auflage, 2007, ISBN 3827372577, 9783827372574.<br/><br/></p><p id="P0151" class="formattext topleveltext indenttext" align="justify"><b>B.3.6 Моделирование</b><br/><br/></p><p id="P0151_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (таблицы В.2, В.5 и В.6).<br/><br/><br/></p><p id="P0151_2" class="formattext topleveltext indenttext" align="justify">Цель. Проведение систематических и полных проверок как функционирования электрических/электронных схем, так и для корректного задания значений параметров их компонентов.<br/><br/></p><p id="P0151_3" class="formattext topleveltext indenttext" align="justify">Описание. Функцию схемы, реализующую систему, связанную с безопасностью, имитируют на компьютере с помощью запрограммированной модели ее поведения. Поведение каждого отдельного компонента схемы моделируют отдельно, и отклик схемы, в которую он входит, анализируют при задании предельных значений параметров для каждого компонента.<br/><br/></p><p id="P0153" class="formattext topleveltext indenttext" align="justify"><b>В.3.7 Проверка (обзор и анализ)</b><br/><br/></p><p id="P0153_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (таблицы В.2 и В.6).<br/><br/><br/></p><p id="P0153_2" class="formattext topleveltext indenttext" align="justify">Цель. Выявление рассогласования между спецификацией и реализацией.<br/><br/></p><p id="P0153_3" class="formattext topleveltext indenttext" align="justify">Описание. Проверяются заданные функции системы, связанной с безопасностью. Оценивается соответствие системы, связанной с безопасностью, требованиям, приведенным в спецификации. Все вызывающие сомнение ситуации при реализации и использовании изделий документируют в целях их последующего разрешения. В отличие от сквозного контроля во время процедуры проверки разработчик системы пассивен, а эксперт активен.<br/><br/></p><p id="P0153_4" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0153_5" class="formattext topleveltext indenttext" align="justify">IEC 61160:2005, Design Review.<br/><br/></p><p id="P0153_6" class="formattext topleveltext indenttext" align="justify">Software engineering: Update. Ian Sommerville, Addison-Wesley Longman, Amsterdam; 8<img class="base64" src="data:image;base64,R0lGODdhDwAXAIABAAAAAP///ywAAAAADwAXAAACJIyPqcvtHwBw01R2r5J1apR5S2aNR2eW0ehJ0QfF8kzX9o0fBQA7" width="15" height="23"/> ed., 2006, ISBN 0321313798, 9780321313799.<br/><br/></p><p id="P0153_7" class="formattext topleveltext indenttext" align="justify">Software Engineering. Ian Sommerville, Pearson Studium, 8. Auflage, 2007, ISBN 3827372577, 9783827372574.<br/><br/></p><p id="P0153_8" class="formattext topleveltext indenttext" align="justify">The Art of Software Testing, Second Edition. G. Myers et al., Wiley &amp; Sons, New York, 2004, ISBN 0471469122, 9780471469124.<br/><br/></p><p id="P0153_9" class="formattext topleveltext indenttext" align="justify">ANSI/IEE 1028:1997, IEEE Standard for software reviews.<br/><br/></p><p id="P0153_10" class="formattext topleveltext indenttext" align="justify">Dependability of Critical Computer Systems 3. P.G. Bishop et al., Elsevier Applied Science, 1990, ISBN 1-85166-544-7.<br/><br/></p><p id="P0155" class="formattext topleveltext indenttext" align="justify"><b>B.3.8 Сквозной контроль</b><br/><br/></p><p id="P0155_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (таблица В.6).<br/><br/><br/></p><p id="P0155_2" class="formattext topleveltext indenttext" align="justify">Цель. Выявление рассогласования между спецификацией и реализацией.<br/><br/></p><p id="P0155_3" class="formattext topleveltext indenttext" align="justify">Описание. Проверяются заданные функции системы, связанной с безопасностью. Оценивается соответствие системы, связанной с безопасностью, требованиям, приведенным в спецификации. Все вызывающие сомнение ситуации при реализации и использовании изделий документируются в целях их последующего разрешения. В отличие от процедуры проверки во время сквозного контроля автор должен быть активен, а эксперт - пассивен.<br/><br/></p><p id="P0155_4" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0155_5" class="formattext topleveltext indenttext" align="justify">Software engineering: Update. Ian Sommerville, Addison-Wesley Longman, Amsterdam; 8<img class="base64" src="data:image;base64,R0lGODdhDwAXAIABAAAAAP///ywAAAAADwAXAAACJIyPqcvtHwBw01R2r5J1apR5S2aNR2eW0ehJ0QfF8kzX9o0fBQA7" width="15" height="23"/> ed., 2006, ISBN 0321313798, 9780321313799.<br/><br/></p><p id="P0155_6" class="formattext topleveltext indenttext" align="justify">Software Engineering. Ian Sommerville, Pearson Studium, 8. Auflage, 2007, ISBN 3827372577, 9783827372574.<br/><br/></p><p id="P0155_7" class="formattext topleveltext indenttext" align="justify">ANSI/IEE 1028:1997, IEEE Standard for software reviews.<br/><br/></p><p><img class="base64 sign" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZIAAAARCAMAAADAD9oKAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MTg4Q0U3ODQ0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MTg4Q0U3ODU0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoxODhDRTc4MjRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDoxODhDRTc4MzRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pos3t18AAAAzUExURfX19SQkJOrq6oeHh7y8vD8/P9/f31RUVMjIyLCwsHh4eJaWlmdnZ6Ojo9TU1AAAAP////kimdMAAAWSSURBVHja7FiJcuQoDAVzGcz1/1+7TwLRuDs9mZ2karZqQ1ViGz90PUngVv1nfMOo9fg2WarnNkf9FGxMHdDkf1jo3bXBg7o0YhIkfrXV0npvBfd48y94HQtV97XWZvBPfbpG29oikGfQ6oeRs4WLb4K2CGNq5wsltpX6B5TQYEa5/u6h9rdn31QdtXS0iKX1WZ360/o9Pl/3NmVq/ahk/cfwZ0X+bSL6T01Kxmq6Fj0MSDNPj+atGzF1+Y17z9IZMRfulHiH+ivMFvE7nm2ffQ26Q5+U0AKLatWUGFm63kU3SJycuwqNLgNJ1ONf6crorUNyEySMStQLlegNgSuSmiT5agizm0YyZwPNbEXLM64y2X0YcGgdN3ytU9FaLDCecHbCyFWVh0kjMvBEHK+rvx/tVIgOWSoTcZrRa+aVJxeOuLc5nG8Oj2cjCzdKDm1Uj9BCSFeO7sKBgKCxRWpXKNAiFtV2njBAGeqm2QBQaZKCjjDCA+vqnZJD802sAzu9q4EwRtde4djUG4kJeFObpsag4cXNNJKJejRY7pVO9EJiQf2XRJLlBEcW1Toooc48FcniBeN2nOALwwzMDXhDJv2CkoKENkS/NKzu0p74rRyOk0vcezgs0iXQhLDixE4J6YAALgUqoEq6VKpih0KosOuUUihxM+eGo6KIA3DEaTI8oJS7UZIybnhmOVX1wCiqLJSYmnr52WjShadTA7Obtsyl2lP22PquxG9kJ1VbSWN2gEXRfF4wlnri36xnTJBYC+R7ShyX17HNDIcXJSg8ddMqDi/p0+HOCGNfKclwPmdHBsVgp9mbHaemuwBMwtvmCK2pQqtwdpakiZIQg7pTAitwc+m6OVWyWFhnzQy9aMrcDZASSAJjgNlMo5R4UIJ1xbhnSsYr+p/LRslS1FfshQFIpb4v06WRvgBky4VfseOmPqy3zaKiZqp/SEmpOqhdqzi8pE+H6/2wu1PiCg9AkvOvlJi0r2ZbS7FooaMpdo8WYy6ixPFRZKcEE9Iz115irhdKWC/y1VquyIpWqU+i5GEapcRWJaGFFN9T4s7foyRQdqmNkqHvGJmn82AtUzed1s9vB63U6jj6ulOCnnbtWsXhJX06/J6S5LbDmKYuy/W11rgbobKpdRvmtNFKGpfS142SqEcL8CE99hIKV+ZmbDnr/NQL2Slx46wxoDSB2U27NS77eN4oGZaj91G6PChZiubzgo2+i9AKJbEd/S5yKA5ZAnCwLL6IcfYe2aHWb1rF4SV9OjwQ9XylZGwwORFSIeLUakYnHEVAgh6U0D7elY49C1OZNrM09pIC8EaJtnyjdHiIqE4qiY+K2YleProNrUcLhk8Lm2k3SgrF/KVKhuUQVUzfKFmK5vOCvVBytMSb69NeolwS66954oXTvnF2en3b3XmlIo3LPXF4SReHXZ5b3zMlCKcpAVse9z38XXh2kvo9htvuppy+LqeP0LgvBo/IpIJ+b/kQrGUDaM4XPvlBR9IPVq3mlkDldKIJ5k0vnGyzNh2myYvdtJ0S3wLtJeZOybT8uEabQ3kPSkSRUDRhs3HpI2uhKwKZKC8elADStJcASJOg7IcrF9BZvVBCPVi0bg6LdHF4IOqNkvmNaVM2iMWBHqoKLD9TvghAE92ecjdXxkxveb8tHElMxB7PblETZ1G2zDe1eNbBMkVEGdsDl4k3d709uAk86RPY3k2b5lZOIzbxnN2c5xk+LM9jv8PZaIBFkSwWBw9CRWwlLJ3fVZPTuYkUyLT+KPP7VBGAQmGev5tHTGMUrbvDU/pyeNn1oOQLQ74d6yeA51Hyfnn6FWDtmF8bueyXvzx+5XB/3d6/4rbfL+8Bz8Ne++X+s4z5pp/QLrtf/vJ47/B3U/L9Q/Fp4P87fn7R/c+NfwQYAFx9eFOvgdoSAAAAAElFTkSuQmCC"/></p><style>.base64.sign {display: none;}</style><p id="P0155_8" class="formattext topleveltext indenttext" align="justify">Dependability of Critical Computer Systems 3. P.G. Bishop et al., Elsevier Applied Science, 1990, ISBN 1-85166-544-7.<br/><br/></p><p id="P0155_9" class="formattext topleveltext indenttext" align="justify">Methodisches Testen von Programmen. G.J. Myers, Oldenbourg Verlag, <img class="normal" src="https://api.docs.cntd.ru/img/12/00/10/32/42/135f542c-1dc5-4db8-9c2d-74263b12735c/P01550001.png" width="53" height="16"/>, Wien, 1987.<br/><br/></p><h3 id="P0158" class="formattext topleveltext indenttext" align="justify" title-level="3"><b>В.4 Процедуры эксплуатации и технического обслуживания Э/Э/ПЭ системы</b><br/><br/></h3><p id="P0158_1" class="formattext topleveltext indenttext" align="justify">Главная цель. Разработка процедур, которые исключают ошибки во время эксплуатации и обслуживания системы, связанной с безопасностью.<br/><br/></p><p id="P015A" class="formattext topleveltext indenttext" align="justify"><b>В.4.1 Инструкции по эксплуатации и техническому обслуживанию</b><br/><br/></p><p id="P015A_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (таблица В.4).<br/><br/><br/></p><p id="P015A_2" class="formattext topleveltext indenttext" align="justify">Цель. Исключение ошибок во время эксплуатации и технического обслуживания систем, связанных с безопасностью.<br/><br/></p><p id="P015A_3" class="formattext topleveltext indenttext" align="justify">Описание. Инструкции пользователя содержат важную информацию о способах использования и поддержки систем. В особых случаях эти инструкции могут содержать также примеры общих способов установки систем, относящихся к безопасности. Все инструкции должны легко восприниматься. Для описания сложных процедур и зависимостей должны использоваться рисунки и схемы.<br/><br/></p><p id="P015A_4" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P015A_5" class="formattext topleveltext indenttext" align="justify">Guidelines for Safe Automation of Chemical Processes. CCPS, AlChE, New York, 1993, ISBN-10: 0-8169-0554-1, ISBN-13: 978-0-8169-0554-6.<br/><br/></p><p id="P015C" class="formattext topleveltext indenttext" align="justify"><b>B.4.2 Удобство общения с пользователем</b><br/><br/></p><p id="P015C_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (таблица В.4).<br/><br/><br/></p><p id="P015C_2" class="formattext topleveltext indenttext" align="justify">Цель. Снижение сложности во время эксплуатации систем, связанных с безопасностью.<br/><br/></p><p id="P015C_3" class="formattext topleveltext indenttext" align="justify">Описание. Правильность эксплуатации систем, связанных с безопасностью, в определенной степени зависит от оператора. Рассматривая конкретный проекты системы и рабочего места, разработчик систем, связанных с безопасностью, должен предусмотреть:<br/><br/></p><p id="P015C_4" class="formattext topleveltext indenttext" align="justify">- необходимость минимального вмешательства человека;<br/><br/></p><p id="P015C_5" class="formattext topleveltext indenttext" align="justify">- необходимое вмешательство наиболее простым способом;<br/><br/></p><p id="P015C_6" class="formattext topleveltext indenttext" align="justify">- возможность минимального ущерба от ошибок оператора;<br/><br/></p><p id="P015C_7" class="formattext topleveltext indenttext" align="justify">- эргономические требования при проектировании средств вмешательства и индикации;<br/><br/></p><p id="P015C_8" class="formattext topleveltext indenttext" align="justify">- простые, имеющие четкую маркировку и удобные для использования средства оператора;<br/><br/></p><p id="P015C_9" class="formattext topleveltext indenttext" align="justify">- неперенапряженность оператора даже в экстремальной ситуации;<br/><br/></p><p id="P015C_10" class="formattext topleveltext indenttext" align="justify">- адаптированность обучения процедурам и средствам процесса вмешательства к уровню знаний и мотивации обучаемого пользователя.<br/><br/></p><p id="P015E" class="formattext topleveltext indenttext" align="justify"><b>В.4.3 Удобство общения с обслуживающим персоналом</b><br/><br/></p><p id="P015E_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (таблица В.4).<br/><br/><br/></p><p id="P015E_2" class="formattext topleveltext indenttext" align="justify">Цель. Упрощение процедуры обслуживания систем, связанных с безопасностью, и проектирование необходимых средств для эффективной диагностики и ремонта.<br/><br/></p><p id="P015E_3" class="formattext topleveltext indenttext" align="justify">Описание. Профилактическое обслуживание и ремонт часто проводятся в сложных условиях давления предельных сроков. Поэтому разработчик систем, связанных с безопасностью, должен предусмотреть, чтобы:<br/><br/></p><p id="P015E_4" class="formattext topleveltext indenttext" align="justify">- средства, относящиеся к обслуживанию безопасности, требовались как можно реже или вообще не требовались;<br/><br/></p><p id="P015E_5" class="formattext topleveltext indenttext" align="justify">- использовались достаточно чувствительные и легко управляемые диагностирующие инструменты для неизбежных ремонтов; эти инструменты должны включать в себя все необходимые интерфейсы;<br/><br/></p><p id="P015E_6" class="formattext topleveltext indenttext" align="justify">- было достаточно времени (если отдельные инструменты диагностики необходимо разработать или приобрести).<br/><br/></p><p id="P0160" class="formattext topleveltext indenttext" align="justify"><b>В.4.4 Сокращение работ на стадии эксплуатации</b><br/><br/></p><p id="P0160_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (таблицы В.4 и В.6).<br/><br/><br/></p><p id="P0160_2" class="formattext topleveltext indenttext" align="justify">Цель. Снизить эксплуатационные возможности для обычного пользователя.<br/><br/></p><p id="P0160_3" class="formattext topleveltext indenttext" align="justify">Описание. Этот подход снижает эксплуатационные возможности путем:<br/><br/></p><p id="P0160_4" class="formattext topleveltext indenttext" align="justify">- ограничения операций в рабочих режимах, например, коммутаторами ключей;<br/><br/></p><p id="P0160_5" class="formattext topleveltext indenttext" align="justify">- ограничения числа используемых в работе элементов;<br/><br/></p><p id="P0160_6" class="formattext topleveltext indenttext" align="justify">- ограничения числа возможных в общем случае рабочих режимов.<br/><br/></p><p id="P0160_7" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0160_8" class="formattext topleveltext indenttext" align="justify">Guidelines for Safe Automation of Chemical Processes. CCPS, AlChE, New York, 1993, ISBN-10: 0-8169-0554-1, ISBN-13: 978-0-8169-0554-6.<br/><br/></p><p id="P0162" class="formattext topleveltext indenttext" align="justify"><b>B.4.5 Эксплуатация только квалифицированным оператором</b><br/><br/></p><p id="P0162_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (таблицы В.4 и В.6).<br/><br/><br/></p><p id="P0162_2" class="formattext topleveltext indenttext" align="justify">Цель. Исключение отказов, обусловленных ошибками оператора.<br/><br/></p><p id="P0162_3" class="formattext topleveltext indenttext" align="justify">Описание. Оператор системы, связанной с безопасностью, обучен до степени, соответствующей уровню сложности и уровню полноты безопасности системы, связанной с безопасностью. В обучение входит изучение основ процесса производства и взаимосвязей между системами, связанными с безопасностью и УО.<br/><br/></p><p id="P0162_4" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0162_5" class="formattext topleveltext indenttext" align="justify">Guidelines for Safe Automation of Chemical Processes. CCPS, AlChE, New York, 1993, ISBN-10: 0-8169-0554-1, ISBN-13: 978-0-8169-0554-6.<br/><br/></p><p id="P0164" class="formattext topleveltext indenttext" align="justify"><b>B.4.6 Защита от ошибок оператора</b><br/><br/></p><p id="P0164_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (таблицы В.4 и В.6).<br/><br/><br/></p><p id="P0164_2" class="formattext topleveltext indenttext" align="justify">Цель. Защита системы от всех видов ошибок оператора.<br/><br/></p><p id="P0164_3" class="formattext topleveltext indenttext" align="justify">Описание. Ложные входные сообщения (значение, время и т.д.) обнаруживаются проверками достоверности или контролем УО. Для того, чтобы объединить эти средства в проекте, необходимо на самом раннем этапе определить, какие из входных сообщений возможны и какие допустимы.<br/><br/></p><p id="P0166" class="formattext topleveltext indenttext" align="justify"><b>В.4.7</b> (Не используется)<br/><br/></p><p id="P0168" class="formattext topleveltext indenttext" align="justify"><b>В.4.8 Защита от модификаций</b><br/><br/></p><p id="P0168_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (таблицы А.17 и А.18).<br/><br/><br/></p><p id="P0168_2" class="formattext topleveltext indenttext" align="justify">Цель. Защита системы, связанной с безопасностью, от модификаций аппаратных средств техническими способами.<br/><br/></p><p id="P0168_3" class="formattext topleveltext indenttext" align="justify">Описание. Модификации или манипуляции обнаруживаются автоматически, например, проверками достоверности сигналов датчиков, обнаружением техническим процессом и автоматическим запуском тестирования. При обнаружении модификации выдается аварийный сигнал.<br/><br/></p><p id="P016A" class="formattext topleveltext indenttext" align="justify"><b>В.4.9 Подтверждение ввода</b><br/><br/></p><p id="P016A_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (таблицы А.17 и А.18).<br/><br/><br/></p><p id="P016A_2" class="formattext topleveltext indenttext" align="justify">Цель. Обнаружение ошибки во время работы самим оператором до активизации УО.<br/><br/></p><p id="P016A_3" class="formattext topleveltext indenttext" align="justify">Описание. Информация, вводимая в УО через систему, связанную с безопасностью, представляется оператору до передачи в УО с тем, чтобы оператор имел возможность обнаружить и исправить ошибки. Проектируемая система должна реагировать на неправильные, самопроизвольные действия оператора и учитывать нижние/верхние пределы скорости и направление реакции оператора. Это позволит исключить, например, более быстрое, чем предполагается, нажатие клавиш оператором, и настроить систему воспринимать двойное нажатие клавиши как одинарное или двойное за счет того, что система (изображение на экране) слишком медленно реагирует на разовое нажатие клавиши. Последовательное нажатие одной и той же клавиши при вводе критических данных должно восприниматься системой как одноразовое; нажатие клавиш &quot;ввод&quot; (enter) или &quot;да&quot; (yes) неограниченное число раз не должно приводить к нарушению безопасности системы.<br/><br/></p><p id="P016A_4" class="formattext topleveltext indenttext" align="justify">Должны быть предусмотрены процедуры формирования временных пауз с возможностью выбора разных ответов (да/нет и  т.п.) с тем, чтобы обеспечить возможность для размышления оператору, а системе - режим ожидания.<br/><br/></p><p id="P016A_5" class="formattext topleveltext indenttext" align="justify">Любая перезагрузка ПЭ системы, связанной с безопасностью, делает эту систему уязвимой, если программные/аппаратные средства не спроектированы с учетом данной ситуации.<br/><br/></p><h3 id="P016D" class="formattext topleveltext indenttext" align="justify" title-level="3"><b>В.5 Интеграция Э/Э/ПЭ системы</b><br/><br/></h3><p id="P016D_1" class="formattext topleveltext indenttext" align="justify">Главная цель. Исключение отказов системы на стадии интеграции и обнаружение любых отказов во время этой и предыдущей стадий.<br/><br/></p><p id="P016F" class="formattext topleveltext indenttext" align="justify"><b>В.5.1 Функциональное тестирование</b><br/><br/></p><p id="P016F_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (таблицы В.3 и В.5) и в МЭК 61508-3 (таблицы А.5-А.7 и С.5-С.7).<br/><br/><br/></p><p id="P016F_2" class="formattext topleveltext indenttext" align="justify">Цель. Обнаружение отказов на стадиях создания спецификации и проектирования. Исключение отказов во время реализации и интеграции программных и аппаратных средств.<br/><br/></p><p id="P016F_3" class="formattext topleveltext indenttext" align="justify">Описание. В процессе функционального тестирования определяется, достигнуты ли заданные характеристики системы. В систему поступают входные данные, которые адекватно характеризуют обычное выполнение операций. Наблюдаемые выходные результаты сравниваются с заданными в спецификации. Отклонения от спецификации и указания на неполноту спецификации документально оформляются.<br/><br/></p><p id="P016F_4" class="formattext topleveltext indenttext" align="justify">Функциональное тестирование электронных компонентов, предназначенных для многоканальной архитектуры, обычно включает в себя промышленные компоненты, каждый из которых поставщик уже протестировал и предварительно подтвердил соответствие. Помимо этого рекомендуется, чтобы покупные промышленные компоненты были протестированы в сочетании с другими компонентами поставщика из той же партии, чтобы выявить неисправности группового типа, которые в противном случае остались бы невыявленными.<br/><br/></p><p id="P016F_5" class="formattext topleveltext indenttext" align="justify">Также о достаточных рабочих возможностях системы см. руководящие материалы (приложение С, С.5.20).<br/><br/></p><p id="P016F_6" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P016F_7" class="formattext topleveltext indenttext" align="justify">Software Testing and Quality Assurance. K. Naik, P. Tripathy, Wiley Interscience, 2008, Print ISBN: 9780471789116 Online ISBN: 9780470382844.<br/><br/></p><p id="P016F_8" class="formattext topleveltext indenttext" align="justify">The Art of Software Testing, Second Edition. G. Myers et al., Wiley &amp; Sons, New York, 2004, ISBN 0471469122, 9780471469124.<br/><br/></p><p id="P016F_9" class="formattext topleveltext indenttext" align="justify">Practical Software Testing: A Process-oriented Approach. I. Burnstein, Springer, 2003, ISBN 0387951318, 9780387951317.<br/><br/></p><p id="P016F_10" class="formattext topleveltext indenttext" align="justify">Dependability of Critical Computer Systems 3. P.G. Bishop et al., Elsevier Applied Science, 1990, ISBN 1-85166-544-7.<br/><br/></p><p id="P0171" class="formattext topleveltext indenttext" align="justify"><b>В.5.2 Тестирование методом &quot;черного ящика&quot;</b><br/><br/></p><p id="P0171_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (таблицы В.3, В.5 и В.6) и в МЭК 61508-3 (таблицы А.5-А.7 и С.5-С.7).<br/><br/><br/></p><p id="P0171_2" class="formattext topleveltext indenttext" align="justify">Цель. Проверка динамического поведения системы в реальных условиях функционирования. Выявление несоответствия функциональной спецификации и оценка ее полезности и устойчивости.<br/><br/></p><p id="P0171_3" class="formattext topleveltext indenttext" align="justify">Описание. Функции системы или программы выполняются в заданном окружении с заданными данными тестирования, которые систематически формируются из спецификации в соответствии с установленными критериями. Это позволяет сравнить поведение системы с ее спецификацией. При проведении тестирования никакие сведения о внутренней структуре системы не используются. Основная цель состоит в том, чтобы определить, правильно ли выполняет функциональный модуль функции, требуемые спецификацией. Метод формирования эквивалентных классов служит примером критерия тестирования данных методом &quot;черного ящика&quot;. Массив входных данных подразделяется на конкретные диапазоны входных значений (эквивалентные классы) на основе спецификации. После этого формируются тестовые примеры из:<br/><br/></p><p id="P0171_4" class="formattext topleveltext indenttext" align="justify">- данных из допустимых диапазонов;<br/><br/></p><p id="P0171_5" class="formattext topleveltext indenttext" align="justify">- данных из недопустимых диапазонов;<br/><br/></p><p id="P0171_6" class="formattext topleveltext indenttext" align="justify">- данных предельных значений диапазонов;<br/><br/></p><p id="P0171_7" class="formattext topleveltext indenttext" align="justify">- экстремальных значений и<br/><br/></p><p id="P0171_8" class="formattext topleveltext indenttext" align="justify">- комбинаций из перечисленных выше классов.<br/><br/></p><p id="P0171_9" class="formattext topleveltext indenttext" align="justify">Могут оказаться эффективными также другие критерии выбора тестовых примеров в различных режимах тестирования (модуля, интеграции и системы). Например, критерий &quot;экстремальные эксплуатационные условия&quot; используется при тестировании системы в процессе подтверждения соответствия.<br/><br/></p><p id="P0171_10" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0171_11" class="formattext topleveltext indenttext" align="justify">Software Testing and Quality Assurance. K. Naik, P. Tripathy, Wiley Interscience, 2008, Print ISBN: 9780471789116 Online ISBN: 9780470382844.<br/><br/></p><p id="P0171_12" class="formattext topleveltext indenttext" align="justify">Essentials of Software Engineering. Frank F. Tsui, Orlando Karam. Jones &amp; Bartlett, 2006. ISBN 076373537X, 9780763735371.<br/><br/></p><p id="P0171_13" class="formattext topleveltext indenttext" align="justify">The Art of Software Testing, Second Edition. G. Myers et al., Wiley &amp; Sons, New York, 2004, ISBN 0471469122, 9780471469124.<br/><br/></p><p id="P0171_14" class="formattext topleveltext indenttext" align="justify">Systematic Software Testing. Rick D. Craig, Stefan P. Jaskiel. Artech House, 2002. ISBN 1580535089, 9781580535083.<br/><br/></p><p id="P0173" class="formattext topleveltext indenttext" align="justify"><b>B.5.3 Статистическое тестирование</b><br/><br/></p><p id="P0173_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (таблицы В.3, В.5 и В.6).<br/><br/><br/></p><p><img class="base64 sign" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZIAAAARCAMAAADAD9oKAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MTg4Q0U3ODQ0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MTg4Q0U3ODU0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoxODhDRTc4MjRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDoxODhDRTc4MzRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pos3t18AAAAzUExURfX19SQkJOrq6oeHh7y8vD8/P9/f31RUVMjIyLCwsHh4eJaWlmdnZ6Ojo9TU1AAAAP////kimdMAAAWSSURBVHja7FiJcuQoDAVzGcz1/1+7TwLRuDs9mZ2karZqQ1ViGz90PUngVv1nfMOo9fg2WarnNkf9FGxMHdDkf1jo3bXBg7o0YhIkfrXV0npvBfd48y94HQtV97XWZvBPfbpG29oikGfQ6oeRs4WLb4K2CGNq5wsltpX6B5TQYEa5/u6h9rdn31QdtXS0iKX1WZ360/o9Pl/3NmVq/ahk/cfwZ0X+bSL6T01Kxmq6Fj0MSDNPj+atGzF1+Y17z9IZMRfulHiH+ivMFvE7nm2ffQ26Q5+U0AKLatWUGFm63kU3SJycuwqNLgNJ1ONf6crorUNyEySMStQLlegNgSuSmiT5agizm0YyZwPNbEXLM64y2X0YcGgdN3ytU9FaLDCecHbCyFWVh0kjMvBEHK+rvx/tVIgOWSoTcZrRa+aVJxeOuLc5nG8Oj2cjCzdKDm1Uj9BCSFeO7sKBgKCxRWpXKNAiFtV2njBAGeqm2QBQaZKCjjDCA+vqnZJD802sAzu9q4EwRtde4djUG4kJeFObpsag4cXNNJKJejRY7pVO9EJiQf2XRJLlBEcW1Toooc48FcniBeN2nOALwwzMDXhDJv2CkoKENkS/NKzu0p74rRyOk0vcezgs0iXQhLDixE4J6YAALgUqoEq6VKpih0KosOuUUihxM+eGo6KIA3DEaTI8oJS7UZIybnhmOVX1wCiqLJSYmnr52WjShadTA7Obtsyl2lP22PquxG9kJ1VbSWN2gEXRfF4wlnri36xnTJBYC+R7ShyX17HNDIcXJSg8ddMqDi/p0+HOCGNfKclwPmdHBsVgp9mbHaemuwBMwtvmCK2pQqtwdpakiZIQg7pTAitwc+m6OVWyWFhnzQy9aMrcDZASSAJjgNlMo5R4UIJ1xbhnSsYr+p/LRslS1FfshQFIpb4v06WRvgBky4VfseOmPqy3zaKiZqp/SEmpOqhdqzi8pE+H6/2wu1PiCg9AkvOvlJi0r2ZbS7FooaMpdo8WYy6ixPFRZKcEE9Iz115irhdKWC/y1VquyIpWqU+i5GEapcRWJaGFFN9T4s7foyRQdqmNkqHvGJmn82AtUzed1s9vB63U6jj6ulOCnnbtWsXhJX06/J6S5LbDmKYuy/W11rgbobKpdRvmtNFKGpfS142SqEcL8CE99hIKV+ZmbDnr/NQL2Slx46wxoDSB2U27NS77eN4oGZaj91G6PChZiubzgo2+i9AKJbEd/S5yKA5ZAnCwLL6IcfYe2aHWb1rF4SV9OjwQ9XylZGwwORFSIeLUakYnHEVAgh6U0D7elY49C1OZNrM09pIC8EaJtnyjdHiIqE4qiY+K2YleProNrUcLhk8Lm2k3SgrF/KVKhuUQVUzfKFmK5vOCvVBytMSb69NeolwS66954oXTvnF2en3b3XmlIo3LPXF4SReHXZ5b3zMlCKcpAVse9z38XXh2kvo9htvuppy+LqeP0LgvBo/IpIJ+b/kQrGUDaM4XPvlBR9IPVq3mlkDldKIJ5k0vnGyzNh2myYvdtJ0S3wLtJeZOybT8uEabQ3kPSkSRUDRhs3HpI2uhKwKZKC8elADStJcASJOg7IcrF9BZvVBCPVi0bg6LdHF4IOqNkvmNaVM2iMWBHqoKLD9TvghAE92ecjdXxkxveb8tHElMxB7PblETZ1G2zDe1eNbBMkVEGdsDl4k3d709uAk86RPY3k2b5lZOIzbxnN2c5xk+LM9jv8PZaIBFkSwWBw9CRWwlLJ3fVZPTuYkUyLT+KPP7VBGAQmGev5tHTGMUrbvDU/pyeNn1oOQLQ74d6yeA51Hyfnn6FWDtmF8bueyXvzx+5XB/3d6/4rbfL+8Bz8Ne++X+s4z5pp/QLrtf/vJ47/B3U/L9Q/Fp4P87fn7R/c+NfwQYAFx9eFOvgdoSAAAAAElFTkSuQmCC"/></p><style>.base64.sign {display: none;}</style><p id="P0173_2" class="formattext topleveltext indenttext" align="justify">Цель. Проверка динамического поведения системы, связанной с безопасностью, и оценка ее полезности и устойчивости.<br/><br/></p><p id="P0173_3" class="formattext topleveltext indenttext" align="justify">Описание. При этом подходе тестируется система или программа с входными данными, выбранными в соответствии с предполагаемым статистическим распределением реальных эксплуатационных входных данных - эксплуатационный профиль.<br/><br/></p><p id="P0173_4" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0175" class="formattext topleveltext indenttext" align="justify">A discussion of statistical testing on a safety-related application. S Kuball, J.H.R. May, Proc. IMechE Vol. 221 Part O: J. Risk and Reliability, Institution of Mechanical Engineers, 2007.<br/><br/></p><p id="P0175_1" class="formattext topleveltext indenttext" align="justify">Practical Reliability Engineering. P. O'Connor, D. Newton, R. Bromley, John Wiley and Sons, 2002, ISBN 0470844639, 9780470844632.<br/><br/></p><p id="P0175_2" class="formattext topleveltext indenttext" align="justify">Dependability of Critical Computer Systems 3. P.G. Bishop et al., Elsevier Applied Science, 1990, ISBN 1-85166-544-7.<br/><br/></p><p id="P0175_3" class="formattext topleveltext indenttext" align="justify">Dependability of Critical Computer Systems 1. F.J. Redmill, Elsevier Applied Science, 1988, ISBN 1-85166-203-0.<br/><br/></p><p id="P0177" class="formattext topleveltext indenttext" align="justify"><b>B.5.4 Полевые испытания</b><br/><br/></p><p id="P0177_1" class="formattext topleveltext indenttext" align="justify">Примечания<br/><br/></p><p id="P0179" class="formattext topleveltext indenttext" align="justify">1 Ссылка на данный метод/средство приведена в МЭК 61508-2 (таблицы В.3, В.5 и В.6).<br/><br/></p><p id="P017B" class="formattext topleveltext indenttext" align="justify">2 См. также приложение С, С.2.10 - аналогичные средства, а в приложении D - статистический подход - то и другое в контексте программного обеспечения.<br/><br/><br/></p><p id="P017B_1" class="formattext topleveltext indenttext" align="justify">Цель. Использование результатов полевых испытаний из различных областей применения в качестве одного из средств исключения сбоев во время интеграции Э/Э/ПЭ системы и/или в процессе подтверждения соответствия Э/Э/ПЭ системы безопасности.<br/><br/></p><p id="P017B_2" class="formattext topleveltext indenttext" align="justify">Описание. Использование компонентов или подсистем, которые при их использовании показали путем испытаний отсутствие или наличие только несущественных ошибок и существенно не изменялись в течение достаточно длительного периода времени во многих различных применениях. В частности, для сложных компонентов с множеством функций (например операционной системы, интегральных схем) разработчик должен обратить внимание на функции, которые были фактически протестированы методом полевых испытаний. Например, должны быть рассмотрены подпрограммы самотестирования для обнаружения сбоев: при отсутствии сбоев аппаратных средств в период эксплуатации о подпрограммах нельзя сказать, что они протестированы, поскольку они никогда не выполняли функций обнаружения своих сбоев.<br/><br/></p><p id="P017B_3" class="formattext topleveltext indenttext" align="justify">При использовании полевых испытаний должны быть соблюдены следующие требования:<br/><br/></p><p id="P017B_4" class="formattext topleveltext indenttext" align="justify">- неизменность спецификации;<br/><br/></p><p id="P017B_5" class="formattext topleveltext indenttext" align="justify">- наличие 10 систем в различных применениях;<br/><br/></p><p id="P017B_6" class="formattext topleveltext indenttext" align="justify">- длительность работы 10<img class="base64" src="data:image;base64,R0lGODdhCwAXAIABAAAAAP///ywAAAAACwAXAAACF4yPqct9ABdwkbowW2Zb9Vdd4kiW5mkWADs=" width="11" height="23"/> ч и по меньшей мере один год сервисной поддержки.<br/><br/></p><p id="P017B_7" class="formattext topleveltext indenttext" align="justify">Примечание - В стандарте сектора применения могут быть определены другие значения этих параметров.<br/><br/><br/></p><p id="P017B_8" class="formattext topleveltext indenttext" align="justify">Полевые испытания документируются поставщиком и/или эксплуатирующей организацией; документация должна по меньшей мере содержать:<br/><br/></p><p id="P017B_9" class="formattext topleveltext indenttext" align="justify">- точное обозначение системы и ее компонентов, включая управление версиями аппаратных средств;<br/><br/></p><p id="P017B_10" class="formattext topleveltext indenttext" align="justify">- сведения о пользователях и времени применения;<br/><br/></p><p id="P017B_11" class="formattext topleveltext indenttext" align="justify">- отработанное время в часах;<br/><br/></p><p id="P017B_12" class="formattext topleveltext indenttext" align="justify">- процедуры выбора системы и прикладные программы, использованные при испытаниях;<br/><br/></p><p id="P017B_13" class="formattext topleveltext indenttext" align="justify">- процедуры обнаружения и регистрации сбоев, а также процедуры устранения их последствий и причин возникновения.<br/><br/></p><p id="P017B_14" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P017B_15" class="formattext topleveltext indenttext" align="justify">IEC 60300-3-2:2004, Dependability management - Part 3-2: Application guide - Collection of dependability data from the field.<br/><br/></p><p id="P017B_16" class="formattext topleveltext indenttext" align="justify">Guidelines for Safe Automation of Chemical Processes. CCPS, AlChE, New York, 1993, ISBN-10: 0-8169-0554-1, ISBN-13: 978-0-8169-0554-6.<br/><br/></p><h3 id="P017E" class="formattext topleveltext indenttext" align="justify" title-level="3"><b>B.6 Подтверждение соответствия Э/Э/ПЭ системы безопасности</b><br/><br/></h3><p id="P017E_1" class="formattext topleveltext indenttext" align="justify">Главная цель. Подтвердить, что Э/Э/ПЭ система, связанная с безопасностью, соответствует спецификации требований к Э/Э/ПЭ системе безопасности и спецификации требований проектирования Э/Э/ПЭ системы.<br/><br/></p><p id="P0180" class="formattext topleveltext indenttext" align="justify"><b>В.6.1 Функциональные испытания в условиях окружающей среды</b><br/><br/></p><p id="P0180_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (таблица В.5).<br/><br/><br/></p><p id="P0180_2" class="formattext topleveltext indenttext" align="justify">Цель. Оценка защищенности системы, связанная с безопасностью, от типовых воздействий окружающей среды.<br/><br/></p><p id="P0180_3" class="formattext topleveltext indenttext" align="justify">Описание. Систему помещают в различные условия окружающей среды (например в соответствии со стандартами серии МЭК 60068 или серии МЭК 61000) и оценивают способности системы выполнять функции безопасности (на соответствие требованиям стандартов, указанных выше).<br/><br/></p><p id="P0180_4" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0180_5" class="formattext topleveltext indenttext" align="justify">IEC 60068-1:1988, Environmental testing - Part 1: General and guidance/Amendment 1(1992).<br/><br/></p><p id="P0180_6" class="formattext topleveltext indenttext" align="justify">IEC 61000-4-1:2006, Electromagnetic compatibility (EMC) - Part 4-1: Testing and measurement techniques - Overview of IEC 61000-4 series.<br/><br/></p><p id="P0180_7" class="formattext topleveltext indenttext" align="justify">Dependability of Critical Computer Systems 3. P.G. Bishop et al., Elsevier Applied Science, 1990, ISBN 1-85166-544-7.<br/><br/></p><p id="P0182" class="formattext topleveltext indenttext" align="justify"><b>B.6.2 Испытания на устойчивость к пиковым выбросам внешних воздействий</b><br/><br/></p><p id="P0182_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (таблицы В.5 и В.6).<br/><br/><br/></p><p id="P0182_2" class="formattext topleveltext indenttext" align="justify">Цель. Проверка способности систем, связанных с безопасностью, справляться с пиковыми выбросами внешних воздействий.<br/><br/></p><p id="P0182_3" class="formattext topleveltext indenttext" align="justify">Описание. В систему загружается типичная прикладная программа и все периферийные линии (цифровые, аналоговые и последовательные интерфейсы, шины, источники питания и т.д.) подвергаются воздействию стандартных шумовых сигналов. Для того, чтобы получить их количественную оценку, целесообразно внимательно подходить к предельным значениям выбросов внешних влияний. Класс помех считается выбранным неверно, если функция системы не выполняется.<br/><br/></p><p id="P0182_4" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0182_5" class="formattext topleveltext indenttext" align="justify">IEC 61000-4-5:2005, Electromagnetic compatibility (EMC) - Part 4-5: Testing and measurement techniques - Surge immunity test.<br/><br/></p><p id="P0184" class="formattext topleveltext indenttext" align="justify">C37.90.1-2002, IEEE Standard for Surge Withstand Capability (SWC) Tests for Relays and Relay Systems Associated with Electric Power Apparatus.<br/><br/></p><p id="P0186" class="formattext topleveltext indenttext" align="justify"><b>B.6.3</b> (He используется.)<br/><br/></p><p id="P0188" class="formattext topleveltext indenttext" align="justify"><b>B.6.4 Статический анализ</b><br/><br/></p><p id="P0188_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (таблицы В.5 и В.6) и в МЭК 61508-3 (таблицы А.9, В.8, С.9 и С.18).<br/><br/><br/></p><p id="P0188_2" class="formattext topleveltext indenttext" align="justify">Цель. Исключение систематических дефектов, которые могут приводить к отказам в тестируемой системе вначале либо после продолжительной эксплуатации.<br/><br/></p><p id="P0188_3" class="formattext topleveltext indenttext" align="justify">Описание. Этот систематический и, возможно, автоматизированный метод позволяет исследовать конкретные статические характеристики опытных образцов системы для обеспечения полноты, согласованности, отсутствия неоднозначностей относительно сформулированных требований (например в руководящих материалах по конструированию, системных спецификациях и инструкциях о применении). Статический анализ должен быть воспроизводим и применим к опытному образцу, который доведен до четко определенной завершающей стадии. Ниже приведены некоторые примеры статического анализа аппаратных и программных средств:<br/><br/></p><p id="P0188_4" class="formattext topleveltext indenttext" align="justify">- анализ согласованности потока данных (например при тестировании, если данные об объекте интерпретируются как имеющие одно значение);<br/><br/></p><p id="P0188_5" class="formattext topleveltext indenttext" align="justify">- анализ управления потоком (например определение маршрутов, кода недоступности);<br/><br/></p><p id="P0188_6" class="formattext topleveltext indenttext" align="justify">- анализ интерфейсов (например исследование передачи переменных между различными программными модулями);<br/><br/></p><p id="P0188_7" class="formattext topleveltext indenttext" align="justify">- анализ потока данных для обнаружения вызывающих сомнения последовательностей для переменных: создание - использование для обращения - удаление;<br/><br/></p><p id="P0188_8" class="formattext topleveltext indenttext" align="justify">- тестирование строгого соблюдения конкретных руководящих материалов (например по вопросам: длина пути утечки тока и зазоры, расстояние между группами модулей, физическое расположение модулей, механически чувствительные физические модули, индивидуальное использование физических модулей при их внедрении).<br/><br/></p><p id="P0188_9" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0188_10" class="formattext topleveltext indenttext" align="justify">Static Analysis and Software Assurance. D. Wagner, Lecture Notes in Computer Science, Volume 2126/2001, Springer, 2001, ISBN 978-3-540-42314-0.<br/><br/></p><p id="P0188_11" class="formattext topleveltext indenttext" align="justify">An Industrial Perspective on Static Analysis. B.A. Wichmann, A.A. Canning, D.L. Clutterbuck, L.A. Winsborrow, N.J. Ward and D.W.R. Marsh. Software Engineering Journal., 69-75, March 1995.<br/><br/></p><p id="P0188_12" class="formattext topleveltext indenttext" align="justify">Dependability of Critical Computer Systems 3. P.G. Bishop et al., Elsevier Applied Science, 1990, ISBN 1-85166-544-7.<br/><br/></p><p id="P018A" class="formattext topleveltext indenttext" align="justify"><b>B.6.5 Динамический анализ и тестирование</b><br/><br/></p><p id="P018A_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (таблицы В.5 и В.6) и в МЭК 61508-3 (таблицы А.5, А.9, В.2, С.5, С.9 и С.12).<br/><br/><br/></p><p id="P018A_2" class="formattext topleveltext indenttext" align="justify">Цель. Обнаружение ошибок в спецификации путем исследования динамического поведения опытных образцов на завершающих стадиях.<br/><br/></p><p id="P018A_3" class="formattext topleveltext indenttext" align="justify">Описание. Динамический анализ систем, связанных с безопасностью, проводится при подаче на вход опытного образца системы, связанной с безопасностью, входных данных, которые типичны для заданного эксплуатационного окружения. Анализ будет удовлетворительным, если наблюдаемое поведение системы, связанной с безопасностью, соответствует требуемому поведению. Любой отказ системы, связанной с безопасностью, должен быть устранен, после чего новые варианты эксплуатации системы должны быть проанализированы.<br/><br/></p><p id="P018A_4" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P018A_5" class="formattext topleveltext indenttext" align="justify">The Concept of Dynamic Analysis. Т. Ball, ESEC/FSE '99, Lecture Notes in Computer Science, Springer, 1999, ISBN 978-3-540-66538-0.<br/><br/></p><p id="P018A_6" class="formattext topleveltext indenttext" align="justify">Dependability of Critical Computer Systems 3. P.G. Bishop et al., Elsevier Applied Science, 1990, ISBN 1-85166-544-7.<br/><br/></p><p id="P018C" class="formattext topleveltext indenttext" align="justify"><b>B.6.6 Анализ отказов</b><br/><br/></p><p id="P018C_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (таблицы В.5 и В.6).<br/><br/></p><p id="P018E" class="formattext topleveltext indenttext" align="justify">В.6.6.1 Анализ видов и последствий отказов<br/><br/></p><p id="P018E_1" class="formattext topleveltext indenttext" align="justify">Цель. Проведение анализа проекта системы с систематическим исследованием всех возможных причин отказов компонентов системы и определением влияния этих отказов на поведение и безопасность системы.<br/><br/></p><p id="P018E_2" class="formattext topleveltext indenttext" align="justify">Описание. Анализ обычно проводится экспертным методом. Каждый компонент системы анализируется по очереди с тем, чтобы выявить набор режимов отказов для компонента, их причины и результаты (на локальном уровне и на уровне всей системы), процедуры обнаружения и рекомендации. При выдаче рекомендаций они документально оформляются в виде корректирующих действий.<br/><br/></p><p id="P018E_3" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P018E_4" class="formattext topleveltext indenttext" align="justify">IEC 60812:2006, Analysis techniques for system reliability - Procedure for failure mode and effects analysis (FMEA).<br/><br/></p><p id="P018E_5" class="formattext topleveltext indenttext" align="justify">Risk Assessment and Risk Management for the Chemical Process Industry. H.R. Greenberg, J.J. Cramer, John Wiley and Sons, 1991, ISBN 0471288829, 9780471288824.<br/><br/></p><p id="P018E_6" class="formattext topleveltext indenttext" align="justify">Reliability Technology. A.E. Green, A.J. Bourne, Wiley-lnterscience, 1972, ISBN 0471324809.<br/><br/></p><p id="P0190" class="formattext topleveltext indenttext" align="justify">B.6.6.2 Причинно-следственные диаграммы<br/><br/></p><p id="P0190_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблицы В.3, В.4, С.13 и С.14).<br/><br/><br/></p><p id="P0190_2" class="formattext topleveltext indenttext" align="justify">Цель. Моделирование с помощью причинно-следственных диаграмм, которые могут представить проект системы в виде последовательности комбинаций базовых событий.<br/><br/></p><p id="P0190_3" class="formattext topleveltext indenttext" align="justify">Описание. Данное средство может рассматриваться как комбинация процедур анализа с помощью дерева отказов и дерева событий. Начиная с критического (начального) события, граф последствий просматривается в прямом направлении, используя логические элементы ДА/НЕТ, описывающие успех и неудачу некоторых операций. Это позволяет сформировать последовательность событий, ведущую или к аварии или к корректной ситуации. Затем для каждого отказа строятся графы причин (то есть деревья отказов). Прохождение в обратном направлении эквивалентно дереву отказов, где критическое событие представлено в виде события, описанного на верхнем уровне. Прохождение в прямом направлении позволяет определять возможные последствия, возникающие из события. В узле графа могут быть символы, описывающие условия распространения причин по различным ветвям от этого узла. Временные задержки также могут учитываться. Эти условия распространения причин также могут быть описаны с помощью деревьев отказов. Для того чтобы диаграмма выглядела более компактной, пути распространения причин могут быть объединены с логическими символами. Должен быть определен набор стандартных символов для использования в причинно-следственных диаграммах. Такие диаграммы могут быть использованы для генерации деревьев отказов и для вычисления вероятности появления определенных критических последовательностей. Они также могут быть использованы для генерации деревьев событий.<br/><br/></p><p id="P0190_4" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0190_5" class="formattext topleveltext indenttext" align="justify">IEC 62502:2010, Analysis techniques for dependability - Event tree analysis (ETA).<br/><br/></p><p id="P0190_6" class="formattext topleveltext indenttext" align="justify">The Cause Consequence Diagram Method as a Basis for Quantitative Accident Analysis. B.S. Nielsen, Danish Atomic Energy Commission, Riso-M-1374, 1971.<br/><br/></p><p id="P0192" class="formattext topleveltext indenttext" align="justify">B.6.6.3 Анализ дерева событий<br/><br/></p><p id="P0192_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблица В.4 и С.14).<br/><br/><br/></p><p id="P0192_2" class="formattext topleveltext indenttext" align="justify">Цель. Моделирование с помощью диаграмм последовательности событий, которая может возникнуть в системе после появления инициализирующего события и указать на возможные опасные последствия. Дерево события трудно создать с нуля, поэтому полезно использовать схему последовательности событий.<br/><br/></p><p id="P0192_3" class="formattext topleveltext indenttext" align="justify">Описание. В верхней части диаграммы записывается последовательность условий, относящихся к формированию последовательности событий, следующих за инициализирующим событием. Начиная с инициализирующего события, являющегося целью анализа, проводится прямая линия к первому условию последовательности. Наличие ветвей &quot;да&quot; и &quot;нет&quot; диаграммы указывает на зависимость будущего события от условий. Каждая из двух ветвей продолжается до следующего условия. Однако не все условия выполняются на этих ветвях. Какая-то из них продолжится до окончания последовательности условий, но каждая ветвь дерева, построенная таким способом, представляет возможную последовательность. Если условия в последовательностях независимы, дерево событий может быть использовано для вычисления вероятностей различных последовательностей, основываясь на значениях вероятностей условий и их числе в последовательности. Поскольку условия редко бывают полностью независимыми, такие вычисления необходимо тщательно рассмотреть и это должны выполнять квалифицированные аналитики.<br/><br/></p><p><img class="base64 sign" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZIAAAARCAMAAADAD9oKAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MTg4Q0U3ODQ0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MTg4Q0U3ODU0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoxODhDRTc4MjRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDoxODhDRTc4MzRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pos3t18AAAAzUExURfX19SQkJOrq6oeHh7y8vD8/P9/f31RUVMjIyLCwsHh4eJaWlmdnZ6Ojo9TU1AAAAP////kimdMAAAWSSURBVHja7FiJcuQoDAVzGcz1/1+7TwLRuDs9mZ2karZqQ1ViGz90PUngVv1nfMOo9fg2WarnNkf9FGxMHdDkf1jo3bXBg7o0YhIkfrXV0npvBfd48y94HQtV97XWZvBPfbpG29oikGfQ6oeRs4WLb4K2CGNq5wsltpX6B5TQYEa5/u6h9rdn31QdtXS0iKX1WZ360/o9Pl/3NmVq/ahk/cfwZ0X+bSL6T01Kxmq6Fj0MSDNPj+atGzF1+Y17z9IZMRfulHiH+ivMFvE7nm2ffQ26Q5+U0AKLatWUGFm63kU3SJycuwqNLgNJ1ONf6crorUNyEySMStQLlegNgSuSmiT5agizm0YyZwPNbEXLM64y2X0YcGgdN3ytU9FaLDCecHbCyFWVh0kjMvBEHK+rvx/tVIgOWSoTcZrRa+aVJxeOuLc5nG8Oj2cjCzdKDm1Uj9BCSFeO7sKBgKCxRWpXKNAiFtV2njBAGeqm2QBQaZKCjjDCA+vqnZJD802sAzu9q4EwRtde4djUG4kJeFObpsag4cXNNJKJejRY7pVO9EJiQf2XRJLlBEcW1Toooc48FcniBeN2nOALwwzMDXhDJv2CkoKENkS/NKzu0p74rRyOk0vcezgs0iXQhLDixE4J6YAALgUqoEq6VKpih0KosOuUUihxM+eGo6KIA3DEaTI8oJS7UZIybnhmOVX1wCiqLJSYmnr52WjShadTA7Obtsyl2lP22PquxG9kJ1VbSWN2gEXRfF4wlnri36xnTJBYC+R7ShyX17HNDIcXJSg8ddMqDi/p0+HOCGNfKclwPmdHBsVgp9mbHaemuwBMwtvmCK2pQqtwdpakiZIQg7pTAitwc+m6OVWyWFhnzQy9aMrcDZASSAJjgNlMo5R4UIJ1xbhnSsYr+p/LRslS1FfshQFIpb4v06WRvgBky4VfseOmPqy3zaKiZqp/SEmpOqhdqzi8pE+H6/2wu1PiCg9AkvOvlJi0r2ZbS7FooaMpdo8WYy6ixPFRZKcEE9Iz115irhdKWC/y1VquyIpWqU+i5GEapcRWJaGFFN9T4s7foyRQdqmNkqHvGJmn82AtUzed1s9vB63U6jj6ulOCnnbtWsXhJX06/J6S5LbDmKYuy/W11rgbobKpdRvmtNFKGpfS142SqEcL8CE99hIKV+ZmbDnr/NQL2Slx46wxoDSB2U27NS77eN4oGZaj91G6PChZiubzgo2+i9AKJbEd/S5yKA5ZAnCwLL6IcfYe2aHWb1rF4SV9OjwQ9XylZGwwORFSIeLUakYnHEVAgh6U0D7elY49C1OZNrM09pIC8EaJtnyjdHiIqE4qiY+K2YleProNrUcLhk8Lm2k3SgrF/KVKhuUQVUzfKFmK5vOCvVBytMSb69NeolwS66954oXTvnF2en3b3XmlIo3LPXF4SReHXZ5b3zMlCKcpAVse9z38XXh2kvo9htvuppy+LqeP0LgvBo/IpIJ+b/kQrGUDaM4XPvlBR9IPVq3mlkDldKIJ5k0vnGyzNh2myYvdtJ0S3wLtJeZOybT8uEabQ3kPSkSRUDRhs3HpI2uhKwKZKC8elADStJcASJOg7IcrF9BZvVBCPVi0bg6LdHF4IOqNkvmNaVM2iMWBHqoKLD9TvghAE92ecjdXxkxveb8tHElMxB7PblETZ1G2zDe1eNbBMkVEGdsDl4k3d709uAk86RPY3k2b5lZOIzbxnN2c5xk+LM9jv8PZaIBFkSwWBw9CRWwlLJ3fVZPTuYkUyLT+KPP7VBGAQmGev5tHTGMUrbvDU/pyeNn1oOQLQ74d6yeA51Hyfnn6FWDtmF8bueyXvzx+5XB/3d6/4rbfL+8Bz8Ne++X+s4z5pp/QLrtf/vJ47/B3U/L9Q/Fp4P87fn7R/c+NfwQYAFx9eFOvgdoSAAAAAElFTkSuQmCC"/></p><style>.base64.sign {display: none;}</style><p id="P0192_4" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0192_5" class="formattext topleveltext indenttext" align="justify">IEC 62502:2010, Analysis techniques for dependability - Event tree analysis (ETA).<br/><br/></p><p id="P0192_6" class="formattext topleveltext indenttext" align="justify">Risk Assessment and Risk Management for the Chemical Process Industry. H.R. Greenberg, J.J. Cramer, John Wiley and Sons, 1991, ISBN 0471288829, 9780471288824.<br/><br/></p><p id="P0194" class="formattext topleveltext indenttext" align="justify">B.6.6.4 Анализ видов, последствий и критичности отказов<br/><br/></p><p id="P0194_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблицы А.10, В.4, С.10 и С.14).<br/><br/><br/></p><p id="P0194_2" class="formattext topleveltext indenttext" align="justify">Цель. Ранжирование критичности компонентов, которые могут вызвать нарушения, повреждения или ухудшение работы системы при одиночных ошибках в целях определить, каким компонентам может потребоваться особое внимание и какие средства управления необходимы в процессе проектирования или эксплуатации.<br/><br/></p><p id="P0194_3" class="formattext topleveltext indenttext" align="justify">Описание. Этот метод сопоставим с FMEA, но отличается наличием одного или нескольких столбцов для описания критичности, которая может быть ранжирована многими методами. Наиболее сложный метод описан Обществом автомобильных инженеров (Society for Automotive Engineers - SAE) в ARP 926. В этом методе значение критичности для любого компонента определяется числом отказов конкретного вида, предполагаемым в процессе выполнения каждого миллиона операций, реализуемых в критическом режиме. Критичность является функцией девяти параметров, большинство из которых должны быть измерены. Очень простой метод определения критичности состоит в умножении вероятности отказа компонента на величину ущерба, который может быть при этом нанесен; этот метод аналогичен простой оценке показателя риска.<br/><br/></p><p id="P0194_4" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0194_5" class="formattext topleveltext indenttext" align="justify">IEC 60812:2006, Analysis techniques for system reliability - Procedure for failure mode and effects analysis (FMEA).<br/><br/></p><p id="P0194_6" class="formattext topleveltext indenttext" align="justify">Software criticality analysis of COTS/SOUP. P. Bishop, T. Clement, S. Guerra. In Reliability Engineering &amp; System Safety, Volume 81, Issue 3, September 2003, Elsevier Ltd., 2003.<br/><br/></p><p id="P0194_7" class="formattext topleveltext indenttext" align="justify">Software FMEA techniques. P.L. Goddard. In Proc Annual 2000 Reliability and Maintainability Symposium, IEEE, 2000, ISBN: 0-7803-5848-1.<br/><br/></p><p id="P0194_8" class="formattext topleveltext indenttext" align="justify">SAE-ARP-926-1997 Fault/failure analysis procedure.<br/><br/></p><p id="P0196" class="formattext topleveltext indenttext" align="justify">B.6.6.5 Анализ дерева отказов<br/><br/></p><p id="P0196_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблица В.4 и В.14).<br/><br/><br/></p><p id="P0196_2" class="formattext topleveltext indenttext" align="justify">Цель. Помощь в анализе событий или комбинации событий, которые вызывают угрозы или опасные последствия, и в выполнении вычисления вероятности главного события.<br/><br/></p><p id="P0196_3" class="formattext topleveltext indenttext" align="justify">Описание. Начиная с главного события, которое может непосредственно вызвать угрозу или опасные последствия (&quot;событие вершины дерева&quot;), выполняется анализ, чтобы идентифицировать причины этого события. Комбинации причины описываются логическими операторами (&quot;И&quot;, &quot;ИЛИ&quot; и т.д.). Затем анализируются промежуточные причины тем же способом и т.д., возвращаясь к базовым событиям, где анализ прекращается.<br/><br/></p><p id="P0196_4" class="formattext topleveltext indenttext" align="justify">Данный метод является графическим, и для изображения дерева отказов используется набор стандартизованных символов. В результате анализа дерево отказа представляет собой логическую функцию, объединяющую базовые события (обычно отказы компонентов) с главным событием (полный отказ системы). Рассматриваемый метод предназначен в основном для анализа аппаратных средств, но допускается также применять его к анализу ошибок программного обеспечения. Этот метод может использоваться для качественного анализа отказов (идентификация сценариев отказа: минимальные сечения или простые импликанты), полуколичественно (оценивая сценарии их вероятностями) и количественно для вычислений вероятности главного события (см. С.6).<br/><br/></p><p id="P0196_5" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0196_6" class="formattext topleveltext indenttext" align="justify">IEC 61025:2006, Fault tree analysis (FTA).<br/><br/></p><p id="P0196_7" class="formattext topleveltext indenttext" align="justify">From safety analysis to software requirements. K.M. Hansen, A.P. Ravn, A.P, V Stavridou. IEEE Trans Software Engineering, Volume 24, Issue 7, Jul 1998.<br/><br/></p><p id="P0198" class="formattext topleveltext indenttext" align="justify">B.6.6.6 Модели Маркова<br/><br/></p><p id="P0198_1" class="formattext topleveltext indenttext" align="justify">Примечание - Краткое сравнение данного метода с методом, основанным на блок-схемах надежности, при анализе полноты безопасности аппаратных средств см. в МЭК 61508-6 (приложение В.1).<br/><br/><br/></p><p id="P0198_2" class="formattext topleveltext indenttext" align="justify">Цель. Моделирование поведения систем, используя граф состояний-переходов, и оценка общесистемных параметров (ненадежность, неготовность, безопасности MTTF, MUT, MDT и др.) системы.<br/><br/></p><p id="P0198_3" class="formattext topleveltext indenttext" align="justify">Описание. Это - конечный автомат (см. В.2.3.2), представленный направленным графом. Узлы (круги) представляют состояния, а ребра (стрелки) между узлами представляют переходы (отказы, ремонты и т.д.), происходящие между состояниями. Ребра имеют весовые коэффициенты, соответствующие частотам отказов или частотам восстановлений. Фундаментальное свойство однородных процессов Маркова заключается в том, что будущее состояние зависит только от настоящего состояния, то есть переход из состояния <img class="base64" src="data:image;base64,R0lGODdhEwATAIABAAAAAP///ywAAAAAEwATAAACKIyPqcvtDw+YaNIGUn7XbBx8ITd60IaSZgmaIvNlr/J2ixVH+s73TQEAOw==" width="19" height="19"/> к последующему состоянию <img class="base64" src="data:image;base64,R0lGODdhIwATAIABAAAAAP///ywAAAAAIwATAAACQoyPqcvtD6OctIGLLoaAp85tjhiA32IyXZoerfGeZlyiD4irtuXCmQacjXq0mqJorBVjy0/zqNL0eE5k5YrNareVAgA7" width="35" height="19"/> не зависит от предыдущего состояния <img class="base64" src="data:image;base64,R0lGODdhIQATAIABAAAAAP///ywAAAAAIQATAAACPYyPqcvtD6OcNICLLn6Ap85tjWhJINOdZaQq6dE6cWaAMzrCNaz1NL67ARen1+TWIkFmvt1RWYlKp9RqpAAAOw==" width="33" height="19"/>. Это означает, что все вероятностные законы моделей экспоненциальны.<br/><br/></p><p id="P0198_4" class="formattext topleveltext indenttext" align="justify">Следует заметить, что события, состояния и частоты отказов могут быть детализированы так, что может быть получено точное описание системы, например, обнаруженные или необнаруженные отказы, обнаружение наибольшего отказа и  т.п. Интервалы контрольных проверок также могут быть смоделированы должным образом при помощи так называемых многофазных процессов Маркова, где вероятности состояний в конце одной фазы (например как раз перед контрольным испытанием) могут использоваться для вычисления начальных условий для следующей фазы (например вероятности различных состояний после того, как контрольная проверка была выполнена).<br/><br/></p><p id="P0198_5" class="formattext topleveltext indenttext" align="justify">Метод Маркова подходит для моделирования многих систем, уровень избыточности которых изменяется со временем вследствие нахождения компонента в состоянии отказа или восстановления. Другие классические методы, например, FMEA и FTA, не могут быть адаптированы к моделированию влияний отказов в течение жизненного цикла системы, поскольку не существует простой комбинаторной формулы для вычисления соответствующих вероятностей.<br/><br/></p><p id="P0198_6" class="formattext topleveltext indenttext" align="justify">В простейших случаях такую формулу, описывающую вероятности системы, можно найти в литературе или вывести самостоятельно. В более сложных случаях существуют методы упрощения (то есть сокращение числа состояний).<br/><br/></p><p id="P0198_7" class="formattext topleveltext indenttext" align="justify">Тем не менее, однородный граф Маркова описывается системой линейных дифференциальных уравнений с постоянными коэффициентами. Был проведен серьезный анализ таких систем, в результате для их решения были разработаны мощные алгоритмы, которые доступны. Поэтому с увеличением размера модели очень эффективно использовать вышеупомянутые алгоритмы, которые реализованы в виде различных пакетов программного обеспечения.<br/><br/></p><p id="P0198_8" class="formattext topleveltext indenttext" align="justify">Нужно отметить, что размер графа растет экспоненциально с числом компонентов, это - так называемый комбинаторный взрыв. Поэтому данный метод применим без аппроксимаций только для небольших систем.<br/><br/></p><p id="P0198_9" class="formattext topleveltext indenttext" align="justify">Если законы распределения неэкспоненциальные (полумарковские процессы), то необходимо использовать метод моделирования Монте-Карло (см. В.6.6.8).<br/><br/></p><p id="P0198_10" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0198_11" class="formattext topleveltext indenttext" align="justify">IEC 61165:1995 Application of Markov techniques.<br/><br/></p><p id="P0198_12" class="formattext topleveltext indenttext" align="justify">The Theory of Stochastic Processes. R.E. Cox and H.D. Miller, Methuen and Co. Ltd., London, UK, 1963.<br/><br/></p><p id="P0198_13" class="formattext topleveltext indenttext" align="justify">Finite MARKOV Chains. J.G. Kemeny and J.L. Snell. D. Van Nostrand Company Inc, Princeton, 1959.<br/><br/></p><p id="P0198_14" class="formattext topleveltext indenttext" align="justify">The Theory and Practice of Reliable System Design. D.P. Siewiorek and R.S. Swarz, Digital Press, 1982.<br/><br/></p><p id="P0198_15" class="formattext topleveltext indenttext" align="justify"><img class="normal" src="https://api.docs.cntd.ru/img/12/00/10/32/42/135f542c-1dc5-4db8-9c2d-74263b12735c/P01980003.png" width="71" height="16"/> des architectures informatiques. Jean-Louis Boulanger, <img class="normal" src="https://api.docs.cntd.ru/img/12/00/10/32/42/135f542c-1dc5-4db8-9c2d-74263b12735c/P01980004.png" width="47" height="16"/> - Lavoisier 2009, ISBN: 978-2-7462-1991-5.<br/><br/></p><p id="P019A" class="formattext topleveltext indenttext" align="justify">B.6.6.7 Структурные схемы надежности<br/><br/></p><p id="P019A_1" class="formattext topleveltext indenttext" align="justify">Примечания<br/><br/></p><p id="P019C" class="formattext topleveltext indenttext" align="justify">1 Данный метод/средство используется в МЭК 61508-6 (приложение В).<br/><br/></p><p id="P019E" class="formattext topleveltext indenttext" align="justify">2 См. также С.6.4 &quot;Структурные схемы надежности&quot;.<br/><br/><br/></p><p id="P019E_1" class="formattext topleveltext indenttext" align="justify">Цель. Моделирование в форме диаграмм набора событий, которые должны происходить, и условий, которые должны быть удовлетворены, для успешного выполнения операций системы или задач. Данный метод в большей степени является методом представления, чем методом анализа.<br/><br/></p><p id="P019E_2" class="formattext topleveltext indenttext" align="justify">Описание. Данный метод позволяет сформировать успешный маршрут, состоящий из блоков, линий и логических переходов. Такой успешный маршрут начинается от одной стороны диаграммы и проходит через блоки и логические переходы до другой стороны диаграммы. Блок представляет собой условие или событие, маршрут проходит через него, если условие истинно или событие произошло. Когда маршрут подходит к логическому переходу, то он продолжается, если критерий логического перехода выполняется. Если маршрут достигает какой-либо вершины, то он может продолжаться по всем исходящим из нее путям. Если существует по меньшей мере один успешный маршрут через всю диаграмму, то цель анализа считается достигнутой.<br/><br/></p><p id="P019E_3" class="formattext topleveltext indenttext" align="justify">Данный метод позволяет сформировать структурное представление моделируемой системы. Эта структура напоминает электрическую схему, в которой ток протекает от входа к выходу, что означает, что моделируемая система работает должным образом. Если в схеме есть разрыв, то это означает, что в моделируемой системе произошел отказ. В результате появляется концепция наборов минимальных сечений, которые представляют комбинации отказов (т.е. места, где структурная схема надежности имеет &quot;разрыв&quot;), приводящих к отказу моделируемой системы.<br/><br/></p><p id="P019E_4" class="formattext topleveltext indenttext" align="justify">Математически данный метод подобен дереву отказов. Он представляет логическую функцию, связывающую состояния отдельных компонентов (отказавших или работающих) с состоянием всей системы (отказавшей или работающей). Поэтому вычисления подобны тем, которые описаны для дерева отказов.<br/><br/></p><p id="P019E_5" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P019E_6" class="formattext topleveltext indenttext" align="justify">IEC 61078:2006 Analysis techniques for dependability - Reliability block diagram method.<br/><br/></p><p id="P019E_7" class="formattext topleveltext indenttext" align="justify"><img class="normal" src="https://api.docs.cntd.ru/img/12/00/10/32/42/135f542c-1dc5-4db8-9c2d-74263b12735c/P019E0000.png" width="71" height="16"/> des architectures informatiques. Jean-Louis Boulanger, <img class="normal" src="https://api.docs.cntd.ru/img/12/00/10/32/42/135f542c-1dc5-4db8-9c2d-74263b12735c/P019E0001.png" width="47" height="16"/> - Lavoisier 2009, ISBN: 978-2-7462-1991-5.<br/><br/></p><p id="P01A0" class="formattext topleveltext indenttext" align="justify">B.6.6.8 Моделирование методом Монте-Карло<br/><br/></p><p id="P01A0_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблица В.4) и используется в МЭК 61508-6 (приложение В).<br/><br/><br/></p><p id="P01A0_2" class="formattext topleveltext indenttext" align="justify">Цель. Моделирование ситуаций реального мира методом генерации случайных чисел, когда аналитические методы не применимы.<br/><br/></p><p id="P01A0_3" class="formattext topleveltext indenttext" align="justify">Описание. Моделирование методом Монте-Карло используется для решения двух классов проблем:<br/><br/></p><p id="P01A0_4" class="formattext topleveltext indenttext" align="justify">- вероятностного, в котором для генерации стохастических ситуаций используются случайные числа;<br/><br/></p><p id="P01A0_5" class="formattext topleveltext indenttext" align="justify">- детерминистического, который математически преобразуется в эквивалентную вероятностную форму.<br/><br/></p><p id="P01A0_6" class="formattext topleveltext indenttext" align="justify">Принцип моделирования Монте-Карло использует случайные числа для анимации модели поведения правильно и неправильно функционирующей исследуемой системы. Такие поведенческие модели реализуются моделями состояния-переходы (граф Маркова, сети Петри, формальные языки и т.д.). Моделирование Монте-Карло позволяет получить большую статистическую выборку, из которой формируются статистические результаты.<br/><br/></p><p id="P01A0_7" class="formattext topleveltext indenttext" align="justify">При использовании моделирования Монте-Карло необходимо заботиться о том, чтобы гарантировать, что смещения, допуски или шум были в приемлемых диапазонах. Этим необходимо управлять через доверительный интервал, который легко может быть получен из моделирований. Вопреки аналитическим методам моделирование Монте-Карло является самоаппраксимирующимся. Для упрощения модели незначительные события просто не появляются без необходимости их идентификации.<br/><br/></p><p id="P01A0_8" class="formattext topleveltext indenttext" align="justify">Общие принципы моделирования методом Монте-Карло заключаются в переформулировании проблемы так, чтобы полученные результаты были как можно более точными, что позволяет отказаться от решения проблемы в ее исходной постановке.<br/><br/></p><p id="P01A0_9" class="formattext topleveltext indenttext" align="justify">В контексте настоящего стандарта моделирование Монте-Карло может использоваться для вычислений УПБ и учитывать неопределенности данных о надежности. Используя современные компьютеры, можно легко выполнить моделирование системы с УПБ 4.<br/><br/></p><p id="P01A0_10" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P01A0_11" class="formattext topleveltext indenttext" align="justify">Monte Carlo Methods. J.M. Hammersley, D. С Handscomb, Chapman &amp; Hall, 1979.<br/><br/></p><p id="P01A0_12" class="formattext topleveltext indenttext" align="justify"><img class="normal" src="https://api.docs.cntd.ru/img/12/00/10/32/42/135f542c-1dc5-4db8-9c2d-74263b12735c/P01A00000.png" width="71" height="16"/> des architectures informatiques. Jean-Louis Boulanger, <img class="normal" src="https://api.docs.cntd.ru/img/12/00/10/32/42/135f542c-1dc5-4db8-9c2d-74263b12735c/P01A00001.png" width="47" height="16"/> - Lavoisier 2009, ISBN: 978-2-7462-1991-5.<br/><br/></p><p id="P01A2" class="formattext topleveltext indenttext" align="justify">B.6.6.9 Модели дерева отказов<br/><br/></p><p id="P01A2_1" class="formattext topleveltext indenttext" align="justify">Примечания<br/><br/></p><p id="P01A4" class="formattext topleveltext indenttext" align="justify">1 О применении данного метода для анализа полноты безопасности аппаратного обеспечения см. в МЭК 61508-6.<br/><br/></p><p id="P01A6" class="formattext topleveltext indenttext" align="justify">2 Применение дерева отказов в качестве средства подтверждения соответствия безопасности уже было описано в В.6.6.5. Данный метод также широко используется для анализа отказов и вероятностных расчетов.<br/><br/><br/></p><p id="P01A6_1" class="formattext topleveltext indenttext" align="justify">Цель. При помощи систематического нисходящего графического (следствие - причина) подхода построить логическую функцию, связывающую базовые события (виды отказов) с главным событием (нежелательное событие).<br/><br/></p><p id="P01A6_2" class="formattext topleveltext indenttext" align="justify">Описание. Это одновременно и метод анализа, помогающий аналитику шаг за шагом разработать модель, и математическая модель для вероятностных расчетов. Данный метод позволяет выполнять:<br/><br/></p><p id="P01A6_3" class="formattext topleveltext indenttext" align="justify">- качественный анализ путем выявления и сортировки сценариев отказов (минимальные сечения или простейшие импликанты);<br/><br/></p><p id="P01A6_4" class="formattext topleveltext indenttext" align="justify">- полукачественный анализ путем ранжирования сценариев в соответствии с их вероятностями возникновения;<br/><br/></p><p id="P01A6_5" class="formattext topleveltext indenttext" align="justify">- количественный анализ путем расчета вероятности главного события.<br/><br/></p><p id="P01A6_6" class="formattext topleveltext indenttext" align="justify">Подобно блок-схемам надежности, дерево отказов представляет логическую (булеву) функцию, связывающую состояния индивидуальных компонентов (отказал или работает) с состоянием всей системы (отказала или работает). Если компоненты являются независимыми, то вероятностные расчеты для логической функции могут быть выполнены только с учетом вероятностных свойств базовых компонентов. Это не так просто, поскольку это статическая модель в основном работает только с постоянными вероятностями. Расчет вероятностей, зависимых от времени, должен быть проведен особенно внимательно. Например, PFDavg систем безопасности, включающих периодическое контрольное тестирование компонентов, не может быть рассчитан непосредственно, кроме того, еще более сложно рассчитать PFH для систем безопасности, работающих в непрерывном режиме. Поэтому с помощью данного метода только инженеры по надежности с глубоким пониманием математики, лежащей в основе данного метода, должны проводить расчеты значений неготовность/PFD и ненадежность/PFH.<br/><br/></p><p id="P01A6_7" class="formattext topleveltext indenttext" align="justify">Для очень простых деревьев отказов расчеты могут быть проведены вручную, однако за последние 50 лет было разработано и реализовано довольно большое количество алгоритмов для решения сложных логических уравнений. Наиболее современным на текущий момент является метод двоичных диаграмм решений (Binary Decision Diagrams, BDD), который основан на технике компактного кодирования логических уравнений в памяти компьютера. В настоящее время это единственный метод, способный выполнять вероятностные расчеты без приближений для систем промышленных размеров. Он также достаточно эффективен для обработки неопределенностей при моделировании методом Монте-Карло.<br/><br/></p><p id="P01A6_8" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P01A6_9" class="formattext topleveltext indenttext" align="justify">IEC 61025:2006, Fault tree analysis (FTA).<br/><br/></p><p id="P01A8" class="formattext topleveltext indenttext" align="justify">B.6.6.10 Обобщенные стохастические модели сетей Петри<br/><br/></p><p id="P01A8_1" class="formattext topleveltext indenttext" align="justify">Примечания<br/><br/></p><p id="P01AA" class="formattext topleveltext indenttext" align="justify">1 О применении данного метода для анализа полноты безопасности аппаратного обеспечения см. в МЭК 61508-6.<br/><br/></p><p id="P01AC" class="formattext topleveltext indenttext" align="justify">2 Метод сетей Петри уже был описан в В.2.3.3 как полуформальный метод. Данный метод также может быть эффективно использован для анализа полноты безопасности аппаратного обеспечения.<br/><br/><br/></p><p id="P01AC_1" class="formattext topleveltext indenttext" align="justify">Цель. Графически построить модель поведения правильно и неправильно функционирующей системы настолько близко к реальной модели системы, насколько это возможно, в целях обеспечения эффективной поддержки моделирования методом Монте-Карло.<br/><br/></p><p id="P01AC_2" class="formattext topleveltext indenttext" align="justify">Описание. Применяется асинхронный конечный автомат, описанный в В.2.3.3, за исключением того, что хорошее свойство, отслеживаемое при полуформальном подтверждении соответствия, не существует, когда моделируется поведение неправильно функционирующей системы безопасности. Так называемые позиции (изображаются кружочками) представляют возможные состояния, а так называемые переходы (изображаются прямоугольниками) представляют события, которые могут произойти. Кроме маркирования позиций (см. В.2.3.3) могут быть использованы сообщения или предикаты для подтверждения соответствия (активизации) переходов, а продолжительность задержки между активизацией перехода и его &quot;возбуждением&quot; может быть детерминированной или стохастической величиной. Поэтому такие сети Петри называются &quot;обобщенными стохастическими&quot; сетями Петри.<br/><br/></p><p><img class="base64 sign" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZIAAAARCAMAAADAD9oKAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MTg4Q0U3ODQ0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MTg4Q0U3ODU0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoxODhDRTc4MjRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDoxODhDRTc4MzRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pos3t18AAAAzUExURfX19SQkJOrq6oeHh7y8vD8/P9/f31RUVMjIyLCwsHh4eJaWlmdnZ6Ojo9TU1AAAAP////kimdMAAAWSSURBVHja7FiJcuQoDAVzGcz1/1+7TwLRuDs9mZ2karZqQ1ViGz90PUngVv1nfMOo9fg2WarnNkf9FGxMHdDkf1jo3bXBg7o0YhIkfrXV0npvBfd48y94HQtV97XWZvBPfbpG29oikGfQ6oeRs4WLb4K2CGNq5wsltpX6B5TQYEa5/u6h9rdn31QdtXS0iKX1WZ360/o9Pl/3NmVq/ahk/cfwZ0X+bSL6T01Kxmq6Fj0MSDNPj+atGzF1+Y17z9IZMRfulHiH+ivMFvE7nm2ffQ26Q5+U0AKLatWUGFm63kU3SJycuwqNLgNJ1ONf6crorUNyEySMStQLlegNgSuSmiT5agizm0YyZwPNbEXLM64y2X0YcGgdN3ytU9FaLDCecHbCyFWVh0kjMvBEHK+rvx/tVIgOWSoTcZrRa+aVJxeOuLc5nG8Oj2cjCzdKDm1Uj9BCSFeO7sKBgKCxRWpXKNAiFtV2njBAGeqm2QBQaZKCjjDCA+vqnZJD802sAzu9q4EwRtde4djUG4kJeFObpsag4cXNNJKJejRY7pVO9EJiQf2XRJLlBEcW1Toooc48FcniBeN2nOALwwzMDXhDJv2CkoKENkS/NKzu0p74rRyOk0vcezgs0iXQhLDixE4J6YAALgUqoEq6VKpih0KosOuUUihxM+eGo6KIA3DEaTI8oJS7UZIybnhmOVX1wCiqLJSYmnr52WjShadTA7Obtsyl2lP22PquxG9kJ1VbSWN2gEXRfF4wlnri36xnTJBYC+R7ShyX17HNDIcXJSg8ddMqDi/p0+HOCGNfKclwPmdHBsVgp9mbHaemuwBMwtvmCK2pQqtwdpakiZIQg7pTAitwc+m6OVWyWFhnzQy9aMrcDZASSAJjgNlMo5R4UIJ1xbhnSsYr+p/LRslS1FfshQFIpb4v06WRvgBky4VfseOmPqy3zaKiZqp/SEmpOqhdqzi8pE+H6/2wu1PiCg9AkvOvlJi0r2ZbS7FooaMpdo8WYy6ixPFRZKcEE9Iz115irhdKWC/y1VquyIpWqU+i5GEapcRWJaGFFN9T4s7foyRQdqmNkqHvGJmn82AtUzed1s9vB63U6jj6ulOCnnbtWsXhJX06/J6S5LbDmKYuy/W11rgbobKpdRvmtNFKGpfS142SqEcL8CE99hIKV+ZmbDnr/NQL2Slx46wxoDSB2U27NS77eN4oGZaj91G6PChZiubzgo2+i9AKJbEd/S5yKA5ZAnCwLL6IcfYe2aHWb1rF4SV9OjwQ9XylZGwwORFSIeLUakYnHEVAgh6U0D7elY49C1OZNrM09pIC8EaJtnyjdHiIqE4qiY+K2YleProNrUcLhk8Lm2k3SgrF/KVKhuUQVUzfKFmK5vOCvVBytMSb69NeolwS66954oXTvnF2en3b3XmlIo3LPXF4SReHXZ5b3zMlCKcpAVse9z38XXh2kvo9htvuppy+LqeP0LgvBo/IpIJ+b/kQrGUDaM4XPvlBR9IPVq3mlkDldKIJ5k0vnGyzNh2myYvdtJ0S3wLtJeZOybT8uEabQ3kPSkSRUDRhs3HpI2uhKwKZKC8elADStJcASJOg7IcrF9BZvVBCPVi0bg6LdHF4IOqNkvmNaVM2iMWBHqoKLD9TvghAE92ecjdXxkxveb8tHElMxB7PblETZ1G2zDe1eNbBMkVEGdsDl4k3d709uAk86RPY3k2b5lZOIzbxnN2c5xk+LM9jv8PZaIBFkSwWBw9CRWwlLJ3fVZPTuYkUyLT+KPP7VBGAQmGev5tHTGMUrbvDU/pyeNn1oOQLQ74d6yeA51Hyfnn6FWDtmF8bueyXvzx+5XB/3d6/4rbfL+8Bz8Ne++X+s4z5pp/QLrtf/vJ47/B3U/L9Q/Fp4P87fn7R/c+NfwQYAFx9eFOvgdoSAAAAAElFTkSuQmCC"/></p><style>.base64.sign {display: none;}</style><p id="P01AC_3" class="formattext topleveltext indenttext" align="justify">Сети Петри являются гибкими поведенческими моделями, которые подтверждают свою высокую эффективность для поддержки моделирования методом Монте-Карло (см. В.6.6.8). Кроме точности самого метода Монте-Карло, которая, так или иначе, всегда известна, все ограничения других методов (зависимости, комбинаторный взрыв, неэкспоненциальность законов распределения и т.д.) преодолеваются. Для современных компьютеров больше не являются проблемой даже оценки для УПБ 4.<br/><br/></p><p id="P01AC_4" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P01AC_5" class="formattext topleveltext indenttext" align="justify">IEC 62551:2012, Analysis techniques for dependability - Petri net modeling.<br/><br/></p><p id="P01AC_6" class="formattext topleveltext indenttext" align="justify"><img class="normal" src="https://api.docs.cntd.ru/img/12/00/10/32/42/135f542c-1dc5-4db8-9c2d-74263b12735c/P01AC0000.png" width="71" height="16"/> des architectures informatiques. Jean-Louis Boulanger, <img class="normal" src="https://api.docs.cntd.ru/img/12/00/10/32/42/135f542c-1dc5-4db8-9c2d-74263b12735c/P01AC0001.png" width="47" height="16"/> - Lavoisier, 2009, ISBN: 978-2-7462-1991-5.<br/><br/></p><p id="P01AE" class="formattext topleveltext indenttext" align="justify"><b>B.6.7 Анализ наихудшего случая</b><br/><br/></p><p id="P01AE_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (таблицы В.5 и В.6).<br/><br/><br/></p><p id="P01AE_2" class="formattext topleveltext indenttext" align="justify">Цель. Исключение систематических ошибок, возникающих в результате неблагоприятных сочетаний условий окружающей среды и допусков на параметры компонентов системы.<br/><br/></p><p id="P01AE_3" class="formattext topleveltext indenttext" align="justify">Описание. Эксплуатационные возможности системы и размеры компонентов исследуются или вычисляются теоретически. При этом для условий окружающей среды задаются их допустимые предельные значения. Анализируются и сопоставляются со спецификацией наиболее существенные характеристики системы.<br/><br/></p><p id="P01B0" class="formattext topleveltext indenttext" align="justify"><b>В.6.8 Расширенное функциональное тестирование</b><br/><br/></p><p id="P01B0_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (таблицы В.5 и В.6).<br/><br/><br/></p><p id="P01B0_2" class="formattext topleveltext indenttext" align="justify">Цель. Обнаружение отказов на стадиях спецификации, проектирования и разработки системы. Проверка поведения системы, связанной с безопасностью, в случае редких или неспецифицированных операций ввода информации.<br/><br/></p><p id="P01B0_3" class="formattext topleveltext indenttext" align="justify">Описание. Расширенное функциональное тестирование проверяет функциональное поведение системы, связанной с безопасностью, как реакцию на входные условия, которые ожидаются только в редких случаях (например глобального отказа) или не охватываются спецификацией системы, связанной с безопасностью (например некорректные операции). Для редко встречающихся условий наблюдаемое поведение системы, связанной с безопасностью, сравнивается со спецификацией. В тех случаях, когда реакция системы, связанной с безопасностью, не специфицирована, следует убедиться в том, что заданная безопасность сохранена в наблюдаемой реакции системы.<br/><br/></p><p id="P01B0_4" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P01B0_5" class="formattext topleveltext indenttext" align="justify">Functional Program Testing and Analysis. W.E. Howden, McGraw-Hill, 1987.<br/><br/></p><p id="P01B0_6" class="formattext topleveltext indenttext" align="justify">The Art of Software Testing. G.J. Myers, Wiley &amp; Sons, New York, 1979.<br/><br/></p><p id="P01B0_7" class="formattext topleveltext indenttext" align="justify">Dependability of Critical Computer Systems 3. P.G. Bishop et al., Elsevier Applied Science, 1990, ISBN 1-85166-544-7.<br/><br/></p><p id="P01B2" class="formattext topleveltext indenttext" align="justify"><b>В.6.9 Испытания в наихудших случаях</b><br/><br/></p><p id="P01B2_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (таблицы В.5 и В.6).<br/><br/><br/></p><p id="P01B2_2" class="formattext topleveltext indenttext" align="justify">Цель. Тестирование ситуаций, специфицированных во время анализа наихудших случаев.<br/><br/></p><p id="P01B2_3" class="formattext topleveltext indenttext" align="justify">Описание. Эксплуатационные возможности системы и размеры компонентов тестируются для наихудших случаев. При этом для условий окружающей среды задают их допустимые предельные значения. Анализируются и сопоставляются со спецификацией наиболее существенные характеристики системы.<br/><br/></p><p id="P01B4" class="formattext topleveltext indenttext" align="justify"><b>В.6.10 Испытания с введением неисправностей</b><br/><br/></p><p id="P01B4_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (таблицы В.5 и В.6).<br/><br/><br/></p><p id="P01B4_2" class="formattext topleveltext indenttext" align="justify">Цель. Внесение или имитация неисправностей в аппаратные средства системы и документирование реакции системы.<br/><br/></p><p id="P01B4_3" class="formattext topleveltext indenttext" align="justify">Описание. Представленный метод оценки зависимостей является качественным. Для описания местоположения и типа неисправностей, а также способа их внесения предпочтительно используются детализированные функциональные блоки, схемы и схемные диаграммы: например, питание может не поступать на различные модули; линии питания, линии общей шины или адресные линии могут быть разомкнуты/коротко замкнуты; компоненты или их порты могут быть разомкнуты или закорочены; реле могут быть замкнуты или разомкнуты, либо их действия могут выполняться в несоответствующие моменты времени и т.д. Возникающие в результате отказы системы классифицируются, например, таблицы 1 и 2 в [8]. Обычно вводятся одиночные неисправности в устойчивом состоянии системы. Однако в случае, если неисправность не обнаруживается тестом встроенной диагностики или оказывается неочевидной, она может сохраниться в системе и вызвать следующую неисправность. При этом количество неисправностей может быстро возрасти многократно.<br/><br/></p><p id="P01B4_4" class="formattext topleveltext indenttext" align="justify">Такие испытания проводятся многопрофильным коллективом специалистов. Поставщик системы должен при этом присутствовать и получать рекомендации. Для отказов, приводящих к опасным последствиям, вычисляют и оценивают среднее время наработки на отказ. Если это время мало, необходима модификация системы.<br/><br/></p><p id="P01B4_5" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P01B4_6" class="formattext topleveltext indenttext" align="justify">IEC 60812:2006, Analysis techniques for system reliability - Procedure for failure mode and effects analysis (FMEA).<br/><br/></p><p id="P01B4_7" class="formattext topleveltext indenttext" align="justify">IEC 61069-5:1994, Industrial-process measurement and control - Evaluation of system properties for the purpose of system assessment - Part 5: Assessment of system dependability.<br/></p><p id="P01B5" class="formattext topleveltext centertext" align="center"></p><h2 id="P01B8" class="formattext topleveltext centertext" align="center" title-level="2">Приложение С<br/>(справочное)<br/></h2><p id="P01B9" class="headertext topleveltext centertext" align="center">Анализ методов и средств достижения полноты безопасности программного обеспечения (см. МЭК 61508-3)</p><p id="P01BA" class="formattext topleveltext empty_line" align="justify"></p><h3 id="P01BD" class="formattext topleveltext indenttext" align="justify" title-level="3"><b>С.1 Общие положения</b><br/><br/></h3><p id="P01BD_1" class="formattext topleveltext indenttext" align="justify">Анализ методов, содержащийся в настоящем приложении, не следует рассматривать как полный или исчерпывающий.<br/><br/></p><h3 id="P01C0" class="formattext topleveltext indenttext" align="justify" title-level="3"><b>С.2 Требования и детальное проектирование</b><br/><br/></h3><p id="P01C0_1" class="formattext topleveltext indenttext" align="justify">Примечание - Соответствующие методы и средства приведены в В.2.<br/><br/></p><p id="P01C2" class="formattext topleveltext indenttext" align="justify"><b>С.2.1 Структурные методы</b><br/><br/></p><p id="P01C2_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблицы А.2 и А.4).<br/><br/></p><p id="P01C4" class="formattext topleveltext indenttext" align="justify">С.2.1.1 Общие положения<br/><br/></p><p id="P01C4_1" class="formattext topleveltext indenttext" align="justify">Цель. Основная цель методов анализа структуры (структурных методов) состоит в обеспечении качества разработки программного обеспечения. Данные методы в основном используются на ранних стадиях жизненного цикла создаваемой системы. Структурные методы используют как точные, так и интуитивные процедуры и нотации (поддерживаемые компьютерами), а также определяют и позволяют документально оформлять требования и возможности реализации в логической последовательности и структурированным способом.<br/><br/></p><p id="P01C4_2" class="formattext topleveltext indenttext" align="justify">Описание. Существует достаточно много структурных методов. Некоторые из них созданы для выполнения традиционных функций обработки данных и транзакций, другие в большей степени ориентированы на процессы управления и задачи реального времени (для систем, реализующих такие задачи, характеристика безопасности является более критичной, чем для других систем). UML (см. С.3.12) содержит много примеров структурированных нотаций.<br/><br/></p><p id="P01C4_3" class="formattext topleveltext indenttext" align="justify">Структурные методы можно считать &quot;интеллектуальными инструментами&quot;, предназначенными для обобщенного восприятия и структуризации конкретной проблемы или системы. К их основным свойствам относятся:<br/><br/></p><p id="P01C4_4" class="formattext topleveltext indenttext" align="justify">- использование логики в рассуждениях и выводах, декомпозиция сложной проблемы на управляемые стадии;<br/><br/></p><p id="P01C4_5" class="formattext topleveltext indenttext" align="justify">- анализ и документирование всей системы, включая окружающую среду, а также разрабатываемую систему;<br/><br/></p><p id="P01C4_6" class="formattext topleveltext indenttext" align="justify">- декомпозиция данных и функций в разрабатываемой системе;<br/><br/></p><p id="P01C4_7" class="formattext topleveltext indenttext" align="justify">- использование контрольных таблиц, то есть списков типов объектов, нуждающихся в анализе;<br/><br/></p><p id="P01C4_8" class="formattext topleveltext indenttext" align="justify">- малая интеллектуальная перегрузка - простота, интуитивность и практичность при представлении проблемы или системы;<br/><br/></p><p id="P01C4_9" class="formattext topleveltext indenttext" align="justify">- акцентирование на разработке структурной модели создаваемой системы с поддержкой CASE средств для полноты метода.<br/><br/></p><p id="P01C4_10" class="formattext topleveltext indenttext" align="justify">Нотации, используемые для анализа и документирования проблем и объектов системы (например на основе процессов и потоков данных), ориентированы на строгость, однако нотации для выражения функций обработки, выполняемых этими объектами, являются более неформальными. В то же время некоторые методы частично используют формальные нотации (например регулярные выражения или конечные состояния автоматов). Увеличение точности нотации не только повышает уровень понимания, но и обеспечивает возможность автоматизированной обработки.<br/><br/></p><p id="P01C4_11" class="formattext topleveltext indenttext" align="justify">Другим преимуществом структурных нотаций является их наглядность, которая позволяет пользователю интуитивно проверять возможности спецификации или проекта при неполной информации.<br/><br/></p><p id="P01C4_12" class="formattext topleveltext indenttext" align="justify">Данный краткий обзор описывает несколько структурных методов более подробно.<br/><br/></p><p id="P01C4_13" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P01C4_14" class="formattext topleveltext indenttext" align="justify">Software Engineering for Real-time Systems. J.E. Cooling, Pearson Education, 2003, ISBN 0201596202, 9780201596205.<br/><br/></p><p id="P01C4_15" class="formattext topleveltext indenttext" align="justify">Software Design. D. Budgen, Pearson Education, 2003, ISBN 0201722194, 9780201722192.<br/><br/></p><p id="P01C6" class="formattext topleveltext indenttext" align="justify">C.2.1.2 Управляемое представление требований (CORE)<br/><br/></p><p id="P01C6_1" class="formattext topleveltext indenttext" align="justify">Цель. Обеспечение требований, определений и формулировок.<br/><br/></p><p id="P01C6_2" class="formattext topleveltext indenttext" align="justify">Описание. Данный метод должен устранить пробел между потребителем/конечным пользователем и аналитиком. Он не основан на математически строгой теории, а является средством коммуникации. Метод CORE создан для представления требований, а не для спецификаций. Данный метод является структурированным, все его представления проходят через различные уровни уточнений. Метод CORE используется для широкого круга проблем, учитывает сведения об окружающей среде, в которой система функционирует, а также различные точки зрения разных типов пользователей. Метод CORE содержит руководящие материалы и тактические подходы для того, чтобы упростить сложный проект. Такое упрощение может быть скорректировано либо явным образом идентифицировано и документально оформлено. Таким образом, спецификации могут быть неполными, однако выявленные нерешенные проблемы и области высокого риска должны быть рассмотрены при последующем проектировании.<br/><br/></p><p id="P01C6_3" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P01C6_4" class="formattext topleveltext indenttext" align="justify">Software Engineering for Real-time Systems. J.E. Cooling, Pearson Education, 2003, ISBN 0201596202, 9780201596205.<br/><br/></p><p id="P01C6_5" class="formattext topleveltext indenttext" align="justify">Requirements Engineering. E. Hull, K. Jackson, J. Dick. Springer, 2005, ISBN 1852338792, 9781852338794.<br/><br/></p><p id="P01C8" class="formattext topleveltext indenttext" align="justify">C.2.1.3 Метод разработки системы по Джексону (JSD)<br/><br/></p><p id="P01C8_1" class="formattext topleveltext indenttext" align="justify">Цель. Разработка метода, охватывающего создание программных систем от стадии формирования требований до стадии кодирования, специально для систем реального времени.<br/><br/></p><p id="P01C8_2" class="formattext topleveltext indenttext" align="justify">Описание. Метод JSD представляет собой поэтапную процедуру разработки, в которой разработчик моделирует поведение реального мира, которое представляется функциями системы, определяет эти функции, вводит их в модель и преобразует образовавшуюся в результате спецификацию, которая реализуема в планируемой среде. Поэтому данный метод охватывает традиционные этапы, такие как создание спецификаций, проектирование и разработка, но несколько отличается от традиционных методов и не является методом нисходящего проектирования.<br/><br/></p><p id="P01C8_3" class="formattext topleveltext indenttext" align="justify">Данный метод уделяет большое внимание выявлению на ранней стадии сущностей реального мира, относящихся к создаваемой системе, а также моделированию этих сущностей и того, что может с ними произойти. Как только анализ &quot;реального мира&quot; будет выполнен и создана его модель, анализируются функции системы с тем, чтобы определить, как они вписываются в модель &quot;реального мира&quot;. Модель результирующей системы дополняется структурным описанием всех процессов модели и затем преобразуется в программы, которые могут работать в заданной программно-аппаратной среде.<br/><br/></p><p id="P01C8_4" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P01C8_5" class="formattext topleveltext indenttext" align="justify">Systems Analysis and Design. D. Yeates, A. Wakefield. Pearson Education, 2003, ISBN 0273655361, 9780273655367.<br/><br/></p><p id="P01C8_6" class="formattext topleveltext indenttext" align="justify">An Overview JSD. J.R. Cameron. IEEE Transactions on Software Engineering, SE-12, No. 2, February 1986.<br/><br/></p><p id="P01CA" class="formattext topleveltext indenttext" align="justify">C.2.1.4 Метод Йордона (Yourdon) для систем реального времени<br/><br/></p><p id="P01CA_1" class="formattext topleveltext indenttext" align="justify">Цель. Спецификация и проектирование систем реального времени.<br/><br/></p><p id="P01CA_2" class="formattext topleveltext indenttext" align="justify">Описание. Данный метод реализует процесс разработки системы, состоящий из трех этапов. На первом этапе происходит создание &quot;сущностной модели&quot;, которая описывает поведение системы в целом. На втором этапе строится модель реализации, описывающая структуру и механизмы, которые, будучи реализованными, отражают требуемое поведение системы. На третьем этапе происходит фактическое построение аппаратных и программных средств системы. Три этапа строго соответствуют традиционным спецификации, проектированию и разработке, но главное, что разработчик на каждом этапе должен активно заниматься моделированием.<br/><br/></p><p id="P01CA_3" class="formattext topleveltext indenttext" align="justify">Сущностная модель состоит из двух частей:<br/><br/></p><p id="P01CA_4" class="formattext topleveltext indenttext" align="justify">- модели окружающей среды, содержащей описание границ между системой и ее окружением, а также внешних событий, на которые должна реагировать система;<br/><br/></p><p id="P01CA_5" class="formattext topleveltext indenttext" align="justify">- модели поведения, которая содержит схемы, описывающие преобразования, выполняемые системой в ответ на события, и описание данных, которые система должна содержать для выдачи ответов.<br/><br/></p><p id="P01CA_6" class="formattext topleveltext indenttext" align="justify">Модель реализации подразделяется на две подмодели, описывающие распределение отдельных процессов в процессорах и декомпозицию процессов на программные модули.<br/><br/></p><p id="P01CA_7" class="formattext topleveltext indenttext" align="justify">Для создания сущностной модели и модели реализации данный метод использует множество хорошо известных подходов: построение диаграмм потоков данных, преобразование графов, структурированный английский язык, диаграммы переходов состояний и сети Петри. Кроме того, данный метод содержит методики для моделирования представленного из уже сформированных моделей проекта системы или вручную (на бумаге) или автоматически.<br/><br/></p><p id="P01CA_8" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P01CA_9" class="formattext topleveltext indenttext" align="justify">Real-time Systems Development. R. Williams. Butterworth-Heinemann, 2006, ISBN 0750664711, 9780750664714.<br/><br/></p><p id="P01CA_10" class="formattext topleveltext indenttext" align="justify">Structured Development for Real-Time Systems (3 Volumes). P.T. Ward and S.J. Mellor. Yourdon Press, 1985.<br/><br/></p><p id="P01CC" class="formattext topleveltext indenttext" align="justify"><b>C.2.2 Диаграммы потоков данных</b><br/><br/></p><p id="P01CC_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблицы В.5 и В.7).<br/><br/><br/></p><p id="P01CC_2" class="formattext topleveltext indenttext" align="justify">Цель. Программная поддержка описания потока данных в виде диаграмм.<br/><br/></p><p id="P01CC_3" class="formattext topleveltext indenttext" align="justify">Описание. Диаграммы потоков данных описывают преобразование входных данных в выходные для каждого компонента схемы, представляющего различные преобразования.<br/><br/></p><p id="P01CC_4" class="formattext topleveltext indenttext" align="justify">Диаграммы потоков данных состоят из трех компонентов:<br/><br/></p><p id="P01CC_5" class="formattext topleveltext indenttext" align="justify">- аннотированные стрелки - обозначают поток данных, входящих и исходящих из блоков преобразования, с кратким описанием этих данных;<br/><br/></p><p id="P01CC_6" class="formattext topleveltext indenttext" align="justify">- аннотированные кружки - обозначают блоки преобразования с кратким описанием преобразований;<br/><br/></p><p id="P01CC_7" class="formattext topleveltext indenttext" align="justify">- операторы (and, хоr) - эти операторы используются для связи аннотированных стрелок.<br/><br/></p><p><img class="base64 sign" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZIAAAARCAMAAADAD9oKAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MTg4Q0U3ODQ0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MTg4Q0U3ODU0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoxODhDRTc4MjRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDoxODhDRTc4MzRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pos3t18AAAAzUExURfX19SQkJOrq6oeHh7y8vD8/P9/f31RUVMjIyLCwsHh4eJaWlmdnZ6Ojo9TU1AAAAP////kimdMAAAWSSURBVHja7FiJcuQoDAVzGcz1/1+7TwLRuDs9mZ2karZqQ1ViGz90PUngVv1nfMOo9fg2WarnNkf9FGxMHdDkf1jo3bXBg7o0YhIkfrXV0npvBfd48y94HQtV97XWZvBPfbpG29oikGfQ6oeRs4WLb4K2CGNq5wsltpX6B5TQYEa5/u6h9rdn31QdtXS0iKX1WZ360/o9Pl/3NmVq/ahk/cfwZ0X+bSL6T01Kxmq6Fj0MSDNPj+atGzF1+Y17z9IZMRfulHiH+ivMFvE7nm2ffQ26Q5+U0AKLatWUGFm63kU3SJycuwqNLgNJ1ONf6crorUNyEySMStQLlegNgSuSmiT5agizm0YyZwPNbEXLM64y2X0YcGgdN3ytU9FaLDCecHbCyFWVh0kjMvBEHK+rvx/tVIgOWSoTcZrRa+aVJxeOuLc5nG8Oj2cjCzdKDm1Uj9BCSFeO7sKBgKCxRWpXKNAiFtV2njBAGeqm2QBQaZKCjjDCA+vqnZJD802sAzu9q4EwRtde4djUG4kJeFObpsag4cXNNJKJejRY7pVO9EJiQf2XRJLlBEcW1Toooc48FcniBeN2nOALwwzMDXhDJv2CkoKENkS/NKzu0p74rRyOk0vcezgs0iXQhLDixE4J6YAALgUqoEq6VKpih0KosOuUUihxM+eGo6KIA3DEaTI8oJS7UZIybnhmOVX1wCiqLJSYmnr52WjShadTA7Obtsyl2lP22PquxG9kJ1VbSWN2gEXRfF4wlnri36xnTJBYC+R7ShyX17HNDIcXJSg8ddMqDi/p0+HOCGNfKclwPmdHBsVgp9mbHaemuwBMwtvmCK2pQqtwdpakiZIQg7pTAitwc+m6OVWyWFhnzQy9aMrcDZASSAJjgNlMo5R4UIJ1xbhnSsYr+p/LRslS1FfshQFIpb4v06WRvgBky4VfseOmPqy3zaKiZqp/SEmpOqhdqzi8pE+H6/2wu1PiCg9AkvOvlJi0r2ZbS7FooaMpdo8WYy6ixPFRZKcEE9Iz115irhdKWC/y1VquyIpWqU+i5GEapcRWJaGFFN9T4s7foyRQdqmNkqHvGJmn82AtUzed1s9vB63U6jj6ulOCnnbtWsXhJX06/J6S5LbDmKYuy/W11rgbobKpdRvmtNFKGpfS142SqEcL8CE99hIKV+ZmbDnr/NQL2Slx46wxoDSB2U27NS77eN4oGZaj91G6PChZiubzgo2+i9AKJbEd/S5yKA5ZAnCwLL6IcfYe2aHWb1rF4SV9OjwQ9XylZGwwORFSIeLUakYnHEVAgh6U0D7elY49C1OZNrM09pIC8EaJtnyjdHiIqE4qiY+K2YleProNrUcLhk8Lm2k3SgrF/KVKhuUQVUzfKFmK5vOCvVBytMSb69NeolwS66954oXTvnF2en3b3XmlIo3LPXF4SReHXZ5b3zMlCKcpAVse9z38XXh2kvo9htvuppy+LqeP0LgvBo/IpIJ+b/kQrGUDaM4XPvlBR9IPVq3mlkDldKIJ5k0vnGyzNh2myYvdtJ0S3wLtJeZOybT8uEabQ3kPSkSRUDRhs3HpI2uhKwKZKC8elADStJcASJOg7IcrF9BZvVBCPVi0bg6LdHF4IOqNkvmNaVM2iMWBHqoKLD9TvghAE92ecjdXxkxveb8tHElMxB7PblETZ1G2zDe1eNbBMkVEGdsDl4k3d709uAk86RPY3k2b5lZOIzbxnN2c5xk+LM9jv8PZaIBFkSwWBw9CRWwlLJ3fVZPTuYkUyLT+KPP7VBGAQmGev5tHTGMUrbvDU/pyeNn1oOQLQ74d6yeA51Hyfnn6FWDtmF8bueyXvzx+5XB/3d6/4rbfL+8Bz8Ne++X+s4z5pp/QLrtf/vJ47/B3U/L9Q/Fp4P87fn7R/c+NfwQYAFx9eFOvgdoSAAAAAElFTkSuQmCC"/></p><style>.base64.sign {display: none;}</style><p id="P01CC_8" class="formattext topleveltext indenttext" align="justify">Каждый аннотированный кружок на диаграмме потока данных может рассматриваться как самостоятельный блок, который при появлении на его входах данных преобразует их в выходные. Одним из основных преимуществ является то, что они показывают преобразования, не предполагая, как они реализуются. Чистая диаграмма потоков данных не включает в себя управляющую информацию или информацию о последовательности процесса, так как управление реализуется в расширениях для реального времени, как в методе Йордона для систем реального времени (см. С.2.1.4).<br/><br/></p><p id="P01CC_9" class="formattext topleveltext indenttext" align="justify">Создание диаграмм потока данных является наилучшим подходом при анализе систем в направлении от входов к выходам. Каждый кружок на диаграмме должен обозначать разное преобразование - его выходы должны отличаться от его входов. Не существует правил определения общей структуры диаграммы, и создание диаграммы потока данных является одним из творческих аспектов создания проекта системы в целом. Подобно всем проектам, процедура, уточняющая начальную диаграмму для создания конечной, является итеративной.<br/><br/></p><p id="P01CC_10" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P01CC_11" class="formattext topleveltext indenttext" align="justify">Software Engineering: Update. Ian Sommerville, Addison-Wesley Longman, Amsterdam; 8<img class="base64" src="data:image;base64,R0lGODdhDwAXAIABAAAAAP///ywAAAAADwAXAAACJIyPqcvtHwBw01R2r5J1apR5S2aNR2eW0ehJ0QfF8kzX9o0fBQA7" width="15" height="23"/> ed., 2006, ISBN 0321313798, 9780321313799.<br/><br/></p><p id="P01CC_12" class="formattext topleveltext indenttext" align="justify">Software Engineering. Ian Sommerville, Pearson Studium, 8. Auflage, 2007, ISBN 3827372577, 9783827372574.<br/><br/></p><p id="P01CC_13" class="formattext topleveltext indenttext" align="justify">ISO 5807:1985, Information processing - Documentation symbols and conventions for data, program and system flowcharts, program network charts and system resources charts.<br/><br/></p><p id="P01CC_14" class="formattext topleveltext indenttext" align="justify">ISO/IEC 8631:1989, Information technology - Program constructs and conventions for their representation.<br/><br/></p><p id="P01CE" class="formattext topleveltext indenttext" align="justify"><b>C.2.3 Структурные диаграммы</b><br/><br/></p><p id="P01CE_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблица В.5).<br/><br/><br/></p><p id="P01CE_2" class="formattext topleveltext indenttext" align="justify">Цель. Представление структуры программы в виде схемы.<br/><br/></p><p id="P01CE_3" class="formattext topleveltext indenttext" align="justify">Описание. Структурные диаграммы дополняют диаграммы потоков данных. Они описывают программируемую систему и иерархию ее компонентов, а также отображают их графически в виде дерева. Структурные диаграммы описывают способ реализации элементов диаграммы потоков данных в виде иерархии программных модулей.<br/><br/></p><p id="P01CE_4" class="formattext topleveltext indenttext" align="justify">Структурная диаграмма показывает взаимоотношения между программными модулями, не указывая при этом порядок активизации программных модулей. Структурные диаграммы изображаются с использованием следующих четырех символов:<br/><br/></p><p id="P01CE_5" class="formattext topleveltext indenttext" align="justify">- прямоугольника с именем модуля;<br/><br/></p><p id="P01CE_6" class="formattext topleveltext indenttext" align="justify">- линии, соединяющей эти прямоугольники, формирующие структуру;<br/><br/></p><p id="P01CE_7" class="formattext topleveltext indenttext" align="justify">- стрелки, отмеченной незаштрихованным кругом, с именем данных, передаваемых в направлении элементов структурной диаграммы и обратно (обычно такая стрелка изображается параллельно линиям, соединяющим прямоугольники схемы);<br/><br/></p><p id="P01CE_8" class="formattext topleveltext indenttext" align="justify">- стрелки, отмеченной заштрихованным кругом, с именем сигнала управления, проходящего в структурной диаграмме от одного модуля к другому, и эта стрелка также изображается параллельно линии, соединяющей два модуля.<br/><br/></p><p id="P01CE_9" class="formattext topleveltext indenttext" align="justify">Из любой нетривиальной диаграммы потока данных можно создать множество различных структурных диаграмм.<br/><br/></p><p id="P01CE_10" class="formattext topleveltext indenttext" align="justify">Диаграммы потоков данных отображают взаимоотношение между информацией и функциями системы. Структурные диаграммы отображают способ реализации элементов системы. Оба метода представляют собой обоснованные, хотя и различные точки зрения на конкретную систему.<br/><br/></p><p id="P01CE_11" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P01CE_12" class="formattext topleveltext indenttext" align="justify">Software Design &amp; Development. G. Lancaster. Pascal Press, 2001, ISBN 1741251753, 9781741251753.<br/><br/></p><p id="P01CE_13" class="formattext topleveltext indenttext" align="justify">Software engineering: Update. Ian Sommerville, Addison-Wesley Longman, Amsterdam; 8<img class="base64" src="data:image;base64,R0lGODdhDwAXAIABAAAAAP///ywAAAAADwAXAAACJIyPqcvtHwBw01R2r5J1apR5S2aNR2eW0ehJ0QfF8kzX9o0fBQA7" width="15" height="23"/> ed., 2006, ISBN 0321313798, 9780321313799.<br/><br/></p><p id="P01CE_14" class="formattext topleveltext indenttext" align="justify">Software Engineering. Ian Sommerville, Pearson Studium, 8. Auflage, 2007, ISBN 3827372577, 9783827372574.<br/><br/></p><p id="P01D0" class="formattext topleveltext indenttext" align="justify"><b>C.2.4 Формальные методы</b><br/><br/></p><p id="P01D0_1" class="formattext topleveltext indenttext" align="justify">Примечаниe - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблицы A.1, A.2, A.4 и В.5).<br/><br/></p><p id="P01D2" class="formattext topleveltext indenttext" align="justify">С.2.4.1 Общие положения<br/><br/></p><p id="P01D2_1" class="formattext topleveltext indenttext" align="justify">Цель. Разработка программных средств, основанных на математических принципах. К этим средствам относятся методы формального проектирования и формального кодирования.<br/><br/></p><p id="P01D2_2" class="formattext topleveltext indenttext" align="justify">Описание. На основе формальных методов разработаны средства описания системы для решения отдельных задач на этапах спецификации, проектирования или реализации. Создаваемое в результате описание представляет собой строгую нотацию, математически анализируемую для обнаружения различных видов несогласованностей или некорректностей. Более того, такое описание может быть в некоторых случаях проанализировано автоматически по аналогии с проверкой компилятором синтаксиса исходной программы или использована анимация в целях показать различные аспекты поведения описываемой системы. Анимация может дать дополнительную уверенность в том, что система соответствует как реальным, так и формально специфицированным требованиям, поскольку это улучшает восприятие человеком специфицированного поведения системы.<br/><br/></p><p id="P01D2_3" class="formattext topleveltext indenttext" align="justify">Формальный метод обычно предлагает нотацию (как правило, используется один из методов дискретной математики), метод вывода описания в данной нотации и различные методы анализа описания для проверки корректности различных свойств системы.<br/><br/></p><p id="P01D2_4" class="formattext topleveltext indenttext" align="justify">Ряд формальных методов CCS, CSP, HOL, LOTOS, OBJ, временная логика, VDM и Z описан в подпунктах настоящего пункта. Следует заметить, что другие методы, например, метод конечных автоматов и сети Петри (см. приложение В), в зависимости от корректности использования методами соответствующего строгого математического аппарата, могут рассматриваться как формальные.<br/><br/></p><p id="P01D2_5" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P01D2_6" class="formattext topleveltext indenttext" align="justify">Formal Specification: Techniques and Applications. N. Nissanke, Springer-Verlag Telos, 1999, ISBN-10:1852330023.<br/><br/></p><p id="P01D2_7" class="formattext topleveltext indenttext" align="justify">The Practice of Formal Methods in Safety-Critical Systems. S. Liu, V. Stavridou, B. Dutertre, J. Systems. Software 28, 77-87, Elsevier, 1995.<br/><br/></p><p id="P01D2_8" class="formattext topleveltext indenttext" align="justify">Formal Methods: Use and Relevance for Development of Safety-Critical Systems. L.M. Barroca, J.A. McDermid, The Computer Journal 35 (6), 579-599, 1992.<br/><br/></p><p id="P01D2_9" class="formattext topleveltext indenttext" align="justify">How to Produce Correct Software - An Introduction to Formal Specification and Program Development by Transformations. E.A. Boiten et al., The Computer Journal 35 (6), 547-554, 1992.<br/><br/></p><p id="P01D4" class="formattext topleveltext indenttext" align="justify">C.2.4.2 CCS - расчет взаимодействующих систем<br/><br/></p><p id="P01D4_1" class="formattext topleveltext indenttext" align="justify">Цель. Описание и анализ поведения систем, реализующих параллельные коммуникационные процессы.<br/><br/></p><p id="P01D4_2" class="formattext topleveltext indenttext" align="justify">Описание. CCS - это математический аппарат, описывающий поведение систем. Проект системы моделируется в виде сети независимых процессов, реализующихся последовательно или параллельно. Процессы могут взаимодействовать через порты (аналогичные каналам CSP), и взаимодействие осуществляется только при готовности обоих процессов. Может быть смоделировано отсутствие детерминизма. Начиная с описания всей системы на высоком уровне абстрагирования (трассирование), можно выполнять пошаговое уточнение системы (стратегия сверху вниз) в рамках композиции взаимодействующих процессов, общее поведение которых формирует также поведение всей системы. В равной степени можно выполнять и стратегию снизу вверх, комбинируя процессы и получая в результате необходимые свойства формируемой системы, используя правила вывода композиционного типа.<br/><br/></p><p id="P01D4_3" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P01D4_4" class="formattext topleveltext indenttext" align="justify">Communication and Concurrency. R. Milner, Prentice-Hall, 1989, ISBN 9780131150072.<br/><br/></p><p id="P01D6" class="formattext topleveltext indenttext" align="justify">C.2.4.3 CSP - взаимодействующие последовательные процессы<br/><br/></p><p id="P01D6_1" class="formattext topleveltext indenttext" align="justify">Цель. Спецификация конкурирующих программных систем, то есть систем, процессы которых реализуются одновременно.<br/><br/></p><p id="P01D6_2" class="formattext topleveltext indenttext" align="justify">Описание. Метод CSP обеспечивает язык для спецификаций процессов системы и подтверждения соответствия реализации процессов их спецификациям (описанным как трасса, то есть допустимая последовательность событий).<br/><br/></p><p id="P01D6_3" class="formattext topleveltext indenttext" align="justify">Система моделируется в виде сети независимых процессов, составленных последовательно или параллельно. Каждый независимый процесс описывается в терминах всех его возможных поведений. Независимые процессы могут взаимодействовать (синхронно или обмениваться данными) через каналы, и взаимодействие происходит только при готовности обоих процессов. Может быть промоделирована относительная синхронизация событий.<br/><br/></p><p id="P01D6_4" class="formattext topleveltext indenttext" align="justify">Теоретические положения метода CSP были непосредственно включены в архитектуру транспьютера INMOS, а язык OCCAM позволил непосредственно реализовывать на сетях транспьютеров системы, специфицированные в языке CSP.<br/><br/></p><p id="P01D6_5" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P01D6_6" class="formattext topleveltext indenttext" align="justify">Communicating Sequential Processes: The First 25 Years. A. Abdallah, С. Jones, J. Sanders (Eds.). Springer, 2004, ISBN 3540258132, 9783540258131.<br/><br/></p><p id="P01D8" class="formattext topleveltext indenttext" align="justify">C.2.4.4 HOL - логика высшего порядка<br/><br/></p><p id="P01D8_1" class="formattext topleveltext indenttext" align="justify">Цель. Спецификация и верификация аппаратных средств.<br/><br/></p><p id="P01D8_2" class="formattext topleveltext indenttext" align="justify">Описание. HOL представляет собой разработанную в компьютерной лаборатории Кембриджского университета конкретную логическую нотацию и систему, которая ее автоматически поддерживает. Логическая нотация взята в основном из простой теории типов Черча, а машинная реализация основана на теории LCF (логике вычислимых функций).<br/><br/></p><p id="P01D8_3" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P01D8_4" class="formattext topleveltext indenttext" align="justify">Higher-Order Computational Logic. J. Lloyd. In Computational Logic: Logic Programming and Beyond, Lecture Notes in Computer Science, Springer Berlin/Heidelberg, 2002, ISBN 978-3-540-43959-2.<br/><br/></p><p id="P01DA" class="formattext topleveltext indenttext" align="justify"><b>C.2.4.5 LOTOS</b><br/><br/></p><p id="P01DA_1" class="formattext topleveltext indenttext" align="justify">Цель. Описание и анализ поведения систем, реализующих параллельные коммуникационные процессы.<br/><br/></p><p id="P01DA_2" class="formattext topleveltext indenttext" align="justify">Описание. LOTOS (язык для спецификации процессов, упорядоченных во времени) основан на CCS с дополнительными возможностями из близких алгебраических теорий CSP и CIRCAL (теория цепей). LOTOS преодолевает недостатки CCS в управлении структурами данных и представлении значений выражений, объединяя его с аспектами языка абстрактных типов данных ACT ONE. Процесс описания аспектов в LOTOS может быть однако использован для других формальных методов при описании абстрактных типов данных.<br/><br/></p><p id="P01DA_3" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P01DA_4" class="formattext topleveltext indenttext" align="justify">Model Checking for Software Architectures. R. Mateescu. In Software Architecture, Lecture Notes in Computer Science, Springer Berlin/Heidelberg, 2004, ISBN 978-3-540-22000-8.<br/><br/></p><p id="P01DA_5" class="formattext topleveltext indenttext" align="justify">ISO 8807:1989, Information processing systems - Open Systems Interconnection - LOTOS - A formal description technique based on the temporal ordering of observational behavior.<br/><br/></p><p id="P01DC" class="formattext topleveltext indenttext" align="justify">C.2.4.6 OBJ<br/><br/></p><p id="P01DC_1" class="formattext topleveltext indenttext" align="justify">Цель. Обеспечение точной спецификации системы в процессе диалога с пользователем и подтверждение соответствия системы до ее реализации.<br/><br/></p><p id="P01DC_2" class="formattext topleveltext indenttext" align="justify">Описание. OBJ представляет собой алгебраический язык спецификаций. Пользователи определяют требования в терминах алгебраических выражений. Системные аспекты (поведение или конструктивы) специфицируются в терминах операций, действующих над абстрактными типами данных (ADT). ADT подобен языку ADA, где поведение оператора наблюдаемо, однако подробности реализации скрыты.<br/><br/></p><p id="P01DC_3" class="formattext topleveltext indenttext" align="justify">Спецификация OBJ и последующая пошаговая реализация подвергаются тем же формальным методам проверки, что и другие формальные методы. Более того, поскольку конструктивные аспекты спецификации OBJ автоматически исполнимы, существует непосредственная возможность подтверждения соответствия системы на основе самой спецификации. Исполнение - это по существу оценка функций системы путем подстановки выражений (перезаписыванием), которая продолжается до тех пор, пока не будут получены конкретные выходные значения. Эта исполнимость позволяет конечным пользователям рассматриваемой системы получать &quot;облик&quot; планируемой системы на этапе ее спецификации без необходимости знакомства с методами, лежащими в основе формальных спецификаций.<br/><br/></p><p id="P01DC_4" class="formattext topleveltext indenttext" align="justify">Как и все другие методы ADT, метод OBJ применим только к последовательным системам или к последовательным аспектам параллельных систем. Метод OBJ применяют для спецификации как малых, так и крупных промышленных применений.<br/><br/></p><p id="P01DC_5" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P01DC_6" class="formattext topleveltext indenttext" align="justify">Software Engineering with OBJ: Algebraic Specification in Action. J. Goguen, G. Malcolm. Springer, 2000, ISBN 0792377575, 9780792377573.<br/><br/></p><p id="P01DE" class="formattext topleveltext indenttext" align="justify">C.2.4.7 <img class="normal" src="https://api.docs.cntd.ru/img/12/00/10/32/42/135f542c-1dc5-4db8-9c2d-74263b12735c/P01DE0000.png" width="72" height="20"/> логика<br/><br/></p><p id="P01DE_1" class="formattext topleveltext indenttext" align="justify">Цель. Непосредственное выражение требований к безопасности и эксплуатации, а также формальное представление сохранения этих качеств на последующих этапах разработки.<br/><br/></p><p id="P01DE_2" class="formattext topleveltext indenttext" align="justify">Описание. Стандартная предикатная логика первого порядка не содержит концепций времени. Временная логика расширяет логику первого порядка добавлением модальных операторов (например &quot;с этого момента&quot; и &quot;случайно&quot;). Эти операторы могут использоваться для уточнения суждений о системе. Например, свойства безопасности могут потребовать использовать модальный оператор &quot;с этого момента&quot;, но может потребоваться, чтобы и другие необходимые состояния системы были достигнуты &quot;случайно&quot; из некоторого другого начального состояния. Временные формулы интерпретируются последовательностями состояний (поведениями). Представление состояния зависит от выбранного уровня описания. Оно может относиться ко всей системе, системным элементам или компьютерной программе.<br/><br/></p><p id="P01DE_3" class="formattext topleveltext indenttext" align="justify">Квантифицированные временные интервалы и ограничения во временной логике явно не обрабатываются. Абсолютное время обрабатывается путем образования дополнительных временных состояний, что является частью описания состояния.<br/><br/></p><p id="P01DE_4" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P01DE_5" class="formattext topleveltext indenttext" align="justify">Mathematical Logic for Computer Science. M. Ben-Ari. Springer, 2001, ISBN 1852333197, 9781852333195.<br/><br/></p><p id="P01E0" class="formattext topleveltext indenttext" align="justify">C.2.4.8 VDM, VDM++ - метод разработки Vienna<br/><br/></p><p id="P01E0_1" class="formattext topleveltext indenttext" align="justify">Цель. Систематическая спецификация и реализация последовательных (VDM) и параллельных (VDM++) программ реального времени.<br/><br/></p><p id="P01E0_2" class="formattext topleveltext indenttext" align="justify">Описание. VDM - это математический метод спецификации и уточнения реализаций, который позволяет доказать их корректность относительно спецификации.<br/><br/></p><p id="P01E0_3" class="formattext topleveltext indenttext" align="justify">В этом основанном на модели методе спецификации состояние системы моделируется в терминах теоретико-множественных структур, в которых описаны инварианты (предикаты), а операции над этим состоянием моделируются путем определения их пред- и постусловий в терминах системных состояний. Операции могут проверяться на сохранение системных инвариантов.<br/><br/></p><p id="P01E0_4" class="formattext topleveltext indenttext" align="justify">Выполнение спецификаций осуществляется путем реализации состояния системы в терминах структур данных в заданном языке и уточнения операций в терминах программы на заданном языке. Этапы реализации и уточнения позволяют логически вывести свойства, устанавливающие корректность этих этапов. Выполняются или нет эти свойства, определяет разработчик.<br/><br/></p><p id="P01E0_5" class="formattext topleveltext indenttext" align="justify">В принципе VDM используется на этапе создания спецификации, но может также использоваться на этапах проектирования и реализации исходного кода. VDM может быть также применен к последовательно структурированным программам или к последовательным процессам в параллельных системах.<br/><br/></p><p id="P01E0_6" class="formattext topleveltext indenttext" align="justify">Объектно-ориентированное и параллельное для реального времени расширения VDM, VDM++ представляют собой язык формализованных спецификаций, основанный на языке VDM-SL, созданном в ИСО, и на объектно-ориентированном языке Smalltalk.<br/><br/></p><p id="P01E0_7" class="formattext topleveltext indenttext" align="justify">VDM++ имеет широкий диапазон конструкций, что позволяет пользователю формально специфицировать параллельные системы реального времени в объектно-ориентированной среде. В VDM++ полная формальная спецификация содержит совокупность спецификаций классов и отдельных характеристик рабочего пространства.<br/><br/></p><p id="P01E0_8" class="formattext topleveltext indenttext" align="justify">К средствам описания реального времени на языке VDM++ относятся:<br/><br/></p><p id="P01E0_9" class="formattext topleveltext indenttext" align="justify">- временные выражения, предусмотренные для представления как текущего момента, так и момента вызова метода внутри тела метода;<br/><br/></p><p id="P01E0_10" class="formattext topleveltext indenttext" align="justify">- выражение, описывающее синхронизирующий сигнал, которое может быть добавлено к методу для спецификации верхних (или нижних) пределов времени исполнения для корректности реализаций;<br/><br/></p><p id="P01E0_11" class="formattext topleveltext indenttext" align="justify">- переменные непрерывного времени, которые должны быть введены. С условными операторами и операторами действия допускается специфицировать отношения (например дифференциальные уравнения) между этими временными функциями, что оказалось очень полезно при спецификации требований к системам, действующим в среде с непрерывным временем. Уточняющие шаги приводят к дискретным программным решениям для программ реального времени.<br/><br/></p><p><img class="base64 sign" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZIAAAARCAMAAADAD9oKAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MTg4Q0U3ODQ0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MTg4Q0U3ODU0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoxODhDRTc4MjRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDoxODhDRTc4MzRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pos3t18AAAAzUExURfX19SQkJOrq6oeHh7y8vD8/P9/f31RUVMjIyLCwsHh4eJaWlmdnZ6Ojo9TU1AAAAP////kimdMAAAWSSURBVHja7FiJcuQoDAVzGcz1/1+7TwLRuDs9mZ2karZqQ1ViGz90PUngVv1nfMOo9fg2WarnNkf9FGxMHdDkf1jo3bXBg7o0YhIkfrXV0npvBfd48y94HQtV97XWZvBPfbpG29oikGfQ6oeRs4WLb4K2CGNq5wsltpX6B5TQYEa5/u6h9rdn31QdtXS0iKX1WZ360/o9Pl/3NmVq/ahk/cfwZ0X+bSL6T01Kxmq6Fj0MSDNPj+atGzF1+Y17z9IZMRfulHiH+ivMFvE7nm2ffQ26Q5+U0AKLatWUGFm63kU3SJycuwqNLgNJ1ONf6crorUNyEySMStQLlegNgSuSmiT5agizm0YyZwPNbEXLM64y2X0YcGgdN3ytU9FaLDCecHbCyFWVh0kjMvBEHK+rvx/tVIgOWSoTcZrRa+aVJxeOuLc5nG8Oj2cjCzdKDm1Uj9BCSFeO7sKBgKCxRWpXKNAiFtV2njBAGeqm2QBQaZKCjjDCA+vqnZJD802sAzu9q4EwRtde4djUG4kJeFObpsag4cXNNJKJejRY7pVO9EJiQf2XRJLlBEcW1Toooc48FcniBeN2nOALwwzMDXhDJv2CkoKENkS/NKzu0p74rRyOk0vcezgs0iXQhLDixE4J6YAALgUqoEq6VKpih0KosOuUUihxM+eGo6KIA3DEaTI8oJS7UZIybnhmOVX1wCiqLJSYmnr52WjShadTA7Obtsyl2lP22PquxG9kJ1VbSWN2gEXRfF4wlnri36xnTJBYC+R7ShyX17HNDIcXJSg8ddMqDi/p0+HOCGNfKclwPmdHBsVgp9mbHaemuwBMwtvmCK2pQqtwdpakiZIQg7pTAitwc+m6OVWyWFhnzQy9aMrcDZASSAJjgNlMo5R4UIJ1xbhnSsYr+p/LRslS1FfshQFIpb4v06WRvgBky4VfseOmPqy3zaKiZqp/SEmpOqhdqzi8pE+H6/2wu1PiCg9AkvOvlJi0r2ZbS7FooaMpdo8WYy6ixPFRZKcEE9Iz115irhdKWC/y1VquyIpWqU+i5GEapcRWJaGFFN9T4s7foyRQdqmNkqHvGJmn82AtUzed1s9vB63U6jj6ulOCnnbtWsXhJX06/J6S5LbDmKYuy/W11rgbobKpdRvmtNFKGpfS142SqEcL8CE99hIKV+ZmbDnr/NQL2Slx46wxoDSB2U27NS77eN4oGZaj91G6PChZiubzgo2+i9AKJbEd/S5yKA5ZAnCwLL6IcfYe2aHWb1rF4SV9OjwQ9XylZGwwORFSIeLUakYnHEVAgh6U0D7elY49C1OZNrM09pIC8EaJtnyjdHiIqE4qiY+K2YleProNrUcLhk8Lm2k3SgrF/KVKhuUQVUzfKFmK5vOCvVBytMSb69NeolwS66954oXTvnF2en3b3XmlIo3LPXF4SReHXZ5b3zMlCKcpAVse9z38XXh2kvo9htvuppy+LqeP0LgvBo/IpIJ+b/kQrGUDaM4XPvlBR9IPVq3mlkDldKIJ5k0vnGyzNh2myYvdtJ0S3wLtJeZOybT8uEabQ3kPSkSRUDRhs3HpI2uhKwKZKC8elADStJcASJOg7IcrF9BZvVBCPVi0bg6LdHF4IOqNkvmNaVM2iMWBHqoKLD9TvghAE92ecjdXxkxveb8tHElMxB7PblETZ1G2zDe1eNbBMkVEGdsDl4k3d709uAk86RPY3k2b5lZOIzbxnN2c5xk+LM9jv8PZaIBFkSwWBw9CRWwlLJ3fVZPTuYkUyLT+KPP7VBGAQmGev5tHTGMUrbvDU/pyeNn1oOQLQ74d6yeA51Hyfnn6FWDtmF8bueyXvzx+5XB/3d6/4rbfL+8Bz8Ne++X+s4z5pp/QLrtf/vJ47/B3U/L9Q/Fp4P87fn7R/c+NfwQYAFx9eFOvgdoSAAAAAElFTkSuQmCC"/></p><style>.base64.sign {display: none;}</style><p id="P01E0_12" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P01E0_13" class="formattext topleveltext indenttext" align="justify">ISO/IEC 13817-1:1996, Information technology - Programming languages, their environments and system software interfaces - Vienna Development Method - Specification Language - Part 1: Base language.<br/><br/></p><p id="P01E0_14" class="formattext topleveltext indenttext" align="justify">Systematic Software Development using VDM. С. В. Jones. Prentice-Hall. 2nd Edition, 1990.<br/><br/></p><p id="P01E0_15" class="formattext topleveltext indenttext" align="justify">Conformity Clause for VDM-SL, G. I. Parkin and B. A. Wichmann, Lecture Notes in Computer Science 670, FME'93 Industrial-Strength Formal Methods, First International Symposium of Formal Methods in Europe. Editors: J. С P. Woodcock and P.G. Larsen. Springer Verlag, 501-520.<br/><br/></p><p id="P01E2" class="formattext topleveltext indenttext" align="justify">C.2.4.9 Z<br/><br/></p><p id="P01E2_1" class="formattext topleveltext indenttext" align="justify">Цель. Z - это нотация языка спецификаций для последовательных систем и метод проектирования, позволяющий разработчику выполнять работу, начиная со спецификации на языке Z до исполнительных алгоритмов, обеспечивая при этом доказательство их корректности по отношению к спецификации.<br/><br/></p><p id="P01E2_2" class="formattext topleveltext indenttext" align="justify">Язык Z в принципе используется на этапе спецификации, однако данный язык был разработан для использования от этапа составления спецификации до проектирования и реализации систем. Более всего он подходит для разработки последовательных систем, ориентированных на данные.<br/><br/></p><p id="P01E2_3" class="formattext topleveltext indenttext" align="justify">Описание. Как и в VDM, в реализованном в языке Z методе спецификации состояние системы моделируется в терминах теоретико-множественных структур, в которых описаны инварианты (используя предикаты), а операции над этими состояниями моделируются путем определения их пред- и постусловий в терминах системных состояний. Операции допускается проверять на сохранение системных инвариантов для демонстрации их согласованности. Формальная часть спецификации подразделяется на схемы, которые обеспечивают возможность структурирования спецификаций путем их усовершенствования.<br/><br/></p><p id="P01E2_4" class="formattext topleveltext indenttext" align="justify">Обычно спецификация Z представляет собой сочетание формального текста на языке Z и неформального пояснительного текста на естественном языке. Формальный текст сам по себе может оказаться слишком сжатым для простого восприятия и часто его смысл необходимо пояснять, тогда как неформальный, естественный язык может оказаться неоднозначным и неточным.<br/><br/></p><p id="P01E2_5" class="formattext topleveltext indenttext" align="justify">В отличие от VDM язык Z представляет собой скорее нотацию, чем завершенный метод. Однако был разработан близкий метод (метод В), который может быть использован в сочетании с языком Z. Метод В основан на принципе пошагового уточнения.<br/><br/></p><p id="P01E2_6" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P01E2_7" class="formattext topleveltext indenttext" align="justify">Formal Specification using Z, 2nd Edition. D. Lightfoot. Palgrave Macmillan, 2000, ISBN 9780333763278.<br/><br/></p><p id="P01E2_8" class="formattext topleveltext indenttext" align="justify">The B-Method. S. Schneider. Palgrave Macmillan, 2001, ISBN 9780333792841.<br/><br/></p><p id="P01E4" class="formattext topleveltext indenttext" align="justify"><b>C.2.5 Программирование с защитой</b><br/><br/></p><p id="P01E4_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблица А.4).<br/><br/><br/></p><p id="P01E4_2" class="formattext topleveltext indenttext" align="justify">Цель. Создание программ, выявляющих во время их исполнения аномальные потоки управления, данных или значения данных и реагирующих на них заранее определенным и приемлемым способом.<br/><br/></p><p id="P01E4_3" class="formattext topleveltext indenttext" align="justify">Описание. В процессе разработки программ допускается использовать разные методы для проверки аномалий в потоках управления или данных. Эти методы могут применяться систематически в процессе программирования системы для снижения вероятности ошибочной обработки данных.<br/><br/></p><p id="P01E4_4" class="formattext topleveltext indenttext" align="justify">Существуют два пересекающихся множества методов защиты. Внутренние методы защиты от ошибок проектируются в программном обеспечении для преодоления недостатков в процессе создания этих программных средств. Эти недостатки могут быть обусловлены ошибками при проектировании или кодировании либо ошибочными требованиями. Ниже перечислены некоторые из рекомендаций по защите:<br/><br/></p><p id="P01E4_5" class="formattext topleveltext indenttext" align="justify">- проверка диапазона значений переменных;<br/><br/></p><p id="P01E4_6" class="formattext topleveltext indenttext" align="justify">- проверка значений переменных на их достоверность (если возможно);<br/><br/></p><p id="P01E4_7" class="formattext topleveltext indenttext" align="justify">- проверка типа, размерности и диапазона значений параметров процедур на входе процедур.<br/><br/></p><p id="P01E4_8" class="formattext topleveltext indenttext" align="justify">Представленные три рекомендации помогают гарантировать допустимость значений, обрабатываемых в программах, как с точки зрения терминов программных функций, так и физических значений переменных.<br/><br/></p><p id="P01E4_9" class="formattext topleveltext indenttext" align="justify">Параметры &quot;только для чтения&quot; и параметры &quot;для чтения-записи&quot; должны быть разделены, и доступ к ним должен проверяться. Программные функции должны рассматривать все параметры в качестве параметров &quot;только для чтения&quot;. Символьные константы не должны быть доступны для записи. Это помогает обнаруживать случайные перезаписи или ошибочное использование переменных.<br/><br/></p><p id="P01E4_10" class="formattext topleveltext indenttext" align="justify">Устойчивое к ошибкам программное обеспечение проектируется в &quot;предположении&quot;, что ошибки существуют в его собственном окружении либо используются выходящие за номиналы значения или предполагаемые условия, но программное обеспечение ведет себя заранее определенным способом. В этом случае применяют следующие проверки:<br/><br/></p><p id="P01E4_11" class="formattext topleveltext indenttext" align="justify">- проверку на достоверность физических значений входных и промежуточных переменных;<br/><br/></p><p id="P01E4_12" class="formattext topleveltext indenttext" align="justify">- проверку влияния выходных переменных, предпочтительно путем прямого наблюдения соответствующих изменений состояния системы;<br/><br/></p><p id="P01E4_13" class="formattext topleveltext indenttext" align="justify">- проверку самим программным обеспечением своей конфигурации, включая наличие и доступность предполагаемых аппаратных средств, а также завершенность самого программного обеспечения, что особенно важно для поддержки полноты в процессе его эксплуатации.<br/><br/></p><p id="P01E4_14" class="formattext topleveltext indenttext" align="justify">Некоторые из методов защиты программ, например, проверки последовательности потока управления, также справляются и с внешними отказами.<br/><br/></p><p id="P01E4_15" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P01E4_16" class="formattext topleveltext indenttext" align="justify">Software Engineering for Real-time Systems. J.E. Cooling, Pearson Education, 2003, ISBN 0201596202, 9780201596205.<br/><br/></p><p id="P01E4_17" class="formattext topleveltext indenttext" align="justify">Dependability of Critical Computer Systems: Guidelines Produced by the European Workshop on Industrial Computer Systems, Technical Committee 7 (EWICS TC7, Systems Reliability, Safety, and Security). Elsevier Applied Science, 1989, ISBN 1851663819, 9781851663811.<br/><br/></p><p id="P01E6" class="formattext topleveltext indenttext" align="justify"><b>С.2.6 Стандарты по проектированию и кодированию</b><br/><br/></p><p id="P01E6_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблица А.4).<br/><br/></p><p id="P01E8" class="formattext topleveltext indenttext" align="justify">С.2.6.1 Общие положения<br/><br/></p><p id="P01E8_1" class="formattext topleveltext indenttext" align="justify">Цель. Упрощение верификации, с тем чтобы поддержать групповой объективный подход и установить стандартный метод проектирования.<br/><br/></p><p id="P01E8_2" class="formattext topleveltext indenttext" align="justify">Описание. В самом начале между участниками проекта должны быть согласованы необходимые правила, охватывающие рассмотренные ниже методы проектирования и разработки (например JSP, сети Петри и т.д.), а также соответствующие стандарты кодирования (см. С.2.6.2).<br/><br/></p><p id="P01E8_3" class="formattext topleveltext indenttext" align="justify">Данные правила создаются для облегчения разработки, верификации, оценки и эксплуатации. При этом должны учитываться доступные инструментальные средства, в частности, для аналитиков, а также развитие средств проектирования.<br/><br/></p><p id="P01E8_4" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P01E8_5" class="formattext topleveltext indenttext" align="justify">IEC 60880:2006, Nuclear power plants - Instrumentation and control systems important to safety - Software aspects for computer-based systems performing category A functions.<br/><br/></p><p id="P01E8_6" class="formattext topleveltext indenttext" align="justify">Verein Deutscher Ingenieure. Software-Zuverlassigkeit - Grundlagen, Konstruktive Mass-nahmen, Nachweisverfahren. VDI-Verlag, 1993, ISBN 3-18-401185-2.<br/><br/></p><p id="P01EA" class="formattext topleveltext indenttext" align="justify">C.2.6.2 Стандарты кодирования<br/><br/></p><p id="P01EA_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблица В.1).<br/><br/><br/></p><p id="P01EA_2" class="formattext topleveltext indenttext" align="justify">Цель. Сократить вероятность ошибок в разрабатываемом коде, связанном с безопасностью, и упростить его верификацию.<br/><br/></p><p id="P01EA_3" class="formattext topleveltext indenttext" align="justify">Описание. Следующие принципы указывают, как связанные с безопасностью правила кодирования (для любого языка программирования) могут помочь в выполнении нормативных требований МЭК 61508-3 и в достижении информативных &quot;требуемых свойств&quot; (см. приложение F). Необходимо уделить внимание доступным инструментам поддержки.<br/><br/></p><p id="X1151"></p><div element-type="table" class="table-container" id="X1152"><style type="text/css">#P01EB .td1 {width: 16.94em}#P01EB .td2 {width: 31.57em}#P01EB .td3 {width: 16.94em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }#P01EB .td4 {width: 31.57em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }</style><table id="P01EB" class="wideTable"><tr height="1"><td class="td1"></td><td class="td2"></td></tr><tr><td valign="top" class="td3"><p id="P01EB0000" class="formattext" align="center">Требования и рекомендации МЭК 61508-3<br/></p></td><td valign="top" class="td4"><p id="P01EB0001" class="formattext" align="center">Указания стандартов кодирования </p></td></tr><tr><td valign="top" class="td3"><p id="P01EB0002" class="formattext" align="justify">Модульный подход (таблица А.2-7, таблица А.4-4)<br/><br/></p></td><td valign="top" class="td4"><p id="P01EB0003" class="formattext" align="justify">Ограничение размера программного модуля (таблица В.9-1) и управление сложностью программного обеспечения (таблица В.9-2). Примеры:<br/><br/></p><p id="P01EB0003_1" class="formattext" align="justify">- определение &quot;локальных&quot;: размера, метрик сложности и предельных размеров (для модулей);<br/><br/></p><p id="P01EB0003_2" class="formattext" align="justify">- определение &quot;глобальных&quot; метрик сложности и предельных размеров (для всей структуры модулей);<br/><br/></p><p id="P01EB0003_3" class="formattext" align="justify">- ограниченное число параметров/фиксированное число параметров под программы (таблица В.9-4).<br/><br/></p><p id="P01EB0003_4" class="formattext" align="justify">Ограничение доступа/инкапсуляция информации (таблица В.9-3), например, стимулы для того, чтобы использовать определенные функции языка. Полностью определенный интерфейс (таблица В.9-6). Примеры:<br/><br/></p><p id="P01EB0003_5" class="formattext" align="justify">- точная спецификация сигнатуры функции;<br/><br/></p><p id="P01EB0003_6" class="formattext" align="justify">- программирование с проверкой ошибок (таблица А.2-3а) и верификация данных (7.9.2.7) с явной спецификацией предварительных условий и постусловий для функций, утверждений, инвариантов типов данных<br/><br/></p></td></tr><tr><td valign="top" class="td3"><p id="P01EB0004" class="formattext" align="justify">Понятность кода<br/><br/></p><p id="P01EB0004_1" class="formattext" align="justify">- содействие понятности кода (7.4.4.13);<br/><br/></p><p id="P01EB0004_2" class="formattext" align="justify">- читаемый, понятный и тестируемый код (7.4.6)<br/><br/></p></td><td valign="top" class="td4"><p id="P01EB0005" class="formattext" align="justify">Соглашения о присвоении имен, продвигающие значащие, однозначные имена, например, предотвращение имен, которые можно перепутать (например IO и I0).<br/><br/></p><p id="P01EB0005_1" class="formattext" align="justify">Символьные имена для числовых значений.<br/><br/></p><p id="P01EB0005_2" class="formattext" align="justify">Процедуры и руководства для документирования исходного кода (7.4.4.13). Например, в них:<br/><br/></p><p id="P01EB0005_3" class="formattext" align="justify">- объяснить, почему и зачем (а не только что) кодируется;<br/><br/></p><p id="P01EB0005_4" class="formattext" align="justify">- описать предостережения;<br/><br/></p><p id="P01EB0005_5" class="formattext" align="justify">- описать побочные эффекты.<br/><br/></p><p id="P01EB0005_6" class="formattext" align="justify">Где это возможно, в исходном коде должна содержаться следующая информация (7.4.4.13):<br/><br/></p><p id="P01EB0005_7" class="formattext" align="justify">- юридическое лицо (например компания, автор(ы) и т.д.);<br/><br/></p><p id="P01EB0005_8" class="formattext" align="justify">- описание кода;<br/><br/></p><p id="P01EB0005_9" class="formattext" align="justify">- входные и выходные данные;<br/><br/></p><p id="P01EB0005_10" class="formattext" align="justify">- история управления конфигурацией.<br/><br/></p><p id="P01EB0005_11" class="formattext" align="justify">(См. также модульный подход.)<br/><br/></p></td></tr><tr><td valign="top" class="td3"><p id="P01EB0006" class="formattext" align="justify">Верифицируемость и тестируемость:<br/><br/></p><p id="P01EB0006_1" class="formattext" align="justify">- способствовать верификации и тестированию (7.4.4.13);<br/><br/></p><p id="P01EB0006_2" class="formattext" align="justify">- способствовать обнаружению ошибок при проектировании или программировании (7.4.4.10);<br/><br/></p><p id="P01EB0006_3" class="formattext" align="justify">- формальная верификация (таблица А.5-9);<br/><br/></p><p id="P01EB0006_4" class="formattext" align="justify">- формальное доказательство (таблица А.9-1)<br/><br/></p></td><td valign="top" class="td4"><p id="P01EB0007" class="formattext" align="justify">- окружения для &quot;критических&quot; библиотечных функций для проверки пред/постусловий;<br/><br/></p><p id="P01EB0007_1" class="formattext" align="justify">- стимулы для того, чтобы использовать функции языка, которые могут выразить ограничения на использование определенных элементов данных или функций (например констант);<br/><br/></p><p id="P01EB0007_2" class="formattext" align="justify">- для инструментов, поддерживающих верификацию: правила выполнения ограничений для выбранных инструментов (если это не вредит более существенным целям);<br/><br/></p><p id="P01EB0007_3" class="formattext" align="justify">- ограниченное использование рекурсии (таблица В.1-6) и другие формы циклических зависимостей.<br/><br/></p><p id="P01EB0007_4" class="formattext" align="justify">(См. также модульный подход.)<br/><br/></p></td></tr><tr><td valign="top" class="td3"><p id="P01EB0008" class="formattext" align="justify">Статическая верификация соответствия специфицированному проекту (7.9.2.12)<br/><br/></p></td><td valign="top" class="td4"><p id="P01EB0009" class="formattext" align="justify">Указания по кодированию для реализации специфицированных в проекте концепций или ограничений. Например:<br/><br/></p><p id="P01EB0009_1" class="formattext" align="justify">- указания по кодированию циклов с гарантируемым максимальным значением времени цикла (таблица А.2-13a);<br/><br/></p><p id="P01EB0009_2" class="formattext" align="justify">- указания по кодированию архитектуры с временным распределением (таблица А.2-13b);<br/><br/></p><p id="P01EB0009_3" class="formattext" align="justify">- указания по кодированию архитектуры, управляемой событиями, с гарантируемым максимальным временем ответа (таблица А.2-13с);<br/><br/></p><p id="P01EB0009_4" class="formattext" align="justify">- циклы со статически определенным максимальным числом итераций (за исключением бесконечного цикла, предусмотренного в проекте);<br/><br/></p><p id="P01EB0009_5" class="formattext" align="justify">- указания по кодированию статического распределения ресурсов (таблица А.2-14) и предотвращение динамических объектов (таблица В.1-2);<br/><br/></p><p id="P01EB0009_6" class="formattext" align="justify">- указания по кодированию статической синхронизации доступа к совместно используемым ресурсам (таблица А.2-15);<br/><br/></p><p id="P01EB0009_7" class="formattext" align="justify">- указания по кодированию, по соблюдению ограничений на использование прерываний (таблица В.1-4);<br/><br/></p><p id="P01EB0009_8" class="formattext" align="justify">- указания по кодированию, чтобы не использовать динамические переменные (таблица В.1-3а);<br/><br/></p><p id="P01EB0009_9" class="formattext" align="justify">- проверка установки динамических переменных в неавтономном режиме (таблица В.1-3b);<br/><br/></p><p id="P01EB0009_10" class="formattext" align="justify">указания по кодированию, чтобы гарантировать совместимость с другими используемыми языками программирования (7.4.4.10).<br/><br/></p><p id="P01EB0009_11" class="formattext" align="justify">Указания, способствующие отслеживаемости проекта<br/><br/></p></td></tr><tr><td valign="top" class="td3"><p id="P01EB000A" class="formattext" align="justify">Подмножество языков (таблица А.3-3):<br/><br/></p><p id="P01EB000A_1" class="formattext" align="justify">- запрет опасных функций языка (7.4.4.13);<br/><br/></p><p id="P01EB000A_2" class="formattext" align="justify">- использование только определенных функций языка (7.4.4.10);<br/><br/></p><p id="P01EB000A_3" class="formattext" align="justify">- структурное программирование (таблица А.4-6),<br/><br/></p><p id="P01EB000A_4" class="formattext" align="justify">- строго типизированный язык программирования (таблица А.3-2);<br/><br/></p><p id="P01EB000A_5" class="formattext" align="justify">- отсутствие автоматического преобразования типов (таблица В.1-8)<br/><br/></p></td><td valign="top" class="td4"><p id="P01EB000B" class="formattext" align="justify">Исключение функций языка, приводящих к неструктурированным проектам. Например:<br/><br/></p><p id="P01EB000B_1" class="formattext" align="justify">- ограниченное использование указателей (таблица В.1-5),<br/><br/></p><p id="P01EB000B_2" class="formattext" align="justify">- ограниченное использование рекурсии (таблица В.1-6),<br/><br/></p><p id="P01EB000B_3" class="formattext" align="justify">- ограниченное использование объединений подобных в С;<br/><br/></p><p id="P01EB000B_4" class="formattext" align="justify">- ограниченное использование исключений, подобных в Ada или C++,<br/><br/></p><p id="P01EB000B_5" class="formattext" align="justify">- неиспользование неструктурированного потока управления в программах на языках высокого уровня (таблица В.1-7),<br/><br/></p><p id="P01EB000B_6" class="formattext" align="justify">- одна точка входа/одна точка выхода в подпрограммах и функциях (таблица В.9-5);<br/><br/></p><p id="P01EB000B_7" class="formattext" align="justify">- неиспользование автоматического преобразования типов;<br/><br/></p><p id="P01EB000B_8" class="formattext" align="justify">- ограниченное использование побочных эффектов, сигнатур функций (например статических переменных).<br/><br/></p><p id="P01EB000B_9" class="formattext" align="justify">Не допускать побочные эффекты в оценке условий и во всех формах утверждений.<br/><br/></p><p id="P01EB000B_10" class="formattext" align="justify">Ограниченное или только документально оформленное использование специфичных для компилятора функций.<br/><br/></p><p id="P01EB000B_11" class="formattext" align="justify">Ограниченное использование конструкций языка, которые могут ввести в заблуждение.<br/><br/></p><p id="P01EB000B_12" class="formattext" align="justify">Должны применяться правила, когда эти возможности языка тем не менее используются<br/><br/></p></td></tr><tr><td valign="top" class="td3"><p id="P01EB000C" class="formattext" align="justify">Хорошая практика программирования (7.4.4.13)<br/><br/></p></td><td valign="top" class="td4"><p id="P01EB000D" class="formattext" align="justify">Когда применяются:<br/><br/></p><p id="P01EB000D_1" class="formattext" align="justify">- указания по кодированию, гарантирующие, что, в случае необходимости, выражения с плавающей точкой оцениваются в правильном порядке (например &quot;a-b+с&quot; не всегда равно &quot;а+с-b&quot;),<br/><br/></p><p id="P01EB000D_2" class="formattext" align="justify">- в сравнениях с плавающей точкой: использовать только неравенства (меньше чем, меньше или равный, больше чем, больше или равный) вместо строгого равенства; указания, относящиеся к условной компиляции и &quot;препроцессорной обработке&quot;;<br/><br/></p><p id="P01EB000D_3" class="formattext" align="justify">- систематическая проверка условий возврата (успех/отказ).<br/><br/></p><p id="P01EB000D_4" class="formattext" align="justify">Документировать и по возможности автоматизировать создание исполняемого кода (make-файлы).<br/><br/></p><p id="P01EB000D_5" class="formattext" align="justify">Предотвращать побочные эффекты, не очевидные из сигнатур функций. Когда такие побочные эффекты существуют, в соответствии с указаниями их необходимо документально оформить.<br/><br/></p><p id="P01EB000D_6" class="formattext" align="justify">Заключать в скобки, когда приоритет операторов не абсолютно очевиден. Искать предположительно невозможные ситуации (например ситуация &quot;по умолчанию&quot; в &quot;переключателях&quot; языка С).<br/><br/></p><p id="P01EB000D_7" class="formattext" align="justify">Использовать &quot;окружения&quot; для критических модулей, в особенности чтобы проверить пред- и постусловия и условия возврата.<br/><br/></p><p id="P01EB000D_8" class="formattext" align="justify">Соблюдать указания по кодированию в условиях известных ошибок компилятора и в пределах, установленных оценкой компилятора<br/><br/></p></td></tr></table></div><p id="P01EC" class="formattext topleveltext empty_line" align="justify"></p><p id="P01EE" class="formattext topleveltext indenttext" align="justify">С.2.6.3 Отказ от динамических переменных или динамических объектов<br/><br/></p><p id="P01EE_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблицы А.2 и В.1).<br/><br/><br/></p><p id="P01EE_2" class="formattext topleveltext indenttext" align="justify">Цель. Исключить:<br/><br/></p><p id="P01EE_3" class="formattext topleveltext indenttext" align="justify">- нежелательные или необнаруживаемые наложения в памяти;<br/><br/></p><p id="P01EE_4" class="formattext topleveltext indenttext" align="justify">- узкие места ресурсов в процессе (связанном с безопасностью) выполнения программы.<br/><br/></p><p id="P01EE_5" class="formattext topleveltext indenttext" align="justify">Описание. В случае применения этого метода динамические переменные и динамические объекты получают определяемые во время выполнения программы определенные и абсолютные адреса в памяти. Объем (размер) распределяемой памяти и ее адреса зависят от состояния системы в момент распределения памяти и не могут быть проверены компилятором или другим автономным инструментом.<br/><br/></p><p id="P01EE_6" class="formattext topleveltext indenttext" align="justify">Так как число динамических переменных и объектов и существующее свободное пространство памяти для размещения новых динамических переменных или объектов зависит от состояния системы в момент их размещения, то при размещении или при использовании переменных или объектов возможны сбои. Например, если объем свободной памяти, распределяемый системой, недостаточен, то содержимое памяти другой переменной может быть неумышленно стерто. Если динамические переменные или объекты не используются, то появление этих ошибок исключено.<br/><br/></p><p id="P01EE_7" class="formattext topleveltext indenttext" align="justify">Необходимы ограничения на использование динамических объектов, если динамическое поведение не может быть точно предсказано с помощью статического анализа (то есть перед выполнением программы), и поэтому не может быть гарантировано предсказуемое выполнение программы.<br/><br/></p><p id="P01F0" class="formattext topleveltext indenttext" align="justify">С.2.6.4 Проверка создания динамических переменных или динамических объектов при выполнении программы<br/><br/></p><p id="P01F0_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблица В.1).<br/><br/><br/></p><p id="P01F0_2" class="formattext topleveltext indenttext" align="justify">Цель. Убедиться в том, что память, в которой должны быть размещены динамические переменные и объекты, свободна до ее загрузки, а размещение в ней динамических переменных и объектов во время выполнения программы не повлияет на уже существующие в ней переменные, данные или коды.<br/><br/></p><p id="P01F0_3" class="formattext topleveltext indenttext" align="justify">Описание. В случае применения этих средств к динамическим переменным относят те переменные, которые имеют свои конкретные и абсолютные адреса в памяти, устанавливаемые во время выполнения программы (в этом смысле динамические переменные являются также атрибутами экземпляров объектов).<br/><br/></p><p id="P01F0_4" class="formattext topleveltext indenttext" align="justify">Аппаратными либо программными средствами память проверяется на то, что она свободна до размещения в ней динамических переменных или объектов (например для того, чтобы исключить переполнение стека). Если размещение не разрешается (например если памяти по конкретному адресу недостаточно), должны быть предприняты соответствующие действия. После использования динамических переменных или объектов (например после выхода из подпрограммы) вся используемая ими память должна быть освобождена.<br/><br/></p><p id="P01F0_5" class="formattext topleveltext indenttext" align="justify">Примечание - Альтернативным методом является демонстрация статического распределения памяти.<br/><br/></p><p id="P01F2" class="formattext topleveltext indenttext" align="justify">С.2.6.5 Ограниченное использование прерываний<br/><br/></p><p id="P01F2_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблица В.1).<br/><br/><br/></p><p id="P01F2_2" class="formattext topleveltext indenttext" align="justify">Цель. Сохранение верифицируемости и тестируемости программного обеспечения.<br/><br/></p><p id="P01F2_3" class="formattext topleveltext indenttext" align="justify">Описание. Использование прерываний должно быть ограничено. Прерывания могут использоваться, если они упрощают систему. Использование программных средств для обработки прерываний должно быть запрещено в критических ситуациях для выполняемых функций (например критичность по времени, критичность изменений данных). Если прерывания используются, то непрерываемые фрагменты должны иметь специфицированное максимальное время вычисления с тем, чтобы можно было вычислить максимальное время, в течение которого прерывание запрещено. Использование прерываний и их маскирование должны подробно документироваться.<br/><br/></p><p id="P01F4" class="formattext topleveltext indenttext" align="justify">С.2.6.6 Ограниченное использование указателей<br/><br/></p><p id="P01F4_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблица В.1).<br/><br/><br/></p><p id="P01F4_2" class="formattext topleveltext indenttext" align="justify">Цель. Исключение проблем, связанных с доступом к данным без предварительной проверки типа и диапазона указателя. Обеспечение модульного тестирования и верификации программных средств. Ограничение последствия отказов.<br/><br/></p><p id="P01F4_3" class="formattext topleveltext indenttext" align="justify">Описание. В прикладных программных средствах арифметика указателей может быть использована на уровне исходного кода только в случае, если тип и диапазон значений указателя данных (для гарантии того, что ссылка указателя находится внутри корректного адресного пространства) будут проверены перед доступом. Межпроцессное взаимодействие в прикладных программах не должно осуществляться прямым доступом между задачами. Обмен данными должен осуществляться через операционную систему.<br/><br/></p><p id="P01F6" class="formattext topleveltext indenttext" align="justify">С.2.6.7 Ограниченное использование рекурсий<br/><br/></p><p id="P01F6_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблица В.1).<br/><br/><br/></p><p id="P01F6_2" class="formattext topleveltext indenttext" align="justify">Цель. Исключение неверифицируемого и нетестируемого использования вызовов подпрограмм.<br/><br/></p><p id="P01F6_3" class="formattext topleveltext indenttext" align="justify">Описание. Если используется рекурсия, то должен быть определен четкий критерий, который делает глубину рекурсии предсказуемой.<br/><br/></p><p id="P01F8" class="formattext topleveltext" align="justify"><b>     </b><b>С.2.7 Структурное программирование</b><br/><br/></p><p id="P01F8_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблица А.4).<br/><br/><br/></p><p id="P01F8_2" class="formattext topleveltext indenttext" align="justify">Цель. Проектирование и реализация программы с использованием практического анализа программы без ее выполнения. Программа может содержать только абсолютный минимум статистически нетестируемого поведения.<br/><br/></p><p id="P01F8_3" class="formattext topleveltext indenttext" align="justify">Описание. Для минимизации структурной сложности программы следует применять следующие принципы:<br/><br/></p><p id="P01F8_4" class="formattext topleveltext indenttext" align="justify">- разделять программу на подходящие, небольшие, минимально связанные программные модули, все взаимодействия между которыми точно специфицированы;<br/><br/></p><p id="P01F8_5" class="formattext topleveltext indenttext" align="justify">- составлять поток управления программными модулями с использованием таких структурированных конструкций, как последовательности, итерации и выбор;<br/><br/></p><p><img class="base64 sign" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZIAAAARCAMAAADAD9oKAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MTg4Q0U3ODQ0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MTg4Q0U3ODU0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoxODhDRTc4MjRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDoxODhDRTc4MzRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pos3t18AAAAzUExURfX19SQkJOrq6oeHh7y8vD8/P9/f31RUVMjIyLCwsHh4eJaWlmdnZ6Ojo9TU1AAAAP////kimdMAAAWSSURBVHja7FiJcuQoDAVzGcz1/1+7TwLRuDs9mZ2karZqQ1ViGz90PUngVv1nfMOo9fg2WarnNkf9FGxMHdDkf1jo3bXBg7o0YhIkfrXV0npvBfd48y94HQtV97XWZvBPfbpG29oikGfQ6oeRs4WLb4K2CGNq5wsltpX6B5TQYEa5/u6h9rdn31QdtXS0iKX1WZ360/o9Pl/3NmVq/ahk/cfwZ0X+bSL6T01Kxmq6Fj0MSDNPj+atGzF1+Y17z9IZMRfulHiH+ivMFvE7nm2ffQ26Q5+U0AKLatWUGFm63kU3SJycuwqNLgNJ1ONf6crorUNyEySMStQLlegNgSuSmiT5agizm0YyZwPNbEXLM64y2X0YcGgdN3ytU9FaLDCecHbCyFWVh0kjMvBEHK+rvx/tVIgOWSoTcZrRa+aVJxeOuLc5nG8Oj2cjCzdKDm1Uj9BCSFeO7sKBgKCxRWpXKNAiFtV2njBAGeqm2QBQaZKCjjDCA+vqnZJD802sAzu9q4EwRtde4djUG4kJeFObpsag4cXNNJKJejRY7pVO9EJiQf2XRJLlBEcW1Toooc48FcniBeN2nOALwwzMDXhDJv2CkoKENkS/NKzu0p74rRyOk0vcezgs0iXQhLDixE4J6YAALgUqoEq6VKpih0KosOuUUihxM+eGo6KIA3DEaTI8oJS7UZIybnhmOVX1wCiqLJSYmnr52WjShadTA7Obtsyl2lP22PquxG9kJ1VbSWN2gEXRfF4wlnri36xnTJBYC+R7ShyX17HNDIcXJSg8ddMqDi/p0+HOCGNfKclwPmdHBsVgp9mbHaemuwBMwtvmCK2pQqtwdpakiZIQg7pTAitwc+m6OVWyWFhnzQy9aMrcDZASSAJjgNlMo5R4UIJ1xbhnSsYr+p/LRslS1FfshQFIpb4v06WRvgBky4VfseOmPqy3zaKiZqp/SEmpOqhdqzi8pE+H6/2wu1PiCg9AkvOvlJi0r2ZbS7FooaMpdo8WYy6ixPFRZKcEE9Iz115irhdKWC/y1VquyIpWqU+i5GEapcRWJaGFFN9T4s7foyRQdqmNkqHvGJmn82AtUzed1s9vB63U6jj6ulOCnnbtWsXhJX06/J6S5LbDmKYuy/W11rgbobKpdRvmtNFKGpfS142SqEcL8CE99hIKV+ZmbDnr/NQL2Slx46wxoDSB2U27NS77eN4oGZaj91G6PChZiubzgo2+i9AKJbEd/S5yKA5ZAnCwLL6IcfYe2aHWb1rF4SV9OjwQ9XylZGwwORFSIeLUakYnHEVAgh6U0D7elY49C1OZNrM09pIC8EaJtnyjdHiIqE4qiY+K2YleProNrUcLhk8Lm2k3SgrF/KVKhuUQVUzfKFmK5vOCvVBytMSb69NeolwS66954oXTvnF2en3b3XmlIo3LPXF4SReHXZ5b3zMlCKcpAVse9z38XXh2kvo9htvuppy+LqeP0LgvBo/IpIJ+b/kQrGUDaM4XPvlBR9IPVq3mlkDldKIJ5k0vnGyzNh2myYvdtJ0S3wLtJeZOybT8uEabQ3kPSkSRUDRhs3HpI2uhKwKZKC8elADStJcASJOg7IcrF9BZvVBCPVi0bg6LdHF4IOqNkvmNaVM2iMWBHqoKLD9TvghAE92ecjdXxkxveb8tHElMxB7PblETZ1G2zDe1eNbBMkVEGdsDl4k3d709uAk86RPY3k2b5lZOIzbxnN2c5xk+LM9jv8PZaIBFkSwWBw9CRWwlLJ3fVZPTuYkUyLT+KPP7VBGAQmGev5tHTGMUrbvDU/pyeNn1oOQLQ74d6yeA51Hyfnn6FWDtmF8bueyXvzx+5XB/3d6/4rbfL+8Bz8Ne++X+s4z5pp/QLrtf/vJ47/B3U/L9Q/Fp4P87fn7R/c+NfwQYAFx9eFOvgdoSAAAAAElFTkSuQmCC"/></p><style>.base64.sign {display: none;}</style><p id="P01F8_6" class="formattext topleveltext indenttext" align="justify">- обеспечивать небольшое число возможных путей через программные модули и возможно более простые отношения между входными и выходными параметрами;<br/><br/></p><p id="P01F8_7" class="formattext topleveltext indenttext" align="justify">- исключать сложные ветвления и, в частности, безусловные переходы (goto) при использовании языков высокого уровня;<br/><br/></p><p id="P01F8_8" class="formattext topleveltext indenttext" align="justify">- по возможности связывать ограничения цикла и ветвление с входными параметрами;<br/><br/></p><p id="P01F8_9" class="formattext topleveltext indenttext" align="justify">- исключать использование сложных вычислений в ветвлении и цикле.<br/><br/></p><p id="P01F8_10" class="formattext topleveltext indenttext" align="justify">Следует использовать свойства языков программирования, которые способствуют указанному выше методу, предпочитая их другим свойствам, которые (как утверждают) более эффективны, за исключением случаев, когда эффективность приобретает абсолютный приоритет (например некоторые критичные к безопасности системы).<br/><br/></p><p id="P01F8_11" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P01F8_12" class="formattext topleveltext indenttext" align="justify">Concepts in Programming Languages. J.С. Mitchell. Cambridge University Press, 2003, ISBN 0521780985, 9780521780988.<br/><br/></p><p id="P01FA" class="formattext topleveltext indenttext" align="justify">A Discipline of Programming. E.W. Dijkstra. Englewood Cliffs NJ, Prentice-Hall, 1976.<br/><br/></p><p id="P01FC" class="formattext topleveltext indenttext" align="justify"><b>C.2.8 Ограничение доступа/инкапсуляция информации</b><br/><br/></p><p id="P01FC_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблица В.9).<br/><br/><br/></p><p id="P01FC_2" class="formattext topleveltext indenttext" align="justify">Цель. Предотвращение непреднамеренного доступа к данным или процедурам и обеспечение тем самым качественной структуры программных средств.<br/><br/></p><p id="P01FC_3" class="formattext topleveltext indenttext" align="justify">Описание. Общедоступные для всех программных компонентов данные могут быть случайно или некорректно модифицированы любым из этих компонентов. Любые изменения этих структур данных могут потребовать подробной проверки программного кода и серьезных исправлений.<br/><br/></p><p id="P01FC_4" class="formattext topleveltext indenttext" align="justify">Ограничение доступа представляет собой общий метод к минимизации указанных выше проблем. Ключевые структуры данных &quot;скрыты&quot;, и с ними можно работать только через конкретный набор процедур доступа, это позволяет модифицировать внутренние структуры данных или добавлять новые процедуры и при этом не оказывать влияния на функциональное поведение остальных программных средств. Например, имя директории могут иметь процедуры доступа &quot;вставить&quot;, &quot;удалить&quot; и &quot;найти&quot;. Процедуры доступа и структуры внутренних данных могут быть изменены (например при использовании различных методов просмотра или запоминании имен на жестком диске), не оказывая влияния на логическое поведение остальных программных средств, использующих эти процедуры.<br/><br/></p><p id="P01FC_5" class="formattext topleveltext indenttext" align="justify">В данном случае следует использовать концепцию абстрактных типов данных. Если непосредственная проверка не предусмотрена, может оказаться необходимым проверить, не было ли абстрагирование случайно разрушено.<br/><br/></p><p id="P01FC_6" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P01FC_7" class="formattext topleveltext indenttext" align="justify">Concepts in Programming Languages. J.С. Mitchell. Cambridge University Press, 2003, ISBN 0521780985, 9780521780988.<br/><br/></p><p id="P01FC_8" class="formattext topleveltext indenttext" align="justify">On Design and Development of Program Families. D.L. Parnas. IEEE Trans SE-2, March 1976.<br/><br/></p><p id="P01FE" class="formattext topleveltext indenttext" align="justify"><b>C.2.9 Модульный подход</b><br/><br/></p><p id="P01FE_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблицы А.4 и В.9).<br/><br/><br/></p><p id="P01FE_2" class="formattext topleveltext indenttext" align="justify">Цель. Декомпозирование программной системы на небольшие законченные модули в целях сокращения сложности системы.<br/><br/></p><p id="P01FE_3" class="formattext topleveltext indenttext" align="justify">Описание. Модульный подход, или модуляризация, включает в себя несколько различных правил для этапов проектирования, кодирования и эксплуатации проекта программных средств. Эти правила меняются в соответствии с реализуемым методом проектирования. Большинство методов подчиняются следующим правилам:<br/><br/></p><p id="P01FE_4" class="formattext topleveltext indenttext" align="justify">- программный модуль (или подпрограмма, что одно и то же) должен выполнять одну четко сформулированную задачу или функцию;<br/><br/></p><p id="P01FE_5" class="formattext topleveltext indenttext" align="justify">- связи между программными модулями должны быть ограничены и строго определены, уровень связности каждого программного модуля должен быть высоким;<br/><br/></p><p id="P01FE_6" class="formattext topleveltext indenttext" align="justify">- совокупности подпрограмм должны строиться так, чтобы обеспечивать несколько уровней программных модулей;<br/><br/></p><p id="P01FE_7" class="formattext topleveltext indenttext" align="justify">- размеры подпрограмм следует ограничить некоторыми конкретными значениями, обычно от двух до четырех размеров экрана;<br/><br/></p><p id="P01FE_8" class="formattext topleveltext indenttext" align="justify">- подпрограммы должны иметь только один вход и один выход;<br/><br/></p><p id="P01FE_9" class="formattext topleveltext indenttext" align="justify">- программные модули должны взаимодействовать с другими программными модулями через свои интерфейсы, где используются глобальные или общие переменные, которые должны быть хорошо структурированы; доступ к ним должен находиться под контролем, и их использование в каждом конкретном случае должно быть обосновано;<br/><br/></p><p id="P01FE_10" class="formattext topleveltext indenttext" align="justify">- все интерфейсы программных модулей должны быть полностью документально оформлены;<br/><br/></p><p id="P01FE_11" class="formattext topleveltext indenttext" align="justify">- все интерфейсы программных модулей должны содержать только необходимые для их функционирования параметры. Однако эта рекомендация усложнена тем, что язык программирования может иметь параметры по умолчанию или используется объектно-ориентированный подход.<br/><br/></p><p id="P01FE_12" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P01FE_13" class="formattext topleveltext indenttext" align="justify">The Art of Software Testing, second edition. G.J. Myers, T. Badgett, T.M. Codd, С. Sandler, John Wiley and Sons, 2004, ISBN 0471469122, 9780471469124.<br/><br/></p><p id="P01FE_14" class="formattext topleveltext indenttext" align="justify">Software Engineering for Real-time Systems. J.E. Cooling, Pearson Education, 2003, ISBN 0201596202, 9780201596205.<br/><br/></p><p id="P01FE_15" class="formattext topleveltext indenttext" align="justify">Concepts in Programming Languages. J.С. Mitchell. Cambridge University Press, 2003, ISBN 0521780985, 9780521780988.<br/><br/></p><p id="P0200" class="formattext topleveltext indenttext" align="justify"><b>C.2.10 Использование доверительных/проверенных элементов программного обеспечения</b><br/><br/></p><p id="P0200_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблицы А.2, С.2, А.4 и С.4).<br/><br/><br/></p><p id="P0200_2" class="formattext topleveltext indenttext" align="justify">Цель. Исключение такого проектирования программных модулей и элементов, которое вызывало бы необходимость их интенсивных повторных проверок или перепроектирования для каждого нового применения. Использование преимущества проектов, которые не были формально или строго проверены, но для которых имеется продолжительный опыт эксплуатации. Использовать преимущества уже существующих программных элементов, которые были проверены для различных применений и для которых существует совокупность доказательств подтверждения соответствия.<br/><br/></p><p id="P0200_3" class="formattext topleveltext indenttext" align="justify">Описание. Данный метод проверяет наличие в программных элементах систематических ошибок проектирования и/или эксплуатационных отказов.<br/><br/></p><p id="P0200_4" class="formattext topleveltext indenttext" align="justify">Строить сложную систему, используя элементарные компоненты, нецелесообразно. Как правило, используют основные узлы (&quot;элементы&quot;, см. МЭК 61508-4, пункты 3.2.8 и 3.4.5), которые были разработаны ранее для обеспечения некоторых полезных функций и которые могут быть использованы для реализации некоторой части новой системы.<br/><br/></p><p id="P0200_5" class="formattext topleveltext indenttext" align="justify">Грамотно спроектированные и структурированные ПЭ системы состоят из ряда программных элементов, которые различаются между собой четким образом и взаимодействуют друг с другом вполне определенными способами. Формирование библиотеки таких общеприменимых программных элементов, которые можно повторно использовать в нескольких применениях, позволяет большую часть ресурсов, необходимых для подтверждения соответствия проектов, распределять по нескольким применениям.<br/><br/></p><p id="P0200_6" class="formattext topleveltext indenttext" align="justify">Однако для применений, связанных с безопасностью, важно иметь достаточную уверенность, что новая система, включающая эти уже существующие элементы, имеет необходимую полноту безопасности, а также, что безопасность новой системы не нарушается некоторым некорректным поведением уже существующих элементов.<br/><br/></p><p id="P0200_7" class="formattext topleveltext indenttext" align="justify">Существуют два подхода, как обрести уверенность в том, что поведение уже существующих элементов точно известно:<br/><br/></p><p id="P0200_8" class="formattext topleveltext indenttext" align="justify">- провести всесторонний анализ опыта эксплуатации элемента, чтобы продемонстрировать, что элемент был &quot;проверен в эксплуатации&quot;;<br/><br/></p><p id="P0200_9" class="formattext topleveltext indenttext" align="justify">- оценить совокупность доказательств подтверждения соответствия, которая была собрана для поведения элемента, чтобы определить, соответствует ли этот элемент требованиям настоящего стандарта.<br/><br/></p><p id="P0202" class="formattext topleveltext indenttext" align="justify">С.2.10.1 Проверка в эксплуатации<br/><br/></p><p id="P0202_1" class="formattext topleveltext indenttext" align="justify">Только в редких случаях &quot;проверки в эксплуатации&quot; (см. МЭК 61508-4, пункт 3.8.18) будет достаточно в качестве единственного средства, гарантирующего для доверительного элемента программного обеспечения достижение им необходимого уровня полноты безопасности. Для сложных элементов со многими возможными функциями (например операционной системы) важно установить, какая из функций достаточно проверена при ее использовании. Например, процедуру самотестирования для обнаружения ошибок, если в период ее эксплуатации не появилось отказов, нельзя рассматривать как проверенную в эксплуатации.<br/><br/></p><p id="P0202_2" class="formattext topleveltext indenttext" align="justify">Программный элемент может быть проверенным в эксплуатации, если он соответствует следующим критериям:<br/><br/></p><p id="P0202_3" class="formattext topleveltext indenttext" align="justify">- спецификация не менялась;<br/><br/></p><p id="P0202_4" class="formattext topleveltext indenttext" align="justify">- использовался в системах в различных областях применения;<br/><br/></p><p id="P0202_5" class="formattext topleveltext indenttext" align="justify">- продолжительность срока его эксплуатации не менее года;<br/><br/></p><p id="P0202_6" class="formattext topleveltext indenttext" align="justify">- продолжительность эксплуатации соответствует уровню полноты безопасности или соответствующему числу запросов; для демонстрации частоты отказов, не связанных с безопасностью, менее:<br/><br/></p><p id="P0202_7" class="formattext topleveltext indenttext" align="justify">- 10<img class="base64" src="data:image;base64,R0lGODdhEQAXAIABAAAAAP///ywAAAAAEQAXAAACIYyPqcvtD4GEARxLDc6b9iqFyOeQDWYm4ZS17gvH8kw7BQA7" width="17" height="23"/> на один запрос (в год) с 95%-ным уровнем доверия необходимо 300 эксплуатационных прохождений (в год);<br/><br/></p><p id="P0202_8" class="formattext topleveltext indenttext" align="justify">- 10<img class="base64" src="data:image;base64,R0lGODdhEQAXAIABAAAAAP///ywAAAAAEQAXAAACHoyPqcvtDwOYEcRDr7FapglyWCdCZQN26sq27guzBQA7" width="17" height="23"/> на один запрос (в год) с 99,9%-ным уровнем доверия необходимо 690000 эксплуатационных прохождений (в год).<br/><br/></p><p id="P0202_9" class="formattext topleveltext indenttext" align="justify">Примечание - Математический аппарат, обеспечивающий числовые оценки данного метода, приведен в приложении D. Аналогичный метод и статистический подход изложены также в В.5.4;<br/><br/><br/></p><p id="P0202_10" class="formattext topleveltext indenttext" align="justify">- весь опыт эксплуатации связан с известным профилем запросов функций программного модуля для гарантии того, что увеличивающийся опыт эксплуатации действительно приводит к увеличению знаний о поведении программного модуля, связанного с соответствующим профилем запроса;<br/><br/></p><p id="P0202_11" class="formattext topleveltext indenttext" align="justify">- его отказы не связаны с безопасностью.<br/><br/></p><p id="P0202_12" class="formattext topleveltext indenttext" align="justify">Примечание - Отказ, некритичный для безопасности в одном контексте, может быть критичен для безопасности в другом контексте, и наоборот.<br/><br/><br/></p><p id="P0202_13" class="formattext topleveltext indenttext" align="justify">Для проверки соответствия критерию программного элемента должно быть документально оформлено:<br/><br/></p><p id="P0202_14" class="formattext topleveltext indenttext" align="justify">- точная идентификация каждой системы и ее элементов, включая номера версий (как для программных, так и для аппаратных средств);<br/><br/></p><p id="P0202_15" class="formattext topleveltext indenttext" align="justify">- идентификация пользователей и продолжительность их работы;<br/><br/></p><p id="P0202_16" class="formattext topleveltext indenttext" align="justify">- продолжительность эксплуатации системы;<br/><br/></p><p id="P0202_17" class="formattext topleveltext indenttext" align="justify">- процедура выбора систем, применяемых пользователями, и случаев ее применения;<br/><br/></p><p id="P0202_18" class="formattext topleveltext indenttext" align="justify">- процедуры обнаружения и регистрации отказов и устранения сбоев.<br/><br/></p><p id="P0204" class="formattext topleveltext indenttext" align="justify">С.2.10.2 Оценка совокупности доказательств подтверждения соответствия<br/><br/></p><p id="P0204_1" class="formattext topleveltext indenttext" align="justify">Уже существующий элемент программного обеспечения (см. МЭК 61508-4, пункт 3.2.8) - это тот, который уже существует и не был разработан специально для текущего проекта или SRS. Уже существующее программное обеспечение может быть коммерческим доступным продуктом, или оно может быть разработано какой-то организацией для предыдущего изделия или системы. Предварительно существующее программное обеспечение может или не может быть разработано в соответствии с требованиями настоящего стандарта.<br/><br/></p><p id="P0204_2" class="formattext topleveltext indenttext" align="justify">Для оценки полноты безопасности новой системы, включающей уже существующие программы, необходима совокупность доказательств подтверждения соответствия для определения поведения предварительно существующего элемента. Она может быть получена (1) из собственной документации поставщика элемента и описания процесса разработки элемента или (2) может быть создана или дополнена дополнительными квалифицированными мероприятиями, выполненными разработчиком новой системы, связанной с безопасностью, или третьими лицами. Возможности и ограничения потенциально повторно используемого программного элемента определяются в &quot;Руководстве по безопасности для применяемых изделий&quot;.<br/><br/></p><p id="P0204_3" class="formattext topleveltext indenttext" align="justify">В любом случае должно существовать (или должно быть создано) руководство по безопасности для применяемых изделий, которое обеспечивает адекватную возможность выполнить оценку полноты безопасности конкретной функции безопасности, которая полностью или частично реализуется повторно используемым элементом. Если его нет, то должен быть сделан консервативный вывод о том, что для элемента не подтверждена возможность его повторного использования в системе, связанной с безопасностью. (Это не означает, что для элемента вообще не подтверждена возможность его повторного использования, просто в данном конкретном случае не было найдено достаточно доказательств.)<br/><br/></p><p id="P0204_4" class="formattext topleveltext indenttext" align="justify">Настоящий стандарт предъявляет особые требования к содержанию руководства по безопасности для применяемых изделий, см. МЭК 61508-2, приложение D, МЭК 61508-3, приложение D и МЭК 61508-3, пункты 7.4.2.12 и 7.4.2.13.<br/><br/></p><p id="P0204_5" class="formattext topleveltext indenttext" align="justify">В &quot;Руководстве по безопасности для применяемых изделий&quot; будет рассмотрено, что:<br/><br/></p><p id="P0204_6" class="formattext topleveltext indenttext" align="justify">- проект элемента известен и документально оформлен;<br/><br/></p><p id="P0204_7" class="formattext topleveltext indenttext" align="justify">- элемент был объектом проверки и подтверждения соответствия на основе систематического подхода с документально оформленной проверкой и анализом всех частей проекта элемента и кода;<br/><br/></p><p id="P0204_8" class="formattext topleveltext indenttext" align="justify">- неиспользуемые и ненужные функции элемента не помешают новой системе выполнения своих требований к безопасности;<br/><br/></p><p id="P0204_9" class="formattext topleveltext indenttext" align="justify">- все вероятные механизмы отказа элемента в новой системе были выявлены и было выполнено их соответствующее ослабление.<br/><br/></p><p id="P0204_10" class="formattext topleveltext indenttext" align="justify">Оценка функциональной безопасности новой системы должна установить, что повторно используемый элемент применяется строго в пределах возможностей, которые для этого элемента были обоснованы доказательством и предположениями в &quot;Руководстве по безопасности для применяемых изделий&quot;.<br/><br/></p><p id="P0204_11" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0204_12" class="formattext topleveltext indenttext" align="justify">Component-Based Software Development: Case Studies. Kung-Kiu Lau. World Scientific, 2004, ISBN 9812388281, 9789812388285.<br/><br/></p><p id="P0204_13" class="formattext topleveltext indenttext" align="justify">Software Reuse and Reverse Engineering in Practice. P.A. V. Hall (ed.), Chapman &amp; Hall, 1992, ISBN 0-412-39980-6.<br/><br/></p><p id="P0204_14" class="formattext topleveltext indenttext" align="justify">Software criticality analysis of COTS/SOUP. P. Bishop, T. Clement, S. Guerra. In Reliability Engineering &amp; System Safety, Volume 81, Issue 3, September 2003, Elsevier Ltd., 2003.<br/><br/></p><p id="P0206" class="formattext topleveltext indenttext" align="justify"><b>C.2.11 Прослеживаемость</b><br/><br/></p><p id="P0206_1" class="formattext topleveltext indenttext" align="justify">Цель. Обеспечить согласованность между этапами жизненного цикла.<br/><br/></p><p id="P0206_2" class="formattext topleveltext indenttext" align="justify">Описание. Для того, чтобы гарантировать для программного обеспечения, что результаты действий на этапах жизненного цикла соответствуют требованиям корректной работы системы, связанной с безопасностью, крайне важно гарантировать обеспечение соответствия между этапами жизненного цикла. Ключевым понятием здесь является &quot;прослеживаемость&quot; между действиями. В сущности, это выполнение анализа влияния, проверяющего (1), что решения, принятые на ранней стадии, адекватно реализованы на более поздних стадиях (прямая прослеживаемость), и (2), что решения, принятые на более позднем этапе, действительно необходимы и санкционированы ранее принятыми решеними (обратная прослеживаемость).<br/><br/></p><p id="P0206_3" class="formattext topleveltext indenttext" align="justify">Прямая прослеживаемость в основном связана с проверкой адекватности требований на более поздних этапах жизненного цикла. Прямая прослеживаемость важна в нескольких точках жизненного цикла системы безопасности:<br/><br/></p><p id="P0206_4" class="formattext topleveltext indenttext" align="justify">- между требованиями к системе безопасности и требованиями к программному обеспечению системы безопасности;<br/><br/></p><p id="P0206_5" class="formattext topleveltext indenttext" align="justify">- между спецификациями требований к программному обеспечению системы безопасности и к архитектуре программного обеспечения;<br/><br/></p><p id="P0206_6" class="formattext topleveltext indenttext" align="justify">- между спецификациями требований к программному обеспечению системы безопасности и к проекту программного обеспечения;<br/><br/></p><p><img class="base64 sign" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZIAAAARCAMAAADAD9oKAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MTg4Q0U3ODQ0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MTg4Q0U3ODU0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoxODhDRTc4MjRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDoxODhDRTc4MzRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pos3t18AAAAzUExURfX19SQkJOrq6oeHh7y8vD8/P9/f31RUVMjIyLCwsHh4eJaWlmdnZ6Ojo9TU1AAAAP////kimdMAAAWSSURBVHja7FiJcuQoDAVzGcz1/1+7TwLRuDs9mZ2karZqQ1ViGz90PUngVv1nfMOo9fg2WarnNkf9FGxMHdDkf1jo3bXBg7o0YhIkfrXV0npvBfd48y94HQtV97XWZvBPfbpG29oikGfQ6oeRs4WLb4K2CGNq5wsltpX6B5TQYEa5/u6h9rdn31QdtXS0iKX1WZ360/o9Pl/3NmVq/ahk/cfwZ0X+bSL6T01Kxmq6Fj0MSDNPj+atGzF1+Y17z9IZMRfulHiH+ivMFvE7nm2ffQ26Q5+U0AKLatWUGFm63kU3SJycuwqNLgNJ1ONf6crorUNyEySMStQLlegNgSuSmiT5agizm0YyZwPNbEXLM64y2X0YcGgdN3ytU9FaLDCecHbCyFWVh0kjMvBEHK+rvx/tVIgOWSoTcZrRa+aVJxeOuLc5nG8Oj2cjCzdKDm1Uj9BCSFeO7sKBgKCxRWpXKNAiFtV2njBAGeqm2QBQaZKCjjDCA+vqnZJD802sAzu9q4EwRtde4djUG4kJeFObpsag4cXNNJKJejRY7pVO9EJiQf2XRJLlBEcW1Toooc48FcniBeN2nOALwwzMDXhDJv2CkoKENkS/NKzu0p74rRyOk0vcezgs0iXQhLDixE4J6YAALgUqoEq6VKpih0KosOuUUihxM+eGo6KIA3DEaTI8oJS7UZIybnhmOVX1wCiqLJSYmnr52WjShadTA7Obtsyl2lP22PquxG9kJ1VbSWN2gEXRfF4wlnri36xnTJBYC+R7ShyX17HNDIcXJSg8ddMqDi/p0+HOCGNfKclwPmdHBsVgp9mbHaemuwBMwtvmCK2pQqtwdpakiZIQg7pTAitwc+m6OVWyWFhnzQy9aMrcDZASSAJjgNlMo5R4UIJ1xbhnSsYr+p/LRslS1FfshQFIpb4v06WRvgBky4VfseOmPqy3zaKiZqp/SEmpOqhdqzi8pE+H6/2wu1PiCg9AkvOvlJi0r2ZbS7FooaMpdo8WYy6ixPFRZKcEE9Iz115irhdKWC/y1VquyIpWqU+i5GEapcRWJaGFFN9T4s7foyRQdqmNkqHvGJmn82AtUzed1s9vB63U6jj6ulOCnnbtWsXhJX06/J6S5LbDmKYuy/W11rgbobKpdRvmtNFKGpfS142SqEcL8CE99hIKV+ZmbDnr/NQL2Slx46wxoDSB2U27NS77eN4oGZaj91G6PChZiubzgo2+i9AKJbEd/S5yKA5ZAnCwLL6IcfYe2aHWb1rF4SV9OjwQ9XylZGwwORFSIeLUakYnHEVAgh6U0D7elY49C1OZNrM09pIC8EaJtnyjdHiIqE4qiY+K2YleProNrUcLhk8Lm2k3SgrF/KVKhuUQVUzfKFmK5vOCvVBytMSb69NeolwS66954oXTvnF2en3b3XmlIo3LPXF4SReHXZ5b3zMlCKcpAVse9z38XXh2kvo9htvuppy+LqeP0LgvBo/IpIJ+b/kQrGUDaM4XPvlBR9IPVq3mlkDldKIJ5k0vnGyzNh2myYvdtJ0S3wLtJeZOybT8uEabQ3kPSkSRUDRhs3HpI2uhKwKZKC8elADStJcASJOg7IcrF9BZvVBCPVi0bg6LdHF4IOqNkvmNaVM2iMWBHqoKLD9TvghAE92ecjdXxkxveb8tHElMxB7PblETZ1G2zDe1eNbBMkVEGdsDl4k3d709uAk86RPY3k2b5lZOIzbxnN2c5xk+LM9jv8PZaIBFkSwWBw9CRWwlLJ3fVZPTuYkUyLT+KPP7VBGAQmGev5tHTGMUrbvDU/pyeNn1oOQLQ74d6yeA51Hyfnn6FWDtmF8bueyXvzx+5XB/3d6/4rbfL+8Bz8Ne++X+s4z5pp/QLrtf/vJ47/B3U/L9Q/Fp4P87fn7R/c+NfwQYAFx9eFOvgdoSAAAAAElFTkSuQmCC"/></p><style>.base64.sign {display: none;}</style><p id="P0206_7" class="formattext topleveltext indenttext" align="justify">- между спецификацией проекта программного обеспечения и спецификациями испытаний модуля и интеграции;<br/><br/></p><p id="P0206_8" class="formattext topleveltext indenttext" align="justify">- между требованиями к интеграции аппаратных средств/программного обеспечения проекта системы и программного обеспечения и спецификациями испытаний интеграции аппаратных средств/программного обеспечения;<br/><br/></p><p id="P0206_9" class="formattext topleveltext indenttext" align="justify">- между спецификацией требований к программному обеспечению системы безопасности и планом подтверждения соответствия программного обеспечения безопасности системы;<br/><br/></p><p id="P0206_10" class="formattext topleveltext indenttext" align="justify">- между спецификацией требований к программному обеспечению системы безопасности и планом модификации программного обеспечения (в том числе повторной проверкой и повторного подтверждения соответствия);<br/><br/></p><p id="P0206_11" class="formattext topleveltext indenttext" align="justify">- между спецификацией проекта программного обеспечения и планом верификации программного обеспечения (включая верификацию данных);<br/><br/></p><p id="P0206_12" class="formattext topleveltext indenttext" align="justify">- между требованиями МЭК 61508-3, раздел 8, и планом оценки функциональной безопасности программного обеспечения.<br/><br/></p><p id="P0206_13" class="formattext topleveltext indenttext" align="justify">Обратная прослеживаемость в основном связана с проверкой, насколько корректно любым требованием обосновывается каждое реализационное решение (реализация понимается в широком контексте, а не только реализация кода). Если такое обоснование отсутствует, то реализация будет содержать что-то не столь необходимое, что приведет к увеличению сложности, но не обязательно удовлетворит любому реальному требованию к системе, связанной с безопасностью. Обратная прослеживаемость важна в нескольких точках жизненного цикла системы безопасности:<br/><br/></p><p id="P0206_14" class="formattext topleveltext indenttext" align="justify">- между требованиями к системе безопасности и предполагаемыми потребностями безопасности;<br/><br/></p><p id="P0206_15" class="formattext topleveltext indenttext" align="justify">- между архитектурой программного обеспечения и спецификацией требований к программному обеспечению системы безопасности;<br/><br/></p><p id="P0206_16" class="formattext topleveltext indenttext" align="justify">- между детальным проектом программного обеспечения и архитектурой программного обеспечения;<br/><br/></p><p id="P0206_17" class="formattext topleveltext indenttext" align="justify">- между программным кодом и детальным проектом программного обеспечения;<br/><br/></p><p id="P0206_18" class="formattext topleveltext indenttext" align="justify">- между планом подтверждения соответствия программного обеспечения безопасности системы и спецификацией требований к программному обеспечению системы безопасности;<br/><br/></p><p id="P0206_19" class="formattext topleveltext indenttext" align="justify">- между планом модификации программного обеспечения и спецификацией требований к программному обеспечению системы безопасности;<br/><br/></p><p id="P0206_20" class="formattext topleveltext indenttext" align="justify">- между планом верификации программного обеспечения (включая верификацию данных) и спецификацией проекта программного обеспечения.<br/><br/></p><p id="P0206_21" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0206_22" class="formattext topleveltext indenttext" align="justify">Requirements Engineering. Е. Hull, K. Jackson, J. Dick. Springer, 2005, ISBN 1852338792, 9781852338794.<br/><br/></p><p id="P0208" class="formattext topleveltext indenttext" align="justify"><b>C.2.12 Проектирование программного обеспечения, не сохраняющего состояние (или проектирование ПО, сохраняющего ограниченное описание состояния)</b><br/><br/></p><p id="P0208_1" class="formattext topleveltext indenttext" align="justify">Цель. Ограничить сложность поведения программного обеспечения.<br/><br/></p><p id="P0208_2" class="formattext topleveltext indenttext" align="justify">Описание. Рассмотрим программу, которая обрабатывает последовательность транзакций: она получает последовательность входных данных и для каждого из них вычисляет выходные данные. Программа может также запоминать некоторые или все состояния в процессе вычисления и может также учитывать эти состояния при вычислении результата для следующих входных данных.<br/><br/></p><p id="P0208_3" class="formattext topleveltext indenttext" align="justify">Если выходные данные программы полностью определяются только входными, то говорят, что такая программа работает без запоминания или является программой, не сохраняющей состояние. Каждая транзакция входных/выходных данных полна в том смысле, что на любую транзакцию никак не влияет любая, более ранняя транзакция, и конкретные входные данные всегда приводят к тем же самым связанным с ними выходным данным.<br/><br/></p><p id="P0208_4" class="formattext topleveltext indenttext" align="justify">Если программа при вычислении входных данных учитывает, кроме входных данных, также и состояние, которое она запомнила в результате предыдущих вычислений, то такая программа обладает более сложным поведением, потому что в различных случаях она может давать различные выходные данные для одних и тех же входных данных. Результат для конкретных входных данных может зависеть от контекста (то есть от предыдущих входных и выходных данных), в котором они обрабатываются. Необходимо также отметить, что в некоторых приложениях (обычно коммуникационные системы) поведение программы может быть особенно чувствительно к изменениям в сохраненном состоянии, которые могут произойти или непреднамеренно или злонамеренно.<br/><br/></p><p id="P0208_5" class="formattext topleveltext indenttext" align="justify">Проектирование с несохраняющимися состояниями (или с сохранением ограниченного описания состояний) является общим подходом, направленным на минимизацию возможной сложности поведения программного обеспечения, исключая или уменьшая использование информации о состоянии при проектировании программного обеспечения.<br/><br/></p><p id="P0208_6" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0208_7" class="formattext topleveltext indenttext" align="justify">Introduction to Automata Theory, Languages, and Computation (3rd Edition). J. Hopcroft, R. Motwani, J. Ullman, Addison-Wesley Longman Publishing Co, 2006, ISBN:0321462254.<br/><br/></p><p id="P0208_8" class="formattext topleveltext indenttext" align="justify">Stateless connections. T. Aura, P. Nikander. In Proc International Conference on Information And Communications Security (ICICS'97), ed Yongfei Han. Springer, 1997, ISBN 354063696X, 9783540636960.<br/><br/></p><p id="P020A" class="formattext topleveltext indenttext" align="justify"><b>C.2.13 Численный анализ в автономном режиме</b><br/><br/></p><p id="P020A_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблица А.9).<br/><br/><br/></p><p id="P020A_2" class="formattext topleveltext indenttext" align="justify">Цель. Гарантировать точность числовых вычислений.<br/><br/></p><p id="P020A_3" class="formattext topleveltext indenttext" align="justify">Описание. Числовая погрешность может возникнуть при вычислении математической функции как следствие использования конечных представлений идеальных функций и чисел. Ошибка усечения появляется, когда функция аппроксимируется конечным числом членов бесконечного ряда, таким как ряд Фурье. Для представления в реальном компьютере вещественных чисел с конечной точностью, вводится их погрешность округления. Если выполняются какие-либо, кроме самых простейших, вычисления с плавающей точкой, то должна быть проверена обоснованность вычисления, чтобы гарантировать, что точность, требуемая приложением, фактически достигнута.<br/><br/></p><p id="P020A_4" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P020A_5" class="formattext topleveltext indenttext" align="justify">Guide to Scientific Computing. P.R. Turner. CRC Press, 2001, ISBN 0849312426, 9780849312427.<br/><br/></p><p id="P020C" class="formattext topleveltext indenttext" align="justify"><b>C.2.14 Диаграммы последовательности сообщений</b><br/><br/></p><p id="P020C_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблицы В.7 и С.17).<br/><br/><br/></p><p id="P020C_2" class="formattext topleveltext indenttext" align="justify">Цель. Помочь получению требований к системе на ранних стадиях проектирования программного обеспечения, включая стадии формирования требований и проектирования архитектуры программного обеспечения. В UML это называется &quot;Диаграмма последовательности системы&quot; (System Sequence Diagram).<br/><br/></p><p id="P020C_3" class="formattext topleveltext indenttext" align="justify">Описание. Диаграмма последовательности сообщений - графический механизм для описания поведения системы с точки зрения коммуникаций между агентами системы (агентом может быть человек, компьютерная система или элемент либо объект программного обеспечения, в зависимости от стадии проектирования). Для каждого агента на схеме представлен вертикальный &quot;жизненный путь&quot;, а стрелки между ними используются, чтобы представить сообщения. Действия по получении сообщений можно дополнительно показать на схемах в виде прямоугольников. Набор сценариев (описывающих и требуемое и нежелательное поведение) создается как спецификация необходимого поведения системы. Эти сценарии имеют несколько применений. Может быть проведена их анимация, чтобы продемонстрировать поведение системы конечным пользователям. Они могут быть преобразованы в исполнимую реализацию системы. Они могут сформировать основу тестовых данных.<br/><br/></p><p id="P020C_4" class="formattext topleveltext indenttext" align="justify">UML содержит расширения обычной концепции диаграммы последовательности сообщений в виде конструкций выбора и итерации, которые позволяют сценариям выполнять условные переходы и циклы, обеспечивая более компактную нотацию. Могут быть также определены подсхемы, на которые можно сослаться из нескольких диаграмм последовательностей более высокого уровня. Также могут быть представлены таймер и внешние события.<br/><br/></p><p id="P020C_5" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P020C_6" class="formattext topleveltext indenttext" align="justify">&quot;Message Sequence charts&quot;, D. Harel, P. Thiagarajan. In UML for Real: Design of Embedded Real-Time Systems. ed. L. Lavagno. Springer, 2003, ISBN 1402075014, 9781402075018.<br/><br/></p><p id="P020C_7" class="formattext topleveltext indenttext" align="justify">ISO/IEC 19501:2005, Information technology - Open Distributed Processing - Unified Modeling Language (UML) Version 1.4.2.<br/><br/></p><h3 id="P020F" class="formattext topleveltext indenttext" align="justify" title-level="3"><b>C.3 Архитектурное проектирование</b><br/><br/></h3><p id="P0211" class="formattext topleveltext indenttext" align="justify"><b>С.3.1 Обнаружение и диагностика сбоев</b><br/><br/></p><p id="P0211_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблица А.2).<br/><br/><br/></p><p id="P0211_2" class="formattext topleveltext indenttext" align="justify">Цель. Обнаружение сбоев в системе, которые могут привести к отказам и тем самым обеспечить основу для контрмер, направленных на минимизацию числа последующих сбоев.<br/><br/></p><p id="P0211_3" class="formattext topleveltext indenttext" align="justify">Описание. Обнаружение сбоев представляет собой действие по проверке системы на наличие ошибочных состояний (обусловленных сбоями в проверяемой (под)системе). Основная цель обнаружения сбоев состоит в том, чтобы предотвратить появление неверных результатов. Система, действующая в сочетании с параллельно работающими компонентами, останавливающими управление, в случае, если она обнаруживает, что ее собственные результаты некорректны, называется самопроверяемой.<br/><br/></p><p id="P0211_4" class="formattext topleveltext indenttext" align="justify">Обнаружение сбоев основывается на принципах избыточности [в основном при обнаружении сбоев аппаратных средств (см. МЭК 61508-2, приложение А)] и разнообразия (программные ошибки). Необходим один из способов голосования для определения корректности результатов. Применимы специальные методы, к которым относятся программирование утверждений, программирование <img class="base64" src="data:image;base64,R0lGODdhEwATAIABAAAAAP///ywAAAAAEwATAAACKIyPqcvtDw+YaNIGUn7XbBx8ITd60IaSZgmaIvNlr/J2ixVH+s73TQEAOw==" width="19" height="19"/>-версий и различные методы контроля. Для аппаратных средств: введение дополнительных сенсоров; контуров регулирования; кодов, проверяющих ошибки, и др.<br/><br/></p><p id="P0211_5" class="formattext topleveltext indenttext" align="justify">Обнаружение сбоев может обеспечиваться проверками в области значений или временной области на различных уровнях, особенно на физическом уровне (температура, напряжение и  т.п.), логическом (коды, обнаруживающие ошибки), функциональном (утверждения) или внешнем (проверки достоверности). Результаты этих проверок могут быть сохранены и связаны с данными, на которые повлиял сбой, с тем чтобы обеспечить возможность отслеживания отказов.<br/><br/></p><p id="P0211_6" class="formattext topleveltext indenttext" align="justify">Сложные системы состоят из подсистем. Эффективность обнаружения ошибок, диагностики и компенсации ошибок зависит от сложности взаимодействия между подсистемами, влияющими на распространение ошибок.<br/><br/></p><p id="P0211_7" class="formattext topleveltext indenttext" align="justify">Диагностику ошибок следует применять на уровне самых малых подсистем, поскольку подсистемы меньших размеров допускают более детальную диагностику ошибок (обнаружение ошибочных состояний).<br/><br/></p><p id="P0211_8" class="formattext topleveltext indenttext" align="justify">Интегрированные информационные системы уровня предприятия могут обычным способом передавать состояния безопасности системы, в том числе информацию диагностического тестирования, другим управляющим системам. При обнаружении некорректного поведения оно может быть выделено и использовано для запуска корректирующих действий до возникновения опасной ситуации. При появлении инцидента документирование такого некорректного поведения может способствовать его последующему анализу.<br/><br/></p><p id="P0211_9" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0211_10" class="formattext topleveltext indenttext" align="justify">Dependability of Critical Computer Systems 1. F.J. Redmill, Elsevier Applied Science, 1988, ISBN 1-85166-203-0.<br/><br/></p><p id="P0213" class="formattext topleveltext indenttext" align="justify"><b>C.3.2 Коды обнаружения и исправления ошибок</b><br/><br/></p><p id="P0213_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблица А.2).<br/><br/><br/></p><p id="P0213_2" class="formattext topleveltext indenttext" align="justify">Цель. Обнаружение и исправление ошибок в чувствительной к ним информации.<br/><br/></p><p id="P0213_3" class="formattext topleveltext indenttext" align="justify">Описание. Для информации, состоящей из <img class="base64" src="data:image;base64,R0lGODdhDQAPAIABAAAAAP///ywAAAAADQAPAAACGYyPqcvtAAxksdIYcJqZHo1o1vaBzommSwEAOw==" width="13" height="15"/> битов, генерируется закодированный блок из <img class="base64" src="data:image;base64,R0lGODdhDQATAIABAAAAAP///ywAAAAADQATAAACHIyPqcvtAcCDUzp7YcRI8uRdUfZ1Rwie5cS2UwEAOw==" width="13" height="19"/> битов, который позволяет обнаруживать и исправлять <img class="base64" src="data:image;base64,R0lGODdhDAANAIABAAAAAP///ywAAAAADAANAAACEoyPqcsHEB6TUMlWcYub9w8yBQA7" width="12" height="13"/> ошибок. Примерами могут служить код Хэмминга и полиномиальные коды.<br/><br/></p><p id="P0213_4" class="formattext topleveltext indenttext" align="justify">Следует отметить, что в системах, связанных с безопасностью, чаще необходимо уничтожить ошибочные данные, чем пытаться исправлять их, поскольку лишь заранее определенная часть ошибок может быть исправлена.<br/><br/></p><p id="P0213_5" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0213_6" class="formattext topleveltext indenttext" align="justify">Fundamentals of Error-correcting Codes, W. Huffman, V. Pless. Cambridge University Press, 2003, ISBN 0521782805, 9780521782807<br/><br/></p><p id="P0215" class="formattext topleveltext indenttext" align="justify"><b>C.3.3 Программирование с проверкой ошибок</b><br/><br/></p><p id="P0215_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-2 (таблица А.18) и в МЭК 61508-3 (таблица А.2).<br/><br/><br/></p><p id="P0215_2" class="formattext topleveltext indenttext" align="justify">Цель. Обнаружение ошибок, оставшихся при проектировании программных средств, в процессе выполнения программ в целях предотвращения критичных для безопасности отказов систем, и продолжение правильного выполнения программы.<br/><br/></p><p id="P0215_3" class="formattext topleveltext indenttext" align="justify">Описание. В методе программирования утверждений уже заложена идея проверки предусловий (до выполнения последовательности операторов начальные условия проверяют на соответствие) и постусловий (проверяют результаты после выполнения последовательности операторов). Если предусловия или постусловия не соблюдаются, то выдается сообщение об ошибке.<br/><br/></p><p id="P0215_4" class="formattext topleveltext indenttext" align="justify"><b><i>Пример -</i></b><br/><br/></p><p id="P0215_5" class="formattext topleveltext indenttext" align="justify"><b><i>assert &lt; pre-condition&gt;;</i></b><br/></p><p id="P0215_6" class="formattext topleveltext indenttext" align="justify"><b><i>action 1;</i></b><br/></p><p id="P0215_7" class="formattext topleveltext indenttext" align="justify"><b><i>...............</i></b><br/></p><p id="P0215_8" class="formattext topleveltext indenttext" align="justify"><b><i>action x;</i></b><br/></p><p id="P0215_9" class="formattext topleveltext indenttext" align="justify"><b><i>assert &lt; post-condition&gt;;</i></b><br/><br/></p><p id="P0215_10" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0215_11" class="formattext topleveltext indenttext" align="justify">Exploiting Traces in Program Analysis. A. Groce, R. Joshi. Lecture Notes in Computer Science, vol. 3920, Springer Berlin/Heidelberg, 2006, ISBN 978-3-540-33056-1.<br/><br/></p><p id="P0215_12" class="formattext topleveltext indenttext" align="justify">Software Development - A Rigorous Approach. С.В. Jones, Prentice-Hall, 1980.<br/><br/></p><p id="P0217" class="formattext topleveltext indenttext" align="justify"><b>C.3.4 Методы контроля</b><br/><br/></p><p id="P0217_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблица А.2).<br/><br/><br/></p><p id="P0217_2" class="formattext topleveltext indenttext" align="justify">Цель. Защита от не обнаруженных на этапах спецификации и реализации ошибок в программных средствах, которые неблагоприятно влияют на их безопасность.<br/><br/></p><p id="P0217_3" class="formattext topleveltext indenttext" align="justify">Описание. Различают два подхода реализации контроля: (1) процесс контроля и контролируемая функция реализованы на одном компьютере с некоторой гарантией независимости между ними; и (2) процесс контроля и контролируемая функция реализованы на разных компьютерах.<br/><br/></p><p id="P0217_4" class="formattext topleveltext indenttext" align="justify">Метод, в котором процесс контроля и контролируемая функция реализованы на разных компьютерах (имеющих разную спецификацию), называется методом внешнего контроля. Данный метод направлен только на то, чтобы гарантировать, что основным компьютером выполняются безопасные, но не обязательно корректирующие действия. Метод внешнего контроля обеспечивает непрерывный контроль основного компьютера и предотвращает вхождение системы в опасное состояние. Кроме того, если обнаружится, что основной компьютер вошел в потенциально опасное состояние, система должна возвратиться обратно в безопасное состояние с помощью либо средств внешнего контроля, либо основного компьютера.<br/><br/></p><p id="P0217_5" class="formattext topleveltext indenttext" align="justify">Аппаратные средства и программное обеспечение средств внешнего контроля следует классифицировать и квалифицировать в соответствии с подходящим УПБ.<br/><br/></p><p id="P0217_6" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0217_7" class="formattext topleveltext indenttext" align="justify">Requirements based Monitors for Real-Time Systems, D. Peters, D. Parnas. IEEE Transactions on Software Engineering, vol. 28, no. 2, 2002.<br/><br/></p><p id="P0219" class="formattext topleveltext indenttext" align="justify"><b>C.3.5 Многовариантное программирование</b><br/><br/></p><p id="P0219_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблица А.2).<br/><br/><br/></p><p id="P0219_2" class="formattext topleveltext indenttext" align="justify">Цель. Обнаружение и наложение маски при выполнении программ на невыявленные на этапах проектирования и реализации ошибки программных средств для предотвращения критичных для безопасности отказов системы и продолжения ее правильной работы.<br/><br/></p><p><img class="base64 sign" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZIAAAARCAMAAADAD9oKAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MTg4Q0U3ODQ0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MTg4Q0U3ODU0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoxODhDRTc4MjRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDoxODhDRTc4MzRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pos3t18AAAAzUExURfX19SQkJOrq6oeHh7y8vD8/P9/f31RUVMjIyLCwsHh4eJaWlmdnZ6Ojo9TU1AAAAP////kimdMAAAWSSURBVHja7FiJcuQoDAVzGcz1/1+7TwLRuDs9mZ2karZqQ1ViGz90PUngVv1nfMOo9fg2WarnNkf9FGxMHdDkf1jo3bXBg7o0YhIkfrXV0npvBfd48y94HQtV97XWZvBPfbpG29oikGfQ6oeRs4WLb4K2CGNq5wsltpX6B5TQYEa5/u6h9rdn31QdtXS0iKX1WZ360/o9Pl/3NmVq/ahk/cfwZ0X+bSL6T01Kxmq6Fj0MSDNPj+atGzF1+Y17z9IZMRfulHiH+ivMFvE7nm2ffQ26Q5+U0AKLatWUGFm63kU3SJycuwqNLgNJ1ONf6crorUNyEySMStQLlegNgSuSmiT5agizm0YyZwPNbEXLM64y2X0YcGgdN3ytU9FaLDCecHbCyFWVh0kjMvBEHK+rvx/tVIgOWSoTcZrRa+aVJxeOuLc5nG8Oj2cjCzdKDm1Uj9BCSFeO7sKBgKCxRWpXKNAiFtV2njBAGeqm2QBQaZKCjjDCA+vqnZJD802sAzu9q4EwRtde4djUG4kJeFObpsag4cXNNJKJejRY7pVO9EJiQf2XRJLlBEcW1Toooc48FcniBeN2nOALwwzMDXhDJv2CkoKENkS/NKzu0p74rRyOk0vcezgs0iXQhLDixE4J6YAALgUqoEq6VKpih0KosOuUUihxM+eGo6KIA3DEaTI8oJS7UZIybnhmOVX1wCiqLJSYmnr52WjShadTA7Obtsyl2lP22PquxG9kJ1VbSWN2gEXRfF4wlnri36xnTJBYC+R7ShyX17HNDIcXJSg8ddMqDi/p0+HOCGNfKclwPmdHBsVgp9mbHaemuwBMwtvmCK2pQqtwdpakiZIQg7pTAitwc+m6OVWyWFhnzQy9aMrcDZASSAJjgNlMo5R4UIJ1xbhnSsYr+p/LRslS1FfshQFIpb4v06WRvgBky4VfseOmPqy3zaKiZqp/SEmpOqhdqzi8pE+H6/2wu1PiCg9AkvOvlJi0r2ZbS7FooaMpdo8WYy6ixPFRZKcEE9Iz115irhdKWC/y1VquyIpWqU+i5GEapcRWJaGFFN9T4s7foyRQdqmNkqHvGJmn82AtUzed1s9vB63U6jj6ulOCnnbtWsXhJX06/J6S5LbDmKYuy/W11rgbobKpdRvmtNFKGpfS142SqEcL8CE99hIKV+ZmbDnr/NQL2Slx46wxoDSB2U27NS77eN4oGZaj91G6PChZiubzgo2+i9AKJbEd/S5yKA5ZAnCwLL6IcfYe2aHWb1rF4SV9OjwQ9XylZGwwORFSIeLUakYnHEVAgh6U0D7elY49C1OZNrM09pIC8EaJtnyjdHiIqE4qiY+K2YleProNrUcLhk8Lm2k3SgrF/KVKhuUQVUzfKFmK5vOCvVBytMSb69NeolwS66954oXTvnF2en3b3XmlIo3LPXF4SReHXZ5b3zMlCKcpAVse9z38XXh2kvo9htvuppy+LqeP0LgvBo/IpIJ+b/kQrGUDaM4XPvlBR9IPVq3mlkDldKIJ5k0vnGyzNh2myYvdtJ0S3wLtJeZOybT8uEabQ3kPSkSRUDRhs3HpI2uhKwKZKC8elADStJcASJOg7IcrF9BZvVBCPVi0bg6LdHF4IOqNkvmNaVM2iMWBHqoKLD9TvghAE92ecjdXxkxveb8tHElMxB7PblETZ1G2zDe1eNbBMkVEGdsDl4k3d709uAk86RPY3k2b5lZOIzbxnN2c5xk+LM9jv8PZaIBFkSwWBw9CRWwlLJ3fVZPTuYkUyLT+KPP7VBGAQmGev5tHTGMUrbvDU/pyeNn1oOQLQ74d6yeA51Hyfnn6FWDtmF8bueyXvzx+5XB/3d6/4rbfL+8Bz8Ne++X+s4z5pp/QLrtf/vJ47/B3U/L9Q/Fp4P87fn7R/c+NfwQYAFx9eFOvgdoSAAAAAElFTkSuQmCC"/></p><style>.base64.sign {display: none;}</style><p id="P0219_3" class="formattext topleveltext indenttext" align="justify">Описание. При многовариантном программировании заданная программная спецификация проектируется и реализуется различными способами <img class="base64" src="data:image;base64,R0lGODdhEwATAIABAAAAAP///ywAAAAAEwATAAACKIyPqcvtDw+YaNIGUn7XbBx8ITd60IaSZgmaIvNlr/J2ixVH+s73TQEAOw==" width="19" height="19"/> раз. Одни и те же входные значения поступают в <img class="base64" src="data:image;base64,R0lGODdhEwATAIABAAAAAP///ywAAAAAEwATAAACKIyPqcvtDw+YaNIGUn7XbBx8ITd60IaSZgmaIvNlr/J2ixVH+s73TQEAOw==" width="19" height="19"/> версий и сравниваются результаты, выданные <img class="base64" src="data:image;base64,R0lGODdhEwATAIABAAAAAP///ywAAAAAEwATAAACKIyPqcvtDw+YaNIGUn7XbBx8ITd60IaSZgmaIvNlr/J2ixVH+s73TQEAOw==" width="19" height="19"/> версиями. Если результат определяется как правильный, он поступает на выходы компьютера.<br/><br/></p><p id="P0219_4" class="formattext topleveltext indenttext" align="justify">Важным требованием является то, что в некотором смысле <img class="base64" src="data:image;base64,R0lGODdhEwATAIABAAAAAP///ywAAAAAEwATAAACKIyPqcvtDw+YaNIGUn7XbBx8ITd60IaSZgmaIvNlr/J2ixVH+s73TQEAOw==" width="19" height="19"/> версий независимы друг от друга, поэтому они не все одновременно перестают правильно работать по общей причине. Независимость версий, являющуюся основой для многовариантного программирования, на практике довольно трудно достичь и продемонстрировать.<br/><br/></p><p id="P0219_5" class="formattext topleveltext indenttext" align="justify"><img class="base64" src="data:image;base64,R0lGODdhEwATAIABAAAAAP///ywAAAAAEwATAAACKIyPqcvtDw+YaNIGUn7XbBx8ITd60IaSZgmaIvNlr/J2ixVH+s73TQEAOw==" width="19" height="19"/> версий могут выполняться параллельно на различных компьютерах, либо все версии могут выполняться на одном компьютере с последующим сравнением полученных результатов на том же компьютере. Для этих <img class="base64" src="data:image;base64,R0lGODdhEwATAIABAAAAAP///ywAAAAAEwATAAACKIyPqcvtDw+YaNIGUn7XbBx8ITd60IaSZgmaIvNlr/J2ixVH+s73TQEAOw==" width="19" height="19"/> результатов могут быть использованы различные стратегии сравнения, и в зависимости от заданных требований применяются следующие стратегии:<br/><br/></p><p id="P0219_6" class="formattext topleveltext indenttext" align="justify">- если система находится в безопасном состоянии, можно потребовать полного согласия (все <img class="base64" src="data:image;base64,R0lGODdhEwATAIABAAAAAP///ywAAAAAEwATAAACKIyPqcvtDw+YaNIGUn7XbBx8ITd60IaSZgmaIvNlr/J2ixVH+s73TQEAOw==" width="19" height="19"/> результатов одинаковы); в противном случае используется выходное значение, которое заставит систему перейти в безопасное состояние. Для простых пошаговых систем сравнение может обеспечить безопасность. В этом случае безопасное действие может быть разбито по шагам, если какая-либо версия реализует пошаговые операции. Этот подход обычно используется только для двух версий (<img class="base64" src="data:image;base64,R0lGODdhEwATAIABAAAAAP///ywAAAAAEwATAAACKIyPqcvtDw+YaNIGUn7XbBx8ITd60IaSZgmaIvNlr/J2ixVH+s73TQEAOw==" width="19" height="19"/>=2);<br/><br/></p><p id="P0219_7" class="formattext topleveltext indenttext" align="justify">- для систем, находящихся в опасном состоянии, могут быть реализованы стратегии мажоритарного сравнения. В случаях, если отсутствует общее согласие, могут использоваться вероятностные подходы с тем, чтобы максимизировать вероятность выбора правильного значения, например, принять среднее значение, временно зафиксировать выходы, пока не будет достигнуто согласие и т.п.<br/><br/></p><p id="P0219_8" class="formattext topleveltext indenttext" align="justify">Данный метод не устраняет ошибок, не выявленных при проектировании программ, а также ошибок в интерпретации спецификации, однако он является средством для обнаружения и маскирования ошибок, прежде чем они смогут повлиять на безопасность.<br/><br/></p><p id="P0219_9" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0219_10" class="formattext topleveltext indenttext" align="justify">Modelling software design diversity - a review, B. Littlewood, P. Popov, L. Strigini. ACM Computing Surveys, vol. 33, No. 2, 2001.<br/><br/></p><p id="P0219_11" class="formattext topleveltext indenttext" align="justify">The N-Version Approach to Fault-Tolerant Software, A. Avizienis, IEEE Transactions on Software Engineering, vol. SE-11, No. 12, pp.1491-1501, 1985.<br/><br/></p><p id="P0219_12" class="formattext topleveltext indenttext" align="justify">An experimental evaluation of the assumption of independence in multi-version programming, J.С. Knight, N.G. Leveson. IEEE Transactions on Software Engineering, vol. SE-12, No. 1, 1986.<br/><br/></p><p id="P0219_13" class="formattext topleveltext indenttext" align="justify">In Search of Effective Diversity: a Six Language Study of Fault-Tolerant Flight Control Software. A. Avizienis, M.R. Lyu and W. Schutz. 18<img class="base64" src="data:image;base64,R0lGODdhDwAXAIABAAAAAP///ywAAAAADwAXAAACJIyPqcvtHwBw01R2r5J1apR5S2aNR2eW0ehJ0QfF8kzX9o0fBQA7" width="15" height="23"/> Symposium on Fault-Tolerant Computing, Tokyo, Japan, 27-30 June 1988, IEEE Computer Society Press, 1988, ISBN 0-8186-0867-6.<br/><br/></p><p id="P021B" class="formattext topleveltext indenttext" align="justify"><b>C.3.6 Восстановление предыдущего состояния</b><br/><br/></p><p id="P021B_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблица А.2).<br/><br/><br/></p><p id="P021B_2" class="formattext topleveltext indenttext" align="justify">Цель. Обеспечение исправления функциональных операций при наличии одной или нескольких ошибок.<br/><br/></p><p id="P021B_3" class="formattext topleveltext indenttext" align="justify">Описание. При обнаружении ошибки система возвращается в первоначальное внутреннее состояние, правильность которого была подтверждена ранее. Данный метод предполагает частое сохранение внутреннего состояния в так называемых четко определенных контрольных точках. Сохранение может быть выполнено глобально (для всей базы данных) или частично (для изменений только между контрольными точками). После этого система должна устранить изменения, произошедшие за это время путем занесения в журнал (аудиторское отслеживание действий), компенсации (все результаты этих изменений аннулируются) или внешнего (ручного) способа.<br/><br/></p><p id="P021B_4" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P021B_5" class="formattext topleveltext indenttext" align="justify">Looking into Compensable Transactions. Jing Li, Huibiao Zhu, Geguang Pu, Jifeng He. In Software Engineering Workshop, 2007. SEW 2007. IEEE, 2007, ISBN 978-0-7695-2862-5.<br/><br/></p><p id="P021B_6" class="formattext topleveltext indenttext" align="justify">Software Fault Tolerance (Trends in Software, No. 3), M.R. Lyu (ed.), John Wiley &amp; Sons, April 1995, ISBN 0471950688.<br/><br/></p><p id="P021D" class="formattext topleveltext indenttext" align="justify"><b>C.3.7 Механизмы повторных попыток парирования сбоя</b><br/><br/></p><p id="P021D_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблица А.2).<br/><br/><br/></p><p id="P021D_2" class="formattext topleveltext indenttext" align="justify">Цель. Парирование обнаруженного сбоя с помощью механизмов повторных попыток.<br/><br/></p><p id="P021D_3" class="formattext topleveltext indenttext" align="justify">Описание. В случае обнаружения сбоя или ошибочного условия предпринимаются попытки парирования сбоя или восстановления ситуации путем повторного выполнения того же кода. Восстановление с помощью повторной попытки может быть полным в виде перезагрузки и повторного пуска процедуры, либо небольшим в виде перепланирования и повторного пуска задачи после выполнения блокировки по времени программы или управляющего действия задачи. Методы повторной попытки широко используются при коммуникационных сбоях или при восстановлении от ошибок, и условия повторной попытки могут быть отделены флажками от ошибки протокола связи (контрольная сумма и т.д.) или от подтверждающего ответа блокировки по времени коммуникации.<br/><br/></p><p id="P021D_4" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P021D_5" class="formattext topleveltext indenttext" align="justify">Reliable Computer Systems: Design and Evaluation, D.P. Siewiorek and R.S. Schwartz, A.K. Peters Ltd., 1998, ISBN 156881092X.<br/><br/></p><p id="P021F" class="formattext topleveltext indenttext" align="justify"><b>C.3.8 Постепенное отключение функций</b><br/><br/></p><p id="P021F_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблица А.2).<br/><br/><br/></p><p id="P021F_2" class="formattext topleveltext indenttext" align="justify">Цель. Обеспечение пригодности наиболее критичных системных функций, несмотря на отказы, путем игнорирования наименее критичных функций.<br/><br/></p><p id="P021F_3" class="formattext topleveltext indenttext" align="justify">Описание. Данный метод устанавливает приоритеты для различных функций, выполняемых системой. Проект создаваемой системы гарантирует, что в случае недостаточности ресурсов для выполнения всех системных функций функции высшего приоритета будут выполнены в предпочтение функциям более низкого приоритета. Например, функции регистрации ошибки и события могут оказаться задачей более низкого приоритета, чем системные функции управления, и в этом случае управление системой будет продолжаться, даже если аппаратные средства из-за регистрации ошибки окажутся неработоспособными. Более того, если аппаратные средства управления системой окажутся неработоспособными, а аппаратные средства регистрации ошибок останутся работоспособными, то аппаратные средства регистрации ошибок возьмут на себя функцию управления.<br/><br/></p><p id="P021F_4" class="formattext topleveltext indenttext" align="justify">Данные соображения относятся в основном к аппаратным средствам, но они применимы также и к системе в целом, включая программное обеспечение. Данные соображения должны учитываться, начиная с самых ранних этапов проектирования.<br/><br/></p><p id="P021F_5" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P021F_6" class="formattext topleveltext indenttext" align="justify">Towards the Integration of Fault, Resource, and Power Management, T. Siridakis. In Computer Safety, Reliability, and Security: 23rd International Conference, SAFECOMP 2004. Eds. Maritta Heisel et al. Springer, 2004, ISBN 3540231765, 9783540231769.<br/><br/></p><p id="P021F_7" class="formattext topleveltext indenttext" align="justify">Achieving Critical System Survivability Through Software Architectures, E.A. Strunk. Springer Berlin/Heidelberg, 2004, ISBN 978-3-540-23168-4.<br/><br/></p><p id="P021F_8" class="formattext topleveltext indenttext" align="justify">The Evolution of Fault-Tolerant Computing. Vol. 1 of Dependable Computing and Fault-Tolerant Systems, Edited by A. Avizienis, H. Kopetz and J. С Laprie, Springer Verlag, 1987, ISBN 3-211-81941-X.<br/><br/></p><p id="P021F_9" class="formattext topleveltext indenttext" align="justify">Fault Tolerance, Principle and Practices. T. Anderson and P.A. Lee, Vol. 3 of Dependable Computing and Fault-Tolerant Systems, Springer Verlag, 1987, ISBN 3-211-82077-9.<br/><br/></p><p id="P0221" class="formattext topleveltext indenttext" align="justify"><b>C.3.9 Исправление ошибок методами искусственного интеллекта</b><br/><br/></p><p id="P0221_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблица А.2).<br/><br/><br/></p><p id="P0221_2" class="formattext topleveltext indenttext" align="justify">Цель. Способность гибко реагировать на возможные угрозы безопасности, используя сочетания методов и моделей процессов, а также некоторые способы безопасности в режиме онлайн и анализа надежности.<br/><br/></p><p id="P0221_3" class="formattext topleveltext indenttext" align="justify">Описание. Для различных каналов связи системы прогнозирование (вычисление тенденций), исправление ошибок, обслуживание и контролирующие действия могут достаточно эффективно поддерживаться системами, основанными на методах искусственного интеллекта (AI). Правила для таких систем могут быть созданы непосредственно из спецификаций и проверены на соответствие. С помощью методов искусственного интеллекта некоторые ошибки общего характера, попадающие в спецификации, для устранения которых уже существуют некоторые правила проектирования и реализации, могут быть исключены, особенно при представлении комбинаций моделей и методов функциональным или описательным способом.<br/><br/></p><p id="P0221_4" class="formattext topleveltext indenttext" align="justify">Методы выбираются так, чтобы ошибки могли быть устранены и влияние отказов минимизировано для обеспечения требуемой полноты безопасности.<br/><br/></p><p id="P0221_5" class="formattext topleveltext indenttext" align="justify">Примечание - Предупреждение об исправлении ошибочных данных см. С.3.2 и об отрицательных рекомендациях применения данного метода - МЭК 61508-3 (таблица А.2, пункт 5).<br/><br/><br/></p><p id="P0221_6" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0221_7" class="formattext topleveltext indenttext" align="justify">Fault Diagnosis: Models, Artificial Intelligence, Applications. J. Korbicz, J. Koscielny, Z. Kowalczuk, W. Cholewa. Springer, 2004, ISBN 3540407677, 9783540407676.<br/><br/></p><p id="P0223" class="formattext topleveltext indenttext" align="justify"><b>C.3.10 Динамическая реконфигурация</b><br/><br/></p><p id="P0223_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблица А.2).<br/><br/><br/></p><p id="P0223_2" class="formattext topleveltext indenttext" align="justify">Цель. Обеспечение функциональности системы, несмотря на внутренний отказ.<br/><br/></p><p id="P0223_3" class="formattext topleveltext indenttext" align="justify">Описание. Логическая архитектура системы должна быть такой, чтобы ее можно было реализовать на подмножестве доступных средств системы. Логическая архитектура должна быть способна к обнаружению отказа в физических средствах и дальнейшей повторной реализации логической архитектуры на другом подмножестве доступных средств, остающихся функционирующими. Несмотря на то, что данный метод в основном традиционно ограничен только восстановлением отказавших модулей аппаратных средств, он применим также к ошибкам в программных средствах при наличии достаточной &quot;избыточности времени прогона&quot; для повторного выполнения программы или при наличии достаточных избыточных данных, которые обеспечат незначительное влияние отдельного и изолированного отказа.<br/><br/></p><p id="P0223_4" class="formattext topleveltext indenttext" align="justify">Данный метод должен рассматриваться на первом этапе проектирования системы.<br/><br/></p><p id="P0223_5" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0223_6" class="formattext topleveltext indenttext" align="justify">Dynamic Reconfiguration of Software Architectures Through Aspects. С. Costa et al. Lecture Notes in Computer Science, Volume 4758/2007, Springer Berlin/Heidelberg, 2007, ISBN 978-3-540-75131-1.<br/><br/></p><p id="P0225" class="formattext topleveltext indenttext" align="justify"><b>C.3.11 Безопасность и работа в жестком реальном времени. Архитектура с временным распределением</b><br/><br/></p><p id="P0225_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблица А.2).<br/><br/><br/></p><p id="P0225_2" class="formattext topleveltext indenttext" align="justify">Цель. Компонуемость и простая реализация обеспечения отказоустойчивости в критических к безопасности системах жесткого реального времени.<br/><br/></p><p id="P0225_3" class="formattext topleveltext indenttext" align="justify">Описание. В архитектуре системы с временным распределением (ТТА) все действия системы инициируются и выполняются под управлением глобальной (жесткой) системы синхронизации. Каждому приложению присвоен фиксированный временной слот на шине с временным распределением, во время которого происходит обмен сообщениями с другими приложениями, поэтому каждое приложение может выполнять обмен только согласно жестко определенному расписанию обмена. В управляемых событиями системах системные действия инициируются случайными событиями в непредсказуемые моменты времени. Главные преимущества архитектуры с временным распределением (см. Scheidler, Хайнер и др.) следующие:<br/><br/></p><p id="P0225_4" class="formattext topleveltext indenttext" align="justify">- компонуемость, которая значительно уменьшает усилия, требуемые для тестирования и сертификации системы;<br/><br/></p><p id="P0225_5" class="formattext topleveltext indenttext" align="justify">- простая реализация обеспечения отказоустойчивости, которая делает архитектуру очень востребованной для критических к безопасности приложений;<br/><br/></p><p id="P0225_6" class="formattext topleveltext indenttext" align="justify">- применение глобально синхронизируемого времени облегчает проектирование распределенных систем реального времени.<br/><br/></p><p id="P0225_7" class="formattext topleveltext indenttext" align="justify">Передача между узлами выполняется в соответствии с протоколом временного распределения ресурсов (ТТР/С) (см. Kopetz, Hexel и др.) согласно статическому расписанию обмена, в рамках которого решается, когда передать сообщение и является ли полученное сообщение важным для конкретного электронного модуля. Доступ к шине реализуется по схеме с определенным периодическим расписанием в режиме множественного доступа с разделением времени (TDMA), связанной с глобальным временем.<br/><br/></p><p id="P0225_8" class="formattext topleveltext indenttext" align="justify">Протокол ТТР/С гарантирует (см. Rushby) четыре базовые услуги (базовые службы) в сети узлов ТТА системы (см. Kopetz, Bauer):<br/><br/></p><p id="P0225_9" class="formattext topleveltext indenttext" align="justify">- Детерминированная передача сообщений в строго определенные моменты времени. Передача сообщений от выходного порта передающего элемента к входным портам получающих элементов в пределах априорно известного временного интервала. Отказоустойчивая транспортная служба, предлагаемая коммуникационной услугой с временным распределением, которая доступна через временной интерфейс с сетевым экраном, устраняет передачу ошибок управления проектом и минимизирует связь между элементами. Передача сообщений в строго определенные моменты времени, с минимальной задержкой и с минимальными флуктуациями, крайне важна для достижения устойчивости управления в приложениях реального времени.<br/><br/></p><p id="P0225_10" class="formattext topleveltext indenttext" align="justify">- Отказоустойчивая синхронизация. Коммуникационный контроллер (а не центральный сервер) генерирует отказоустойчивый синхронизирующий глобальный временной сигнал (с точностью до нескольких тактов), которым обеспечены подсистемы узлов.<br/><br/></p><p id="P0225_11" class="formattext topleveltext indenttext" align="justify">- Контроль целостности данных при сбоях в узлах (служба целостности). Коммуникационный контроллер сообщает каждому SRU (&quot;минимальному элементу замены&quot;) о состоянии остальных SRU в кластере с временной задержкой меньше одного раунда TDMA.<br/><br/></p><p id="P0225_12" class="formattext topleveltext indenttext" align="justify">- Строгая изоляция сбоя. Злонамеренно дефектная подсистема узла (включая ее программное обеспечение) может сформировать ошибочные выходные данные, но никогда не сможет вмешаться каким-либо способом в корректную работу остальной части кластера ТТР/С. Невоспринимаемость сбоя во времени гарантируется поведением коммуникационного контроллера, реализующего временное распределение.<br/><br/></p><p id="P0225_13" class="formattext topleveltext indenttext" align="justify">Примечание - Существуют другие протоколы с временным распределением: FlexRay и ТТ - Ethernet (Ethernet с временным распределением).<br/><br/><br/></p><p id="P0225_14" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0225_15" class="formattext topleveltext indenttext" align="justify">Time-Triggered Architecture (ТТА). С. Scheidler, G. Heiner, R. Sasse, E. Fuchs, H. Kopetz, С. Temple. In Advances in Information Technologies: The Business Challenge, ed. J-Y. Roger. IOS Press, 1998, ISBN 9051993854, 9789051993851.<br/><br/></p><p id="P0227" class="formattext topleveltext indenttext" align="justify">A Synchronisation Strategy for a TTP/C Controller. H. Kopetz, R. Hexel, A. Krueger, D. Millinger, A. Schedl. SAE paper 960120, Application of Multiplexing Technology SP 1137, Detroit, SAE Press, Warrendale, 1996.<br/><br/></p><p id="P0227_1" class="formattext topleveltext indenttext" align="justify">The Time-Triggered Architecture. H. Kopetz, G. Bauer. Proceedings of the IEEE Special Issue on Modeling and Design of Embedded Software, October 2002.<br/><br/></p><p id="P0227_2" class="formattext topleveltext indenttext" align="justify">An Overview of Formal Verification for the Time-Triggered Architecture. J. Rushby: Invited paper, Oldenburg, Germany, September 9-12, 2002. Proceedings FTRTFT 2002, Springer LNCS 2469, 2002, ISBN 978-3-540-44165-6.<br/><br/></p><p id="P0229" class="formattext topleveltext indenttext" align="justify"><b>C.3.12 UML</b><br/><br/></p><p id="P0229_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблица В.7).<br/><br/><br/></p><p id="P0229_2" class="formattext topleveltext indenttext" align="justify">Цель. Обеспечить исчерпывающий набор нотаций для моделирования требуемого поведения сложных систем.<br/><br/></p><p id="P0229_3" class="formattext topleveltext indenttext" align="justify">Описание. UML, в соответствии с названием, - это набор требований и нотаций проектирования, которые предназначены обеспечить всестороннюю поддержку процессу разработки программного обеспечения. Некоторые части UML основаны на нотациях, впервые появившихся в других методах (таких как диаграмма последовательностей и диаграммы переходов), а другие нотации уникальны в UML. UML очень близок к объектно-ориентированному языку, хотя некоторые из нотаций могут не использоваться в объектно-ориентированном программировании. UML поддерживается многими коммерчески доступными CASE инструментами, многие из которых способны автоматически генерировать программные коды из моделей UML.<br/><br/></p><p id="P0229_4" class="formattext topleveltext indenttext" align="justify">Нотации UML, которые обычно применяются для спецификации и проектирования систем, связанных с безопасностью, следующие:<br/><br/></p><p id="P0229_5" class="formattext topleveltext indenttext" align="justify">- диаграммы классов;<br/><br/></p><p id="P0229_6" class="formattext topleveltext indenttext" align="justify">- прецеденты;<br/><br/></p><p><img class="base64 sign" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZIAAAARCAMAAADAD9oKAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MTg4Q0U3ODQ0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MTg4Q0U3ODU0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoxODhDRTc4MjRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDoxODhDRTc4MzRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pos3t18AAAAzUExURfX19SQkJOrq6oeHh7y8vD8/P9/f31RUVMjIyLCwsHh4eJaWlmdnZ6Ojo9TU1AAAAP////kimdMAAAWSSURBVHja7FiJcuQoDAVzGcz1/1+7TwLRuDs9mZ2karZqQ1ViGz90PUngVv1nfMOo9fg2WarnNkf9FGxMHdDkf1jo3bXBg7o0YhIkfrXV0npvBfd48y94HQtV97XWZvBPfbpG29oikGfQ6oeRs4WLb4K2CGNq5wsltpX6B5TQYEa5/u6h9rdn31QdtXS0iKX1WZ360/o9Pl/3NmVq/ahk/cfwZ0X+bSL6T01Kxmq6Fj0MSDNPj+atGzF1+Y17z9IZMRfulHiH+ivMFvE7nm2ffQ26Q5+U0AKLatWUGFm63kU3SJycuwqNLgNJ1ONf6crorUNyEySMStQLlegNgSuSmiT5agizm0YyZwPNbEXLM64y2X0YcGgdN3ytU9FaLDCecHbCyFWVh0kjMvBEHK+rvx/tVIgOWSoTcZrRa+aVJxeOuLc5nG8Oj2cjCzdKDm1Uj9BCSFeO7sKBgKCxRWpXKNAiFtV2njBAGeqm2QBQaZKCjjDCA+vqnZJD802sAzu9q4EwRtde4djUG4kJeFObpsag4cXNNJKJejRY7pVO9EJiQf2XRJLlBEcW1Toooc48FcniBeN2nOALwwzMDXhDJv2CkoKENkS/NKzu0p74rRyOk0vcezgs0iXQhLDixE4J6YAALgUqoEq6VKpih0KosOuUUihxM+eGo6KIA3DEaTI8oJS7UZIybnhmOVX1wCiqLJSYmnr52WjShadTA7Obtsyl2lP22PquxG9kJ1VbSWN2gEXRfF4wlnri36xnTJBYC+R7ShyX17HNDIcXJSg8ddMqDi/p0+HOCGNfKclwPmdHBsVgp9mbHaemuwBMwtvmCK2pQqtwdpakiZIQg7pTAitwc+m6OVWyWFhnzQy9aMrcDZASSAJjgNlMo5R4UIJ1xbhnSsYr+p/LRslS1FfshQFIpb4v06WRvgBky4VfseOmPqy3zaKiZqp/SEmpOqhdqzi8pE+H6/2wu1PiCg9AkvOvlJi0r2ZbS7FooaMpdo8WYy6ixPFRZKcEE9Iz115irhdKWC/y1VquyIpWqU+i5GEapcRWJaGFFN9T4s7foyRQdqmNkqHvGJmn82AtUzed1s9vB63U6jj6ulOCnnbtWsXhJX06/J6S5LbDmKYuy/W11rgbobKpdRvmtNFKGpfS142SqEcL8CE99hIKV+ZmbDnr/NQL2Slx46wxoDSB2U27NS77eN4oGZaj91G6PChZiubzgo2+i9AKJbEd/S5yKA5ZAnCwLL6IcfYe2aHWb1rF4SV9OjwQ9XylZGwwORFSIeLUakYnHEVAgh6U0D7elY49C1OZNrM09pIC8EaJtnyjdHiIqE4qiY+K2YleProNrUcLhk8Lm2k3SgrF/KVKhuUQVUzfKFmK5vOCvVBytMSb69NeolwS66954oXTvnF2en3b3XmlIo3LPXF4SReHXZ5b3zMlCKcpAVse9z38XXh2kvo9htvuppy+LqeP0LgvBo/IpIJ+b/kQrGUDaM4XPvlBR9IPVq3mlkDldKIJ5k0vnGyzNh2myYvdtJ0S3wLtJeZOybT8uEabQ3kPSkSRUDRhs3HpI2uhKwKZKC8elADStJcASJOg7IcrF9BZvVBCPVi0bg6LdHF4IOqNkvmNaVM2iMWBHqoKLD9TvghAE92ecjdXxkxveb8tHElMxB7PblETZ1G2zDe1eNbBMkVEGdsDl4k3d709uAk86RPY3k2b5lZOIzbxnN2c5xk+LM9jv8PZaIBFkSwWBw9CRWwlLJ3fVZPTuYkUyLT+KPP7VBGAQmGev5tHTGMUrbvDU/pyeNn1oOQLQ74d6yeA51Hyfnn6FWDtmF8bueyXvzx+5XB/3d6/4rbfL+8Bz8Ne++X+s4z5pp/QLrtf/vJ47/B3U/L9Q/Fp4P87fn7R/c+NfwQYAFx9eFOvgdoSAAAAAElFTkSuQmCC"/></p><style>.base64.sign {display: none;}</style><p id="P0229_7" class="formattext topleveltext indenttext" align="justify">- диаграммы действий;<br/><br/></p><p id="P0229_8" class="formattext topleveltext indenttext" align="justify">- диаграммы переходов (диаграммы состояний);<br/><br/></p><p id="P0229_9" class="formattext topleveltext indenttext" align="justify">- диаграммы последовательностей.<br/><br/></p><p id="P0229_10" class="formattext topleveltext indenttext" align="justify">Другие нотации UML относятся к представлению проекта архитектуры программного обеспечения (структуры программного обеспечения), но в данном пункте не рассматриваются.<br/><br/></p><p id="P0229_11" class="formattext topleveltext indenttext" align="justify">Диаграмма переходов описана в В.2.3.2 и диаграмма последовательностей - в С.2.14. Остальные нотации описаны в следующих трех подпунктах.<br/><br/></p><p id="P022B" class="formattext topleveltext indenttext" align="justify">С.3.12.1 Диаграммы классов<br/><br/></p><p id="P022B_1" class="formattext topleveltext indenttext" align="justify">Диаграммы классов определяют классы объектов, которые должны использоваться в программном обеспечении. Они основаны на более ранних схемах атрибут-связь-сущность, но адаптированы к объектно-ориентированному проектированию. Каждый класс (из которого один или более экземпляров будут использоваться в качестве объектов во время выполнения) представлен прямоугольником, а различные отношения между классами показаны линиями или стрелками. Операции или методы, предлагаемые каждым классом, и атрибуты данных каждого класса могут быть добавлены к схеме. Представляемые отношения состоят как из ссылочных отношений с указанием их кратности (экземпляр класса А может обратиться к одному или нескольким экземплярам класса В), так и из отношений специализации (класс X - уточнение класса Y) с, возможно, дополнительными методами и атрибутами. Может быть изображено множественное наследование.<br/><br/></p><p id="P022D" class="formattext topleveltext indenttext" align="justify">С.3.12.2 Прецеденты<br/><br/></p><p id="P022D_1" class="formattext topleveltext indenttext" align="justify">Прецеденты обеспечивают текстовое описание требуемого поведения системы в соответствии с определенным сценарием, обычно с точки зрения внешних агентов, включая пользователей системы и внешних систем. Для представления дополнительного поведения, особенно в случаях ошибочных ответов, внутри данного прецедента могут использоваться альтернативные подсценарии. Чтобы обеспечить достаточно полную спецификацию системных требований, разрабатывается набор прецедентов. Прецеденты могут быть начальной точкой для разработки более строгих моделей, таких как диаграммы последовательностей и диаграммы действий.<br/><br/></p><p id="P022D_2" class="formattext topleveltext indenttext" align="justify">Диаграммы прецедентов обеспечивают пиктографическое представление системы и агентов, которые включены в прецеденты, но оно не строгое, так как для спецификации важным является только текстовое описание прецедента.<br/><br/></p><p id="P022F" class="formattext topleveltext indenttext" align="justify">С.3.12.3 Диаграммы действий<br/><br/></p><p id="P022F_1" class="formattext topleveltext indenttext" align="justify">Диаграммы действий показывают намеченную последовательность действий, выполняемых элементом программного обеспечения (часто объектом в объектно-ориентированном проекте), включая последовательное и итеративное поведение (некоторые аспекты очень похожи на блок-схему). Диаграммы действий однако позволяют описание параллельных действий для нескольких элементов, указывая взаимодействия между этими элементами стрелками на диаграмме. Точки синхронизации, в которых действие, прежде чем начнет выполняться, должно ожидать один или несколько входных потоков от других действий, обозначаются символом, подобным узлу сети Петри.<br/><br/></p><p id="P022F_2" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P022F_3" class="formattext topleveltext indenttext" align="justify">ISO/IEC 19501:2005, Information technology - Open Distributed Processing - Unified Modeling Language (UML) Version 1.4.2.<br/><br/></p><h3 id="P0232" class="formattext topleveltext indenttext" align="justify" title-level="3"><b>С.4 Инструменты разработки и языки программирования</b><br/><br/></h3><p id="P0234" class="formattext topleveltext indenttext" align="justify"><b>С.4.1 Строго типизированные языки программирования</b><br/><br/></p><p id="P0234_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблица А.3).<br/><br/><br/></p><p id="P0234_2" class="formattext topleveltext indenttext" align="justify">Цель. Снижение вероятности ошибок путем использования языка, который компилятором обеспечивает высокий уровень проверки.<br/><br/></p><p id="P0234_3" class="formattext topleveltext indenttext" align="justify">Описание. Если скомпилирован строго типизированный язык программирования, то проводится много проверок по использованию типов переменных, например, в вызовах процедур и доступе к внешним данным. Компиляция может оказаться безуспешной и будет выдано сообщение об ошибке при любом использовании типа переменных, которое не соответствует заранее установленным правилам.<br/><br/></p><p id="P0234_4" class="formattext topleveltext indenttext" align="justify">Подобные языки обычно позволяют определять установленные пользователем типы данных на основе типов данных базового языка (например целое число, реальное число). Затем эти типы могут быть использованы так же, как и базовый тип. Вводятся строгие проверки, чтобы гарантировать использование правильного типа. Эти проверки проводятся для всей программы, даже если она построена из отдельных скомпилированных модулей. Данные проверки гарантируют также, что число и тип аргументов конкретной процедуры соответствуют числу и типу аргументов в ее вызове, даже если к ней обращаются из отдельно скомпилированных программных модулей.<br/><br/></p><p id="P0234_5" class="formattext topleveltext indenttext" align="justify">Строго типизированные языки обычно обеспечивают другие аспекты проверенной на практике техники программного обеспечения, например, легко анализируемые структуры управления (if... then... else..., do... while... и  т.п.), которые приводят к четко структурированным программам.<br/><br/></p><p id="P0234_6" class="formattext topleveltext indenttext" align="justify">Типичными примерами строго типизированных языков являются Pascal, Ada и Modula 2.<br/><br/></p><p id="P0234_7" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0234_8" class="formattext topleveltext indenttext" align="justify">Concepts in Programming Languages. J.С. Mitchell. Cambridge University Press, 2003, ISBN 0521780985, 9780521780988.<br/><br/></p><p id="P0236" class="formattext topleveltext indenttext" align="justify"><b>C.4.2 Подмножество языка</b><br/><br/></p><p id="P0236_1" class="formattext topleveltext indenttext" align="justify">Примечаниe - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблица А.3).<br/><br/><br/></p><p id="P0236_2" class="formattext topleveltext indenttext" align="justify">Цель. Снижение вероятности внесения программных ошибок и повышение вероятности обнаружения оставшихся ошибок.<br/><br/></p><p id="P0236_3" class="formattext topleveltext indenttext" align="justify">Описание. Язык исследуется для определения программных конструкций, подверженных ошибкам либо сложных для анализа, например, при использовании методов статического анализа. После этого определяется языковое подмножество, которое исключает такие конструкции.<br/><br/></p><p id="P0236_4" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0236_5" class="formattext topleveltext indenttext" align="justify">Practical Experiences of Safety- and Security-Critical Technologies, P. Amey, A.J. Hilton. Ada User Journal, June, 2004.<br/><br/></p><p id="P0236_6" class="formattext topleveltext indenttext" align="justify">Safer C: Developing Software for High-integrity and Safety-critical Systems. L. Hatton, McGraw-Hill, 1994, ISBN 0077076400, 9780077076405.<br/><br/></p><p id="P0236_7" class="formattext topleveltext indenttext" align="justify">Requirements for programming languages in safety and security software standard B.A. Wichmann. Computer Standards and Interfaces. Vol. 14, pp.433-441, 1992.<br/><br/></p><p id="P0238" class="formattext topleveltext indenttext" align="justify"><b>C.4.3 Сертифицированные средства и сертифицированные трансляторы</b><br/><br/></p><p id="P0238_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблица А.3).<br/><br/><br/></p><p id="P0238_2" class="formattext topleveltext indenttext" align="justify">Цель. Помощь разработчику на различных этапах разработки программных средств в использовании необходимых инструментальных средств, которые, где это возможно, должны быть сертифицированы с тем, чтобы обеспечить конкретную степень уверенности в корректности результатов.<br/><br/></p><p id="P0238_3" class="formattext topleveltext indenttext" align="justify">Описание. Сертификацию инструментальных средств в общем случае допускается проводить независимо, как правило, в национальных органах по сертификации, по независимому набору критериев, находящемуся обычно в национальных или международных стандартах. В идеальном случае инструментальные средства, применяемые на всех стадиях разработки (спецификация, проектирование, кодирование, тестирование и оценка соответствия), и те из них, которые используются в управлении конфигурацией, должны быть сертифицированы.<br/><br/></p><p id="P0238_4" class="formattext topleveltext indenttext" align="justify">В настоящее время регулярным процедурам сертификации подвергаются только компиляторы (трансляторы); сертификация проводится национальными органами по сертификации и заключается в проверке компиляторов (трансляторов) на соответствие международным стандартам, например, для языков Ada или Pascal.<br/><br/></p><p id="P0238_5" class="formattext topleveltext indenttext" align="justify">Важно отметить, что сертифицированные инструментальные средства и сертифицированные трансляторы обычно сертифицируются только на соответствие стандартам на соответствующий язык или процесс. Обычно они никак не сертифицируются на соответствие стандартам по безопасности.<br/><br/></p><p id="P0238_6" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0238_7" class="formattext topleveltext indenttext" align="justify">The certification of software tools with respect to software standards, P. Bunyakiati et al. In IEEE International Conference on Information Reuse and Integration, IRI 2007, IEEE, 2007, ISBN 1-4244-1500-4.<br/><br/></p><p id="P0238_8" class="formattext topleveltext indenttext" align="justify">Certified Testing of С Compilers for Embedded Systems. O. Morgan. In: 3rd Institution of Engineering and Technology Conference on Automotive Electronics. IEEE, 2007, ISBN 978-0-86341-815-0.<br/><br/></p><p id="P0238_9" class="formattext topleveltext indenttext" align="justify">The Ada Conformity Assessment Test Suite (ACATS), version 2.5, Ada Conformity Assessment Authority, www. , Apr. 2002.<br/><br/></p><p id="P023A" class="formattext topleveltext indenttext" align="justify"><b>С.4.4 Инструментальные средства и трансляторы. Повышение уверенности на основании опыта использования</b><br/><br/></p><p id="P023A_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблица А.3).<br/><br/><br/></p><p id="P023A_2" class="formattext topleveltext indenttext" align="justify">Цель. Исключение любых проблем, обусловленных ошибками транслятора, которые могут появиться во время разработки, верификации и эксплуатации программного пакета.<br/><br/></p><p id="P023A_3" class="formattext topleveltext indenttext" align="justify">Описание. Транслятор используется в тех случаях, где не было доказательств ненадлежащего исполнения многих предыдущих проектов. Если отсутствует опыт эксплуатации трансляторов или в них обнаружены любые известные серьезные ошибки, то от таких транслятров следует отказаться, если только нет каких-либо других гарантий корректной работы транслятора (см. С.4.4.1).<br/><br/></p><p id="P023A_4" class="formattext topleveltext indenttext" align="justify">Если в трансляторе выявлены небольшие недостатки, то соответствующие языковые конструкции фиксируются и в проектах, связанных с безопасностью, не применяются.<br/><br/></p><p id="P023A_5" class="formattext topleveltext indenttext" align="justify">Другим вариантом исключения проблем, обусловленных ошибками транслятора, является ограничение языка до его общеиспользуемых конструкций.<br/><br/></p><p id="P023A_6" class="formattext topleveltext indenttext" align="justify">Настоящие рекомендации основаны на опыте построения многих проектов. Доказано, что недоработанные трансляторы служат серьезным препятствием в любой программной разработке. Такие трансляторы в общем случае делают невозможной разработку программного обеспечения, связанного с безопасностью.<br/><br/></p><p id="P023A_7" class="formattext topleveltext indenttext" align="justify">В настоящее время не существует методов подтверждения корректности всего транслятора или отдельных его частей.<br/><br/></p><p id="P023C" class="formattext topleveltext indenttext" align="justify">С.4.4.1 Сравнение исходных программ и исполнимых кодов<br/><br/></p><p id="P023C_1" class="formattext topleveltext indenttext" align="justify">Цель. Убедиться в том, что инструменты, используемые для создания образа PROM, не вносят в него никаких ошибок.<br/><br/></p><p id="P023C_2" class="formattext topleveltext indenttext" align="justify">Описание. Образ PROM обратно преобразуется в совокупность &quot;объектных&quot; модулей. Эти &quot;объектные&quot; модули обратно преобразуются в файлы ассемблера, которые затем, с помощью соответствующих методов, сравниваются с фактическими исходными файлами, используемыми первоначально для разработки PROM.<br/><br/></p><p id="P023C_3" class="formattext topleveltext indenttext" align="justify">Основное преимущество данного метода состоит в том, что инструменты [компиляторы, редакторы связей (компоновщики) и  т.п.], используемые для разработки образа PROM, не требуют подтверждения соответствия. Этим методом проверяют правильность преобразования исходного файла, используемого для конкретной системы, связанной с безопасностью.<br/><br/></p><p id="P023C_4" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P023C_5" class="formattext topleveltext indenttext" align="justify">Demonstrating Equivalence of Source Code and PROM Contents. D.J. Pavey and L.A. Winsborrow. The Computer Journal. Vol. 36, No. 7, 1993.<br/><br/></p><p id="P023C_6" class="formattext topleveltext indenttext" align="justify">Formal demonstration of equivalence of source code and PROM contents: an industrial example. D.J. Pavey and L.A. Winsborrow. Mathematics of Dependable Systems, Ed. С. Mitchell and V. Stavridou, Clarendon Press, 1995, ISBN 0-198534-91-4.<br/><br/></p><p id="P023C_7" class="formattext topleveltext indenttext" align="justify">Assuring Correctness in a Safety Critical Software Application. L.A. Winsborrow and D.J. Pavey. High Integrity Systems. Vol. 1, No. 5, pp.453-459, 1996.<br/><br/></p><p id="P023E" class="formattext topleveltext indenttext" align="justify"><b>C.4.5 Выбор соответствующего языка программирования</b><br/><br/></p><p id="P023E_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблица А.3).<br/><br/><br/></p><p id="P023E_2" class="formattext topleveltext indenttext" align="justify">Цель. Обеспечение в максимальной степени требований настоящего стандарта для специального защищающего программирования, строгой типизации, структурного программирования и, возможно, суждений. Выбранный язык программирования должен обеспечить легко верифицируемый код и простые процедуры разработки, верификации и эксплуатации программ.<br/><br/></p><p id="P023E_3" class="formattext topleveltext indenttext" align="justify">Описание. Язык программирования должен быть полностью и однозначно определен. Язык должен быть ориентирован на пользователя или проблему, а не на процессор или платформу. Широко используемые языки программирования или их подмножества должны быть предпочтительнее языков специального применения.<br/><br/></p><p id="P023E_4" class="formattext topleveltext indenttext" align="justify">Языки программирования также должны обеспечивать:<br/><br/></p><p id="P023E_5" class="formattext topleveltext indenttext" align="justify">- блочную структуру организации программ;<br/><br/></p><p id="P023E_6" class="formattext topleveltext indenttext" align="justify">- проверку времени трансляции;<br/><br/></p><p id="P023E_7" class="formattext topleveltext indenttext" align="justify">- проверку во время работы программы типов и границ массивов.<br/><br/></p><p id="P023E_8" class="formattext topleveltext indenttext" align="justify">Язык программирования должен включать в себя:<br/><br/></p><p id="P023E_9" class="formattext topleveltext indenttext" align="justify">- использование небольших и управляемых программных модулей;<br/><br/></p><p id="P023E_10" class="formattext topleveltext indenttext" align="justify">- ограничение доступа к данным в конкретных программных модулях;<br/><br/></p><p id="P023E_11" class="formattext topleveltext indenttext" align="justify">- определение поддиапазонов переменных;<br/><br/></p><p id="P023E_12" class="formattext topleveltext indenttext" align="justify">- любые другие типы конструкции, ограничивающие ошибки.<br/><br/></p><p id="P023E_13" class="formattext topleveltext indenttext" align="justify">Если операции системы безопасности зависят от ограничений реального времени, то язык программирования должен обеспечивать также обработку исключений или прерываний.<br/><br/></p><p id="P023E_14" class="formattext topleveltext indenttext" align="justify">Желательно, чтобы язык программирования обеспечивался соответствующим транслятором, подходящими библиотеками с заранее созданными программными модулями, отладчиком и инструментами как для управления версиями, так и для разработки.<br/><br/></p><p id="P023E_15" class="formattext topleveltext indenttext" align="justify">В настоящее время еще не ясно, будут ли объектно-ориентированные языки программирования предпочтительнее других общепринятых языков.<br/><br/></p><p id="P023E_16" class="formattext topleveltext indenttext" align="justify">К свойствам, которые усложняют верификацию и поэтому должны быть исключены, относятся:<br/><br/></p><p id="P023E_17" class="formattext topleveltext indenttext" align="justify">- безусловные переходы (за исключением вызовов подпрограмм);<br/><br/></p><p id="P023E_18" class="formattext topleveltext indenttext" align="justify">- рекурсии;<br/><br/></p><p id="P023E_19" class="formattext topleveltext indenttext" align="justify">- указатели, динамически распределяемые области памяти или любые типы динамических переменных или объектов;<br/><br/></p><p id="P023E_20" class="formattext topleveltext indenttext" align="justify">- обработка прерываний на уровне исходного кода;<br/><br/></p><p id="P023E_21" class="formattext topleveltext indenttext" align="justify">- множество входов или выходов в циклах, блоках или подпрограммах;<br/><br/></p><p id="P023E_22" class="formattext topleveltext indenttext" align="justify">- неявная инициализация или объявление переменных;<br/><br/></p><p id="P023E_23" class="formattext topleveltext indenttext" align="justify">- вариантные записи и эквивалентность;<br/><br/></p><p id="P023E_24" class="formattext topleveltext indenttext" align="justify">- процедурная переменная в качестве параметра.<br/><br/></p><p id="P023E_25" class="formattext topleveltext indenttext" align="justify">Языки программирования низкого уровня, в частности ассемблеры, обладают недостатками, связанными с их жесткой ориентацией на процессор машины или на определенную платформу.<br/><br/></p><p id="P023E_26" class="formattext topleveltext indenttext" align="justify">Желательным свойством языка программирования является то, что его проектирование и использование должно приводить к созданию программ, выполнение которых предсказуемо. Если используется подходящий конкретный язык программирования, то в нем должно существовать подмножество, которое гарантирует, что выполнение программы предсказуемо. Это подмножество не может быть (в общем случае) статически определено, несмотря на то, что многие статические ограничения помогают гарантировать предсказуемое выполнение. Обычно это может потребовать демонстрации того, что индексы массива находятся в установленных пределах и что числовое переполнение не может возникнуть, и  т.п.<br/><br/></p><p><img class="base64 sign" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZIAAAARCAMAAADAD9oKAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MTg4Q0U3ODQ0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MTg4Q0U3ODU0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoxODhDRTc4MjRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDoxODhDRTc4MzRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pos3t18AAAAzUExURfX19SQkJOrq6oeHh7y8vD8/P9/f31RUVMjIyLCwsHh4eJaWlmdnZ6Ojo9TU1AAAAP////kimdMAAAWSSURBVHja7FiJcuQoDAVzGcz1/1+7TwLRuDs9mZ2karZqQ1ViGz90PUngVv1nfMOo9fg2WarnNkf9FGxMHdDkf1jo3bXBg7o0YhIkfrXV0npvBfd48y94HQtV97XWZvBPfbpG29oikGfQ6oeRs4WLb4K2CGNq5wsltpX6B5TQYEa5/u6h9rdn31QdtXS0iKX1WZ360/o9Pl/3NmVq/ahk/cfwZ0X+bSL6T01Kxmq6Fj0MSDNPj+atGzF1+Y17z9IZMRfulHiH+ivMFvE7nm2ffQ26Q5+U0AKLatWUGFm63kU3SJycuwqNLgNJ1ONf6crorUNyEySMStQLlegNgSuSmiT5agizm0YyZwPNbEXLM64y2X0YcGgdN3ytU9FaLDCecHbCyFWVh0kjMvBEHK+rvx/tVIgOWSoTcZrRa+aVJxeOuLc5nG8Oj2cjCzdKDm1Uj9BCSFeO7sKBgKCxRWpXKNAiFtV2njBAGeqm2QBQaZKCjjDCA+vqnZJD802sAzu9q4EwRtde4djUG4kJeFObpsag4cXNNJKJejRY7pVO9EJiQf2XRJLlBEcW1Toooc48FcniBeN2nOALwwzMDXhDJv2CkoKENkS/NKzu0p74rRyOk0vcezgs0iXQhLDixE4J6YAALgUqoEq6VKpih0KosOuUUihxM+eGo6KIA3DEaTI8oJS7UZIybnhmOVX1wCiqLJSYmnr52WjShadTA7Obtsyl2lP22PquxG9kJ1VbSWN2gEXRfF4wlnri36xnTJBYC+R7ShyX17HNDIcXJSg8ddMqDi/p0+HOCGNfKclwPmdHBsVgp9mbHaemuwBMwtvmCK2pQqtwdpakiZIQg7pTAitwc+m6OVWyWFhnzQy9aMrcDZASSAJjgNlMo5R4UIJ1xbhnSsYr+p/LRslS1FfshQFIpb4v06WRvgBky4VfseOmPqy3zaKiZqp/SEmpOqhdqzi8pE+H6/2wu1PiCg9AkvOvlJi0r2ZbS7FooaMpdo8WYy6ixPFRZKcEE9Iz115irhdKWC/y1VquyIpWqU+i5GEapcRWJaGFFN9T4s7foyRQdqmNkqHvGJmn82AtUzed1s9vB63U6jj6ulOCnnbtWsXhJX06/J6S5LbDmKYuy/W11rgbobKpdRvmtNFKGpfS142SqEcL8CE99hIKV+ZmbDnr/NQL2Slx46wxoDSB2U27NS77eN4oGZaj91G6PChZiubzgo2+i9AKJbEd/S5yKA5ZAnCwLL6IcfYe2aHWb1rF4SV9OjwQ9XylZGwwORFSIeLUakYnHEVAgh6U0D7elY49C1OZNrM09pIC8EaJtnyjdHiIqE4qiY+K2YleProNrUcLhk8Lm2k3SgrF/KVKhuUQVUzfKFmK5vOCvVBytMSb69NeolwS66954oXTvnF2en3b3XmlIo3LPXF4SReHXZ5b3zMlCKcpAVse9z38XXh2kvo9htvuppy+LqeP0LgvBo/IpIJ+b/kQrGUDaM4XPvlBR9IPVq3mlkDldKIJ5k0vnGyzNh2myYvdtJ0S3wLtJeZOybT8uEabQ3kPSkSRUDRhs3HpI2uhKwKZKC8elADStJcASJOg7IcrF9BZvVBCPVi0bg6LdHF4IOqNkvmNaVM2iMWBHqoKLD9TvghAE92ecjdXxkxveb8tHElMxB7PblETZ1G2zDe1eNbBMkVEGdsDl4k3d709uAk86RPY3k2b5lZOIzbxnN2c5xk+LM9jv8PZaIBFkSwWBw9CRWwlLJ3fVZPTuYkUyLT+KPP7VBGAQmGev5tHTGMUrbvDU/pyeNn1oOQLQ74d6yeA51Hyfnn6FWDtmF8bueyXvzx+5XB/3d6/4rbfL+8Bz8Ne++X+s4z5pp/QLrtf/vJ47/B3U/L9Q/Fp4P87fn7R/c+NfwQYAFx9eFOvgdoSAAAAAElFTkSuQmCC"/></p><style>.base64.sign {display: none;}</style><p id="P023E_27" class="formattext topleveltext indenttext" align="justify">Рекомендации по конкретным языкам программирования приведены в таблице С.1.<br/><br/></p><p id="P023E_28" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P023E_29" class="formattext topleveltext indenttext" align="justify">Concepts in Programming Languages. J.С. Mitchell. Cambridge University Press, 2003, ISBN 0521780985, 9780521780988.<br/><br/></p><p id="P023E_30" class="formattext topleveltext indenttext" align="justify">IEC 60880:2006, Nuclear power plants - Instrumentation and control systems important to safety - Software aspects for computer-based systems performing category A functions.<br/><br/></p><p id="P023E_31" class="formattext topleveltext indenttext" align="justify">IEC 61131-3:2003, Programmable controllers - Part 3: Programming languages.<br/><br/></p><p id="P023E_32" class="formattext topleveltext indenttext" align="justify">ISO/IEC 1539-1:2004, Information technology - Programming languages - Fortran - Part 1: Base language.<br/><br/></p><p id="P023E_33" class="formattext topleveltext indenttext" align="justify">ISO/IEC 7185:1990, Information technology - Programming languages - Pascal.<br/><br/></p><p id="P023E_34" class="formattext topleveltext indenttext" align="justify">ISO/IEC 8652:1995, Information technology - Programming languages - Ada.<br/><br/></p><p id="P023E_35" class="formattext topleveltext indenttext" align="justify">ISO/IEC 9899:1999, Programming languages - С.<br/><br/></p><p id="P023E_36" class="formattext topleveltext indenttext" align="justify">ISO/IEC 10206:1991, Information technology - Programming languages - Extended Pascal.<br/><br/></p><p id="P023E_37" class="formattext topleveltext indenttext" align="justify">ISO/IEC 10514-1:1996, Information technology - Programming languages - Part 1: Modula-2, Base Language.<br/><br/></p><p id="P023E_38" class="formattext topleveltext indenttext" align="justify">ISO/IEC 10514-3:1998, Information technology - Programming languages - Part 3: Object Oriented Modula-2.<br/><br/></p><p id="P023E_39" class="formattext topleveltext indenttext" align="justify">ISO/IEC 14882:2003, Programming languages - C++.<br/><br/></p><p id="P023E_40" class="formattext topleveltext indenttext" align="justify">ISO/IEC/TR 15942:2000, Information technology - Programming languages - Guide for the use of the Ada programming language in high integrity systems.<br/><br/><br/></p><p id="P023E_41" class="formattext topleveltext" align="justify">Таблица C.1 - Рекомендации по конкретным языкам программирования<br/></p><p id="X1527"></p><div element-type="table" class="table-container" id="X1528"><style type="text/css">#P023F .td1 {width: 26.18em}#P023F .td2 {width: 4.62em}#P023F .td3 {width: 5.39em}#P023F .td4 {width: 26.18em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }#P023F .td5 {width: 4.62em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }#P023F .td6 {width: 5.39em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }#P023F .td7 {width: 46.97em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }</style><table id="P023F" class="wideTable"><tr height="1"><td class="td1"></td><td class="td2"></td><td class="td3"></td><td class="td3"></td><td class="td3"></td></tr><tr><td valign="top" class="td4"><p id="P023F0000" class="formattext" align="center">Язык программирования<br/></p></td><td valign="top" class="td5"><p id="P023F0001" class="formattext" align="center">УПБ1 </p></td><td valign="top" class="td6"><p id="P023F0002" class="formattext" align="center">УПБ2 </p></td><td valign="top" class="td6"><p id="P023F0003" class="formattext" align="center">УПБ3 </p></td><td valign="top" class="td6"><p id="P023F0004" class="formattext" align="center">УПБ4 </p></td></tr><tr><td valign="top" class="td4"><p id="P023F0005" class="formattext" align="justify">1 ADA<br/><br/></p></td><td valign="top" class="td5"><p id="P023F0006" class="formattext" align="center">HR </p></td><td valign="top" class="td6"><p id="P023F0007" class="formattext" align="center">HR </p></td><td valign="top" class="td6"><p id="P023F0008" class="formattext" align="center">R </p></td><td valign="top" class="td6"><p id="P023F0009" class="formattext" align="center">R </p></td></tr><tr><td valign="top" class="td4"><p id="P023F000A" class="formattext" align="justify">2 ADA с подмножеством<br/><br/></p></td><td valign="top" class="td5"><p id="P023F000B" class="formattext" align="center">HR </p></td><td valign="top" class="td6"><p id="P023F000C" class="formattext" align="center">HR </p></td><td valign="top" class="td6"><p id="P023F000D" class="formattext" align="center">HR </p></td><td valign="top" class="td6"><p id="P023F000E" class="formattext" align="center">HR </p></td></tr><tr><td valign="top" class="td4"><p id="P023F000F" class="formattext" align="justify">3 Java<br/><br/></p></td><td valign="top" class="td5"><p id="P023F0010" class="formattext" align="center">NR </p></td><td valign="top" class="td6"><p id="P023F0011" class="formattext" align="center">NR </p></td><td valign="top" class="td6"><p id="P023F0012" class="formattext" align="center">NR </p></td><td valign="top" class="td6"><p id="P023F0013" class="formattext" align="center">NR </p></td></tr><tr><td valign="top" class="td4"><p id="P023F0014" class="formattext" align="justify">4 Java с подмножеством (без включения сборки мусора или с включением сборки мусора, которая не будет вызывать остановку прикладной программы в течение значительного промежутка времени). Руководящие указания по использованию объектно-ориентированных средств см. в приложении G.<br/><br/></p></td><td valign="top" class="td5"><p id="P023F0015" class="formattext" align="center">R </p></td><td valign="top" class="td6"><p id="P023F0016" class="formattext" align="center">R </p></td><td valign="top" class="td6"><p id="P023F0017" class="formattext" align="center">NR </p></td><td valign="top" class="td6"><p id="P023F0018" class="formattext" align="center">NR </p></td></tr><tr><td valign="top" class="td4"><p id="P023F0019" class="formattext" align="justify">5 PASCAL (см. примечание 1)<br/><br/></p></td><td valign="top" class="td5"><p id="P023F001A" class="formattext" align="center">HR </p></td><td valign="top" class="td6"><p id="P023F001B" class="formattext" align="center">HR </p></td><td valign="top" class="td6"><p id="P023F001C" class="formattext" align="center">R </p></td><td valign="top" class="td6"><p id="P023F001D" class="formattext" align="center">R </p></td></tr><tr><td valign="top" class="td4"><p id="P023F001E" class="formattext" align="justify">6 PASCAL с подмножеством<br/><br/></p></td><td valign="top" class="td5"><p id="P023F001F" class="formattext" align="center">HR </p></td><td valign="top" class="td6"><p id="P023F0020" class="formattext" align="center">HR </p></td><td valign="top" class="td6"><p id="P023F0021" class="formattext" align="center">HR </p></td><td valign="top" class="td6"><p id="P023F0022" class="formattext" align="center">HR </p></td></tr><tr><td valign="top" class="td4"><p id="P023F0023" class="formattext" align="justify">7 FORTRAN 77<br/><br/></p></td><td valign="top" class="td5"><p id="P023F0024" class="formattext" align="center">R </p></td><td valign="top" class="td6"><p id="P023F0025" class="formattext" align="center">R </p></td><td valign="top" class="td6"><p id="P023F0026" class="formattext" align="center">R </p></td><td valign="top" class="td6"><p id="P023F0027" class="formattext" align="center">R </p></td></tr><tr><td valign="top" class="td4"><p id="P023F0028" class="formattext" align="justify">8 FORTRAN 77 с подмножеством<br/><br/></p></td><td valign="top" class="td5"><p id="P023F0029" class="formattext" align="center">HR </p></td><td valign="top" class="td6"><p id="P023F002A" class="formattext" align="center">HR </p></td><td valign="top" class="td6"><p id="P023F002B" class="formattext" align="center">HR </p></td><td valign="top" class="td6"><p id="P023F002C" class="formattext" align="center">HR </p></td></tr><tr><td valign="top" class="td4"><p id="P023F002D" class="formattext" align="justify">9 С<br/><br/></p></td><td valign="top" class="td5"><p id="P023F002E" class="formattext" align="center">R </p></td><td valign="top" class="td6"><p id="P023F002F" class="formattext" align="center">-</p></td><td valign="top" class="td6"><p id="P023F0030" class="formattext" align="center">NR </p></td><td valign="top" class="td6"><p id="P023F0031" class="formattext" align="center">NR </p></td></tr><tr><td valign="top" class="td4"><p id="P023F0032" class="formattext" align="justify">10 С с подмножеством и стандартом кодирования, а также использование инструментов статического анализа<br/><br/></p></td><td valign="top" class="td5"><p id="P023F0033" class="formattext" align="center">HR </p></td><td valign="top" class="td6"><p id="P023F0034" class="formattext" align="center">HR </p></td><td valign="top" class="td6"><p id="P023F0035" class="formattext" align="center">HR </p></td><td valign="top" class="td6"><p id="P023F0036" class="formattext" align="center">HR </p></td></tr><tr><td valign="top" class="td4"><p id="P023F0037" class="formattext" align="justify">11 C++ (Руководящие указания по использованию объектно-ориентированных средств см. в приложении G.)<br/><br/></p></td><td valign="top" class="td5"><p id="P023F0038" class="formattext" align="center">R </p></td><td valign="top" class="td6"><p id="P023F0039" class="formattext" align="center">-</p></td><td valign="top" class="td6"><p id="P023F003A" class="formattext" align="center">NR </p></td><td valign="top" class="td6"><p id="P023F003B" class="formattext" align="center">NR </p></td></tr><tr><td valign="top" class="td4"><p id="P023F003C" class="formattext" align="justify">12 C++ с подмножеством и стандартом кодирования, а также использование инструментов статического анализа (Руководящие указания по использованию объектно-ориентированных средств см. в приложении G.)<br/><br/></p></td><td valign="top" class="td5"><p id="P023F003D" class="formattext" align="center">HR </p></td><td valign="top" class="td6"><p id="P023F003E" class="formattext" align="center">HR </p></td><td valign="top" class="td6"><p id="P023F003F" class="formattext" align="center">HR </p></td><td valign="top" class="td6"><p id="P023F0040" class="formattext" align="center">HR </p></td></tr><tr><td valign="top" class="td4"><p id="P023F0041" class="formattext" align="justify">13 Ассемблер<br/><br/></p></td><td valign="top" class="td5"><p id="P023F0042" class="formattext" align="center">R </p></td><td valign="top" class="td6"><p id="P023F0043" class="formattext" align="center">R </p></td><td valign="top" class="td6"><p id="P023F0044" class="formattext" align="center">-</p></td><td valign="top" class="td6"><p id="P023F0045" class="formattext" align="center">-</p></td></tr><tr><td valign="top" class="td4"><p id="P023F0046" class="formattext" align="justify">14 Ассемблер с подмножеством и стандартом кодирования<br/><br/></p></td><td valign="top" class="td5"><p id="P023F0047" class="formattext" align="center">R </p></td><td valign="top" class="td6"><p id="P023F0048" class="formattext" align="center">R </p></td><td valign="top" class="td6"><p id="P023F0049" class="formattext" align="center">R </p></td><td valign="top" class="td6"><p id="P023F004A" class="formattext" align="center">R </p></td></tr><tr><td valign="top" class="td4"><p id="P023F004B" class="formattext" align="justify">15 Многоступенчатые диаграммы<br/><br/></p></td><td valign="top" class="td5"><p id="P023F004C" class="formattext" align="center">R </p></td><td valign="top" class="td6"><p id="P023F004D" class="formattext" align="center">R </p></td><td valign="top" class="td6"><p id="P023F004E" class="formattext" align="center">R </p></td><td valign="top" class="td6"><p id="P023F004F" class="formattext" align="center">R </p></td></tr><tr><td valign="top" class="td4"><p id="P023F0050" class="formattext" align="justify">16 Многоступенчатая диаграмма с определенным подмножеством языка<br/><br/></p></td><td valign="top" class="td5"><p id="P023F0051" class="formattext" align="center">HR </p></td><td valign="top" class="td6"><p id="P023F0052" class="formattext" align="center">HR </p></td><td valign="top" class="td6"><p id="P023F0053" class="formattext" align="center">HR </p></td><td valign="top" class="td6"><p id="P023F0054" class="formattext" align="center">HR </p></td></tr><tr><td valign="top" class="td4"><p id="P023F0055" class="formattext" align="justify">17 Диаграмма функциональных блоков<br/><br/></p></td><td valign="top" class="td5"><p id="P023F0056" class="formattext" align="center">R </p></td><td valign="top" class="td6"><p id="P023F0057" class="formattext" align="center">R </p></td><td valign="top" class="td6"><p id="P023F0058" class="formattext" align="center">R </p></td><td valign="top" class="td6"><p id="P023F0059" class="formattext" align="center">R </p></td></tr><tr><td valign="top" class="td4"><p id="P023F005A" class="formattext" align="justify">18 Диаграмма функциональных блоков с определенным подмножеством языка<br/><br/></p></td><td valign="top" class="td5"><p id="P023F005B" class="formattext" align="center">HR </p></td><td valign="top" class="td6"><p id="P023F005C" class="formattext" align="center">HR </p></td><td valign="top" class="td6"><p id="P023F005D" class="formattext" align="center">HR </p></td><td valign="top" class="td6"><p id="P023F005E" class="formattext" align="center">HR </p></td></tr><tr><td valign="top" class="td4"><p id="P023F005F" class="formattext" align="justify">19 Структурированный текст<br/><br/></p></td><td valign="top" class="td5"><p id="P023F0060" class="formattext" align="center">R </p></td><td valign="top" class="td6"><p id="P023F0061" class="formattext" align="center">R </p></td><td valign="top" class="td6"><p id="P023F0062" class="formattext" align="center">R </p></td><td valign="top" class="td6"><p id="P023F0063" class="formattext" align="center">R </p></td></tr><tr><td valign="top" class="td4"><p id="P023F0064" class="formattext" align="justify">20 Структурированный текст с определенным подмножеством языка<br/><br/></p></td><td valign="top" class="td5"><p id="P023F0065" class="formattext" align="center">HR </p></td><td valign="top" class="td6"><p id="P023F0066" class="formattext" align="center">HR </p></td><td valign="top" class="td6"><p id="P023F0067" class="formattext" align="center">HR </p></td><td valign="top" class="td6"><p id="P023F0068" class="formattext" align="center">HR </p></td></tr><tr><td valign="top" class="td4"><p id="P023F0069" class="formattext" align="justify">21 Последовательная функциональная диаграмма<br/><br/></p></td><td valign="top" class="td5"><p id="P023F006A" class="formattext" align="center">R </p></td><td valign="top" class="td6"><p id="P023F006B" class="formattext" align="center">R </p></td><td valign="top" class="td6"><p id="P023F006C" class="formattext" align="center">R </p></td><td valign="top" class="td6"><p id="P023F006D" class="formattext" align="center">R </p></td></tr><tr><td valign="top" class="td4"><p id="P023F006E" class="formattext" align="justify">22 Последовательная функциональная диаграмма с определенным подмножеством языка<br/><br/></p></td><td valign="top" class="td5"><p id="P023F006F" class="formattext" align="center">HR </p></td><td valign="top" class="td6"><p id="P023F0070" class="formattext" align="center">HR </p></td><td valign="top" class="td6"><p id="P023F0071" class="formattext" align="center">HR </p></td><td valign="top" class="td6"><p id="P023F0072" class="formattext" align="center">HR </p></td></tr><tr><td valign="top" class="td4"><p id="P023F0073" class="formattext" align="justify">23 Список команд<br/><br/></p></td><td valign="top" class="td5"><p id="P023F0074" class="formattext" align="center">R </p></td><td valign="top" class="td6"><p id="P023F0075" class="formattext" align="center">-</p></td><td valign="top" class="td6"><p id="P023F0076" class="formattext" align="center">NR </p></td><td valign="top" class="td6"><p id="P023F0077" class="formattext" align="center">NR </p></td></tr><tr><td valign="top" class="td4"><p id="P023F0078" class="formattext" align="justify">24 Список команд с определенным подмножеством языка<br/><br/></p></td><td valign="top" class="td5"><p id="P023F0079" class="formattext" align="center">HR </p></td><td valign="top" class="td6"><p id="P023F007A" class="formattext" align="center">R </p></td><td valign="top" class="td6"><p id="P023F007B" class="formattext" align="center">R </p></td><td valign="top" class="td6"><p id="P023F007C" class="formattext" align="center">R </p></td></tr><tr><td colspan="5" valign="top" class="td7"><p id="P023F007D" class="formattext indenttext" align="justify">Примечания<br/><br/></p><p id="P023F007D_1" class="formattext indenttext" align="justify">1 Пояснения к рекомендациям R, HR, NR см. в МЭК 61508-3, приложение А.<br/><br/></p><p id="P023F007D_2" class="formattext indenttext" align="justify">2 Системное программное обеспечение включает в себя операционную систему, драйверы, встроенные функции и программные модули, являющиеся частью системы. Программные средства обычно обеспечиваются системой безопасности при поставке. Подмножество языка следует выбирать очень внимательно с тем, чтобы исключить сложные структуры, которые могут образоваться в результате ошибок реализации. Следует выполнять проверки для того, чтобы убедиться в правильном использовании подмножества языка программирования.<br/><br/></p><p id="P023F007D_3" class="formattext indenttext" align="justify">3 Прикладная программа представляет собой программу, разработанную для конкретного безопасного применения. Во многих случаях такая программа разрабатывается конечным пользователем либо подрядчиком, ориентированным на разработку прикладных программ. В тех случаях, когда ряд языков программирования поддерживает одни и те же рекомендации, разработчику следует выбрать тот, который повсеместно используется персоналом в конкретной промышленности или отрасли. Подмножество языка программирования следует выбирать с особым вниманием, чтобы исключить сложные структуры, которые могут привести к ошибкам реализации.<br/><br/></p><p id="P023F007D_4" class="formattext indenttext" align="justify">4 Если конкретный язык программирования не представлен в настоящей таблице, то это не означает, что он исключен. Этот конкретный язык программирования должен соответствовать требованиям настоящего стандарта.<br/><br/></p><p id="P023F007D_5" class="formattext indenttext" align="justify">5 Существует ряд расширений языка Паскаль, включая свободно распространяемый Паскаль. Ссылки на Паскаль включают эти расширения.<br/><br/></p><p id="P023F007D_6" class="formattext indenttext" align="justify">6 Java имеет сборщик мусора времени выполнения. Подмножество Java может не иметь сборщика мусора. Некоторые реализации Java обеспечивают прогрессивную сборку мусора, которая восстанавливает свободную память в процессе выполнения программы и предотвращает выполнение остановки, когда исчерпана доступная память. Приложения жесткого реального времени не должны использовать любые средства сборки мусора.<br/><br/></p><p id="P023F007D_7" class="formattext indenttext" align="justify">7 Если применение языка Java требует использования интерпретатора времени выполнения для про межуточного кода Java, то интерпретатор должен рассматриваться, как часть программного обеспечения, связанного с безопасностью, и удовлетворять требованиям МЭК 61508-3.<br/><br/></p><p id="P023F007D_8" class="formattext indenttext" align="justify">8 О пунктах 15-24 см. [7].<br/><br/></p></td></tr></table></div><p id="P0240" class="formattext topleveltext empty_line" align="justify"></p><p id="P0242" class="formattext topleveltext indenttext" align="justify"><b>С.4.6 Автоматическая генерация программного обеспечения</b><br/><br/></p><p id="P0242_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблица А.2).<br/><br/><br/></p><p id="P0242_2" class="formattext topleveltext indenttext" align="justify">Цель. Автоматизировать наиболее подверженные ошибкам задачи реализации программного обеспечения.<br/><br/></p><p id="P0242_3" class="formattext topleveltext indenttext" align="justify">Описание. Проект системы описывается моделью (исполнимой спецификацией) на более высоком уровне абстракции, чем традиционный исполняемый код. Модель автоматически преобразуется генератором кода в исполнимую форму. Цель состоит в том, чтобы улучшить качество программного обеспечения, устраняя подверженные ошибкам ручные задачи кодирования. Дальнейшая возможная выгода в том, что более сложные проекты могут выполняться на более высоком абстрактном уровне.<br/><br/></p><p id="P0242_4" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0242_5" class="formattext topleveltext indenttext" align="justify">Embedded Software Generation from System Level Design Languages, H. Yu, R. Domer, D. Gajski. In &quot;ASP-DAC 2004: Proceedings of the ASP-Dac 2004 Asia and South Pacific Design Automation Conference, 2004&quot;, IEEE Circuits and Systems Society. IEEE, 2004, ISBN 0780381750, 9780780381759.<br/><br/></p><p id="P0242_6" class="formattext topleveltext indenttext" align="justify">Transforming Process Algebra Models into UML State Machines: Bridging a Semantic Gap? M.F. van Amstel et al. In Theory and Practice of Model Transformations: First International Conference, ICMT&quot;. Ed. A. Vallecillo. Springer, 2008, ISBN 3540699260, 9783540699262.<br/><br/></p><p id="P0244" class="formattext topleveltext indenttext" align="justify"><b>C.4.7 Управление тестированием и средства автоматизации</b><br/><br/></p><p id="P0244_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблица А.5).<br/><br/><br/></p><p id="P0244_2" class="formattext topleveltext indenttext" align="justify">Цель. Обеспечить систематический и всесторонний подход к тестированию системы и программного обеспечения.<br/><br/></p><p id="P0244_3" class="formattext topleveltext indenttext" align="justify">Описание. Использование подходящих средств поддержки автоматизирует более трудоемкие и подверженные ошибкам задачи при разработке системы и дает возможность систематического подхода к управлению тестированием. Доступность поддержки обеспечивает более всесторонний подход и к обычному и регрессионному тестированию.<br/><br/></p><p id="P0244_4" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0244_5" class="formattext topleveltext indenttext" align="justify">Managing the Testing Process: Practical Tools and Techniques for Managing Hardware and Software Testing. R. Black, John Wiley and Sons, 2002, ISBN 0471223980, 9780471223986.<br/><br/></p><h3 id="P0247" class="formattext topleveltext indenttext" align="justify" title-level="3"><b>C.5 Верификация и модификация</b><br/><br/></h3><p id="P0249" class="formattext topleveltext indenttext" align="justify"><b>C.5.1 Вероятностное тестирование</b><br/><br/></p><p id="P0249_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблицы А.5, С.15, А.7 и С.17).<br/><br/><br/></p><p id="P0249_2" class="formattext topleveltext indenttext" align="justify">Цель. Получение количественных показателей надежности исследуемой программы.<br/><br/></p><p id="P0249_3" class="formattext topleveltext indenttext" align="justify">Описание. Количественные показатели могут быть получены с учетом относительных уровней доверия и значимости и должны иметь следующий вид:<br/><br/></p><p id="P0249_4" class="formattext topleveltext indenttext" align="justify">- вероятность ошибки при запросе;<br/><br/></p><p id="P0249_5" class="formattext topleveltext indenttext" align="justify">- вероятность ошибки в течение определенного периода времени;<br/><br/></p><p id="P0249_6" class="formattext topleveltext indenttext" align="justify">- вероятность последствий ошибки.<br/><br/></p><p id="P0249_7" class="formattext topleveltext indenttext" align="justify">Из этих показателей могут быть получены другие показатели, например:<br/><br/></p><p id="P0249_8" class="formattext topleveltext indenttext" align="justify">- вероятность безошибочной работы;<br/><br/></p><p id="P0249_9" class="formattext topleveltext indenttext" align="justify">- вероятность живучести;<br/><br/></p><p id="P0249_10" class="formattext topleveltext indenttext" align="justify">- доступность;<br/><br/></p><p id="P0249_11" class="formattext topleveltext indenttext" align="justify">- MTBF или частота отказов;<br/><br/></p><p id="P0249_12" class="formattext topleveltext indenttext" align="justify">- вероятность безопасного исполнения.<br/><br/></p><p id="P0249_13" class="formattext topleveltext indenttext" align="justify">Вероятностные соображения основываются либо на статистических испытаниях, либо на опыте эксплуатации. Обычно количество тестовых примеров или наблюдаемых практических примеров очень велико. Обычно тестирование в режиме запросов занимает значительно меньше времени, чем в непрерывном режиме работы.<br/><br/></p><p id="P0249_14" class="formattext topleveltext indenttext" align="justify">Для формирования входных данных тестирования и управления выходными данными тестирования обычно используются инструменты автоматического тестирования. Крупные тесты прогоняются на больших центральных компьютерах с имитацией соответствующей периферии. Тестируемые данные выбираются с учетом как систематических, так и случайных ошибок аппаратных средств. Например, общее управление тестированием гарантирует профиль тестируемых данных, тогда как случайный выбор тестируемых данных может управлять отдельными тестовыми примерами более детально.<br/><br/></p><p id="P0249_15" class="formattext topleveltext indenttext" align="justify">Как указано выше, индивидуальные средства для тестирования, выполнение тестирования и управление тестированием определяются детализированными целями тестирования. Другие важные условия задаются математическими предпосылками, которые должны быть соблюдены, если оценка тестирования удовлетворяет заданным целям тестирования.<br/><br/></p><p id="P0249_16" class="formattext topleveltext indenttext" align="justify">Из опыта эксплуатации также могут быть получены вероятностные характеристики поведения любого тестируемого объекта. Если соблюдаются одинаковые условия, то к оценкам результатов тестирования может быть применен одинаковый математический аппарат.<br/><br/></p><p id="P0249_17" class="formattext topleveltext indenttext" align="justify">Используя эти методы, достаточно сложно продемонстрировать на практике сверхвысокие уровни надежности.<br/><br/></p><p id="P0249_18" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P024B" class="formattext topleveltext indenttext" align="justify">A discussion of statistical testing on a safety-related application. S. Kuball, J.H.R. May, Proc IMechE. Vol. 221. Part O: J. Risk and Reliability, Institution of Mechanical Engineers, 2007.<br/><br/></p><p id="P024B_1" class="formattext topleveltext indenttext" align="justify">Estimating the Probability of Failure when Testing Reveals No Failures, W.K. Miller, L.J. Morell et al. IEEE Transactions on Software Engineering, Vol. 18, No.1, pp.33-43, January 1992.<br/><br/></p><p id="P024B_2" class="formattext topleveltext indenttext" align="justify">Reliability estimation from appropriate testing of plant protection software, J. May, G. Hughes, A.D. Lunn. IEE Software Engineering Journal. Vol. 10. No. 6. pp.206-218, Nov., 1995 (ISSN: 0268-6961).<br/><br/></p><p id="P024B_3" class="formattext topleveltext indenttext" align="justify">Validation of ultra high dependability for software based systems, B. Littlewood and L. Strigini. Comm. ACM 36 (11), 69-80, 1993.<br/><br/></p><p id="P024D" class="formattext topleveltext indenttext" align="justify"><b>C.5.2 Регистрация и анализ данных</b><br/><br/></p><p id="P024D_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблицы А.5 и А.8).<br/><br/><br/></p><p id="P024D_2" class="formattext topleveltext indenttext" align="justify">Цель. Документирование всех данных, решений и разумного обоснования программных проектов в целях обеспечения верификации, подтверждения соответствия, оценки и эксплуатации.<br/><br/></p><p id="P024D_3" class="formattext topleveltext indenttext" align="justify">Описание. В процессе всего проектирования разрабатывается подробная документация, в которую входят:<br/><br/></p><p id="P024D_4" class="formattext topleveltext indenttext" align="justify">- тестирование, выполняемое на каждом программном модуле;<br/><br/></p><p id="P024D_5" class="formattext topleveltext indenttext" align="justify">- решения и их разумные обоснования;<br/><br/></p><p id="P024D_6" class="formattext topleveltext indenttext" align="justify">- проблемы и их решения.<br/><br/></p><p id="P024D_7" class="formattext topleveltext indenttext" align="justify">В процессе и по завершении проекта эта документация может быть проанализирована на наличие широкого набора информации. В частности, такая информация, использовавшаяся в качестве обоснования при принятии конкретных решений в процессе разработки проекта и очень важная для обслуживания вычислительных систем, не всегда известна инженерам по эксплуатации.<br/><br/></p><p id="P024D_8" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P024D_9" class="formattext topleveltext indenttext" align="justify">Dependability of Critical Computer Systems 2. F.J. Redmill, Elsevier Applied Science, 1989, ISBN 1851663819, 9781851663811.<br/><br/></p><p id="P024F" class="formattext topleveltext indenttext" align="justify"><b>C.5.3 Тестирование интерфейса</b><br/><br/></p><p id="P024F_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблица А.5).<br/><br/><br/></p><p id="P024F_2" class="formattext topleveltext indenttext" align="justify">Цель. Обнаружение ошибок в интерфейсах подпрограмм.<br/><br/></p><p id="P024F_3" class="formattext topleveltext indenttext" align="justify">Описание. Возможны несколько уровней детализации или полноты тестирования. К наиболее важным уровням относится тестирование:<br/><br/></p><p><img class="base64 sign" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZIAAAARCAMAAADAD9oKAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MTg4Q0U3ODQ0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MTg4Q0U3ODU0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoxODhDRTc4MjRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDoxODhDRTc4MzRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pos3t18AAAAzUExURfX19SQkJOrq6oeHh7y8vD8/P9/f31RUVMjIyLCwsHh4eJaWlmdnZ6Ojo9TU1AAAAP////kimdMAAAWSSURBVHja7FiJcuQoDAVzGcz1/1+7TwLRuDs9mZ2karZqQ1ViGz90PUngVv1nfMOo9fg2WarnNkf9FGxMHdDkf1jo3bXBg7o0YhIkfrXV0npvBfd48y94HQtV97XWZvBPfbpG29oikGfQ6oeRs4WLb4K2CGNq5wsltpX6B5TQYEa5/u6h9rdn31QdtXS0iKX1WZ360/o9Pl/3NmVq/ahk/cfwZ0X+bSL6T01Kxmq6Fj0MSDNPj+atGzF1+Y17z9IZMRfulHiH+ivMFvE7nm2ffQ26Q5+U0AKLatWUGFm63kU3SJycuwqNLgNJ1ONf6crorUNyEySMStQLlegNgSuSmiT5agizm0YyZwPNbEXLM64y2X0YcGgdN3ytU9FaLDCecHbCyFWVh0kjMvBEHK+rvx/tVIgOWSoTcZrRa+aVJxeOuLc5nG8Oj2cjCzdKDm1Uj9BCSFeO7sKBgKCxRWpXKNAiFtV2njBAGeqm2QBQaZKCjjDCA+vqnZJD802sAzu9q4EwRtde4djUG4kJeFObpsag4cXNNJKJejRY7pVO9EJiQf2XRJLlBEcW1Toooc48FcniBeN2nOALwwzMDXhDJv2CkoKENkS/NKzu0p74rRyOk0vcezgs0iXQhLDixE4J6YAALgUqoEq6VKpih0KosOuUUihxM+eGo6KIA3DEaTI8oJS7UZIybnhmOVX1wCiqLJSYmnr52WjShadTA7Obtsyl2lP22PquxG9kJ1VbSWN2gEXRfF4wlnri36xnTJBYC+R7ShyX17HNDIcXJSg8ddMqDi/p0+HOCGNfKclwPmdHBsVgp9mbHaemuwBMwtvmCK2pQqtwdpakiZIQg7pTAitwc+m6OVWyWFhnzQy9aMrcDZASSAJjgNlMo5R4UIJ1xbhnSsYr+p/LRslS1FfshQFIpb4v06WRvgBky4VfseOmPqy3zaKiZqp/SEmpOqhdqzi8pE+H6/2wu1PiCg9AkvOvlJi0r2ZbS7FooaMpdo8WYy6ixPFRZKcEE9Iz115irhdKWC/y1VquyIpWqU+i5GEapcRWJaGFFN9T4s7foyRQdqmNkqHvGJmn82AtUzed1s9vB63U6jj6ulOCnnbtWsXhJX06/J6S5LbDmKYuy/W11rgbobKpdRvmtNFKGpfS142SqEcL8CE99hIKV+ZmbDnr/NQL2Slx46wxoDSB2U27NS77eN4oGZaj91G6PChZiubzgo2+i9AKJbEd/S5yKA5ZAnCwLL6IcfYe2aHWb1rF4SV9OjwQ9XylZGwwORFSIeLUakYnHEVAgh6U0D7elY49C1OZNrM09pIC8EaJtnyjdHiIqE4qiY+K2YleProNrUcLhk8Lm2k3SgrF/KVKhuUQVUzfKFmK5vOCvVBytMSb69NeolwS66954oXTvnF2en3b3XmlIo3LPXF4SReHXZ5b3zMlCKcpAVse9z38XXh2kvo9htvuppy+LqeP0LgvBo/IpIJ+b/kQrGUDaM4XPvlBR9IPVq3mlkDldKIJ5k0vnGyzNh2myYvdtJ0S3wLtJeZOybT8uEabQ3kPSkSRUDRhs3HpI2uhKwKZKC8elADStJcASJOg7IcrF9BZvVBCPVi0bg6LdHF4IOqNkvmNaVM2iMWBHqoKLD9TvghAE92ecjdXxkxveb8tHElMxB7PblETZ1G2zDe1eNbBMkVEGdsDl4k3d709uAk86RPY3k2b5lZOIzbxnN2c5xk+LM9jv8PZaIBFkSwWBw9CRWwlLJ3fVZPTuYkUyLT+KPP7VBGAQmGev5tHTGMUrbvDU/pyeNn1oOQLQ74d6yeA51Hyfnn6FWDtmF8bueyXvzx+5XB/3d6/4rbfL+8Bz8Ne++X+s4z5pp/QLrtf/vJ47/B3U/L9Q/Fp4P87fn7R/c+NfwQYAFx9eFOvgdoSAAAAAElFTkSuQmCC"/></p><style>.base64.sign {display: none;}</style><p id="P024F_4" class="formattext topleveltext indenttext" align="justify">- всех интерфейсных переменных с их предельными значениями;<br/><br/></p><p id="P024F_5" class="formattext topleveltext indenttext" align="justify">- всех отдельных интерфейсных переменных с их предельными значениями с другими интерфейсными переменными с их нормальными значениями;<br/><br/></p><p id="P024F_6" class="formattext topleveltext indenttext" align="justify">- всех значений предметной области каждой интерфейсной переменной с другими интерфейсными переменными с их нормальными значениями;<br/><br/></p><p id="P024F_7" class="formattext topleveltext indenttext" align="justify">- всех значений всех переменных в разных комбинациях (возможно только для небольших интерфейсов);<br/><br/></p><p id="P024F_8" class="formattext topleveltext indenttext" align="justify">- при специфицированных условиях тестирования, уместных для каждого вызова каждой подпрограммы.<br/><br/></p><p id="P024F_9" class="formattext topleveltext indenttext" align="justify">Эти тестирования особенно важны, если интерфейсы не имеют возможности обнаруживать неправильные значения параметров. Такие тестирования также важны при генерации новых конфигураций ранее существовавших подпрограмм.<br/><br/></p><p id="P0251" class="formattext topleveltext indenttext" align="justify"><b>С.5.4 Анализ граничных значений</b><br/><br/></p><p id="P0251_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблицы В.2, В.3 и В.8).<br/><br/><br/></p><p id="P0251_2" class="formattext topleveltext indenttext" align="justify">Цель. Обнаружение программных ошибок при предельных и граничных значениях параметров.<br/><br/></p><p id="P0251_3" class="formattext topleveltext indenttext" align="justify">Описание. Предметная входная область программы разделяется на множество входных классов в соответствии с отношениями эквивалентности (см. С.5.7). Тестирование должно охватывать границы и экстремальные значения классов. Данное тестирование проверяет совпадение границы предметной входной области в спецификации с границами, установленными программой. Использование нулевого значения как в непосредственных, так и в косвенных преобразованиях часто приводит к ошибкам. Особого внимания требуют:<br/><br/></p><p id="P0251_4" class="formattext topleveltext indenttext" align="justify">- нулевой делитель;<br/><br/></p><p id="P0251_5" class="formattext topleveltext indenttext" align="justify">- знаки пробела ASCII;<br/><br/></p><p id="P0251_6" class="formattext topleveltext indenttext" align="justify">- пустой стек или элемент списка;<br/><br/></p><p id="P0251_7" class="formattext topleveltext indenttext" align="justify">- заполненная матрица;<br/><br/></p><p id="P0251_8" class="formattext topleveltext indenttext" align="justify">- ввод нулевой таблицы.<br/><br/></p><p id="P0251_9" class="formattext topleveltext indenttext" align="justify">Обычно границы входных значений напрямую соотносятся с границами выходных значений. Для установления выходных параметров в их предельные значения необходимо записывать специальные тестовые примеры. Следует также по возможности рассмотреть спецификацию такого тестового примера, который побуждает выходное значение превысить установленные спецификацией граничные значения.<br/><br/></p><p id="P0251_10" class="formattext topleveltext indenttext" align="justify">Если выходные значения являются последовательностью данных, например, таблица, то особое внимание следует уделить первому и последнему элементам, а также спискам, содержащим либо ни одного, либо один, либо два элемента.<br/><br/></p><p id="P0251_11" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0251_12" class="formattext topleveltext indenttext" align="justify">The Art of Software Testing, second edition. G.J. Myers, T. Badgett, T.M. Codd, С. Sandler, John Wiley and Sons, 2004, ISBN 0471469122, 9780471469124.<br/><br/></p><p id="P0253" class="formattext topleveltext indenttext" align="justify"><b>С.5.5 Предположение ошибок</b><br/><br/></p><p id="P0253_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблицы В.2 и В.8).<br/><br/><br/></p><p id="P0253_2" class="formattext topleveltext indenttext" align="justify">Цель. Исключение ошибки программирования.<br/><br/></p><p id="P0253_3" class="formattext topleveltext indenttext" align="justify">Описание. Опыт тестирования и интуиция в сочетании со сведениями и заинтересованностью относительно тестируемой системы могут добавить некоторые неклассифицированные тестовые примеры к набору заданных тестовых примеров.<br/><br/></p><p id="P0253_4" class="formattext topleveltext indenttext" align="justify">Специальные значения или комбинации значений могут быть подвержены ошибкам. Некоторые вызывающие интерес тестовые примеры могут быть получены из анализа контрольных списков. Следует также рассмотреть, является ли система достаточно устойчивой. Например, следует ли нажимать клавиши на передней панели слишком быстро или слишком часто. Что произойдет, если две клавиши нажать одновременно.<br/><br/></p><p id="P0253_5" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0253_6" class="formattext topleveltext indenttext" align="justify">The Art of Software Testing, second edition. G.J. Myers, T. Badgett, T.M. Codd, С. Sandler, John Wiley and Sons, 2004, ISBN 0471469122, 9780471469124.<br/><br/></p><p id="P0255" class="formattext topleveltext indenttext" align="justify"><b>C.5.6 Введение ошибок</b><br/><br/></p><p id="P0255_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблица В.2).<br/><br/><br/></p><p id="P0255_2" class="formattext topleveltext indenttext" align="justify">Цель. Подтверждение адекватности набора тестовых примеров.<br/><br/></p><p id="P0255_3" class="formattext topleveltext indenttext" align="justify">Описание. Некоторые известные типы ошибок вводятся (подсеиваются) в программу, и программа выполняется с тестовыми примерами в режиме тестирования. При обнаружении только некоторых подсеянных ошибок тестовый пример становится неадекватным. Отношение числа найденных подсеянных ошибок к общему числу подсеянных ошибок оценивается как отношение числа найденных реальных ошибок к общему числу реальных ошибок. Это дает возможность оценить количество остаточных ошибок, и тем самым, остальную работу по тестированию.<br/><br/></p><p id="P0256" class="formattext topleveltext centertext" align="center"><img class="normal" src="https://api.docs.cntd.ru/img/12/00/10/32/42/135f542c-1dc5-4db8-9c2d-74263b12735c/P02560000.png" width="488" height="44"/>.</p><p id="P0257" class="formattext topleveltext indenttext" align="justify"><br/></p><p id="P0257_1" class="formattext topleveltext indenttext" align="justify">Обнаружение всех подсеянных ошибок может указывать либо на адекватность тестового примера, либо на то, что подсеянные ошибки было слишком легко найти. Ограничениями данного метода являются: порядок получения любых полезных результатов, типы ошибок. Также необходимо, чтобы позиции подсеивания отражали статистическое распределение реальных ошибок.<br/><br/></p><p id="P0257_2" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0257_3" class="formattext topleveltext indenttext" align="justify">Software Fault Injection: Inoculating Programs Against Errors. J. Voas, G. McGraw. Wiley Computer Pub., 1998, ISBN 0471183814, 9780471183815.<br/><br/></p><p id="P0257_4" class="formattext topleveltext indenttext" align="justify">Faults, Injection Methods, and Fault Attacks. Chong Нее Kim, Jean-Jacques Quisquater, IEEE Design and Test of Computers, vol. 24, No. 6, pp.544-545, Nov., 2007.<br/><br/></p><p id="P0257_5" class="formattext topleveltext indenttext" align="justify">Fault seeding for software reliability model validation. A. Pasquini, E. De Agostino. Control Engineering Practice, Volume 3, Issue 7, July 1995. Elsevier Science Ltd.<br/><br/></p><p id="P0259" class="formattext topleveltext indenttext" align="justify"><b>C.5.7 Разделение входных данных на классы эквивалентности</b><br/><br/></p><p id="P0259_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблицы В.2 и В.3).<br/><br/><br/></p><p id="P0259_2" class="formattext topleveltext indenttext" align="justify">Цель. Адекватное тестирование программных средств с использованием минимума тестируемых данных. Тестируемые данные образуются путем выбора частей входных данных предметной области, требующихся для анализа программных средств.<br/><br/></p><p id="P0259_3" class="formattext topleveltext indenttext" align="justify">Описание. Данный метод тестирования основывается на отношении эквивалентности входных данных, определяющем разбиение входных данных предметной области.<br/><br/></p><p id="P0259_4" class="formattext topleveltext indenttext" align="justify">Тестовые примеры выбираются в целях охвата всех предварительно специфицированных разбиений. Из каждого класса эквивалентности выбирается по меньшей мере один тестовый пример.<br/><br/></p><p id="P0259_5" class="formattext topleveltext indenttext" align="justify">Существуют следующие основные возможности разбиения входных данных:<br/><br/></p><p id="P0259_6" class="formattext topleveltext indenttext" align="justify">- классы эквивалентности, образованные из спецификации, - интерпретация спецификации может быть ориентирована либо на входные значения, например, выбранные значения считаются одинаковыми, либо ориентирована на выходные значения, например, набор значений приводит к одному и тому же функциональному результату;<br/><br/></p><p id="P0259_7" class="formattext topleveltext indenttext" align="justify">- классы эквивалентности, образованные в соответствии с внутренней структурой программы, - результаты класса эквивалентности определяются из статического анализа программ, например, набор значений обрабатывается одним и тем же способом.<br/><br/></p><p id="P0259_8" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0259_9" class="formattext topleveltext indenttext" align="justify">The Art of Software Testing, second edition. G.J. Myers, T. Badgett, T.M. Codd, С. Sandler, John Wiley and Sons, 2004, ISBN 0471469122, 9780471469124.<br/><br/></p><p id="P0259_10" class="formattext topleveltext indenttext" align="justify">Software engineering: Update. Ian Sommerville, Addison-Wesley Longman, Amsterdam; 8<img class="base64" src="data:image;base64,R0lGODdhDwAXAIABAAAAAP///ywAAAAADwAXAAACJIyPqcvtHwBw01R2r5J1apR5S2aNR2eW0ehJ0QfF8kzX9o0fBQA7" width="15" height="23"/> ed., 2006, ISBN 0321313798, 9780321313799.<br/><br/></p><p id="P0259_11" class="formattext topleveltext indenttext" align="justify">Software Engineering. Ian Sommerville, Pearson Studium, 8. Auflage, 2007, ISBN 3827372577, 9783827372574.<br/><br/></p><p id="P0259_12" class="formattext topleveltext indenttext" align="justify">Static Analysis and Software Assurance. D. Wagner, Lecture Notes in Computer Science, Volume 2126/2001, Springer, 2001, ISBN 978-3-540-42314-09.<br/><br/></p><p id="P025B" class="formattext topleveltext indenttext" align="justify"><b>С.5.8 Структурное тестирование</b><br/><br/></p><p id="P025B_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблица В.2).<br/><br/><br/></p><p id="P025B_2" class="formattext topleveltext indenttext" align="justify">Цель. Применение тестов, анализирующих определенные подмножества структуры программы.<br/><br/></p><p id="P025B_3" class="formattext topleveltext indenttext" align="justify">Описание. На основе анализа программы выбирается набор входных данных так, чтобы мог быть проанализирован достаточно большой (часто с заранее заданным значением) процент программных кодов. Меры охвата программы, в зависимости от степени требуемой строгости, могут быть различными. В любом случае целью должны быть 100% выбранной метрики охвата; если невозможно достигнуть 100%-ного охвата, то причины, почему 100%-ный охват не может быть достигнут, должны быть документально оформлены в отчете о тестировании (например если возникает аппаратная проблема, то может быть введен только код защиты). Первые четыре метода в следующем списке специально упомянуты в рекомендациях в таблице В.2 МЭК 61508-3 и широко поддерживаются инструментами тестирования; оставшиеся методы могут быть также рассмотрены:<br/><br/></p><p id="P025B_4" class="formattext topleveltext indenttext" align="justify">- охват точек входа (граф вызовов) - гарантирует, что каждая подпрограмма (стандартная подпрограмма или функция) по крайней мере однажды должна быть вызвана (это - наименее строгое структурное измерение охвата).<br/><br/></p><p id="P025B_5" class="formattext topleveltext indenttext" align="justify">Примечание - В объектно-ориентированных языках может быть несколько подпрограмм с одним и тем же именем, которые применяются к различным вариантам полиморфизма (переопределяющие подпрограммы), которые могут вызываться динамической диспетчеризацией. В таких случаях должна быть протестирована каждая такая переопределенная подпрограмма;<br/><br/><br/></p><p id="P025B_6" class="formattext topleveltext indenttext" align="justify">- операторы  - гарантирует, что все операторы в коде были выполнены по крайней мере однажды;<br/><br/></p><p id="P025B_7" class="formattext topleveltext indenttext" align="justify">- условные переходы - должны быть проверены обе ветви каждого условного перехода. Это может оказаться нецелесообразным для некоторых типов кодов защиты;<br/><br/></p><p id="P025B_8" class="formattext topleveltext indenttext" align="justify">- составные условия - анализируется каждое условие в составном условном переходе (связанное оператором И/ИЛИ). См. MCDC (охват условного модифицированного решения, документ DО178B);<br/><br/></p><p id="P025B_9" class="formattext topleveltext indenttext" align="justify">- LCSAJ - последовательность линейного кода и переходов представляет собой любую линейную последовательность закодированных утверждений, включая условные утверждения, заканчивающиеся переходом. Многие потенциальные подпоследовательности могут оказаться невыполнимыми из-за ограничений, которые налагаются на входные данные в результате выполнения предыдущего кода;<br/><br/></p><p id="P025B_10" class="formattext topleveltext indenttext" align="justify">- поток данных - выполняющиеся последовательности выбираются на основе используемых данных; например, последовательность, где одна и та же переменная и записывается, и считывается;<br/><br/></p><p id="P025B_11" class="formattext topleveltext indenttext" align="justify">- базовая последовательность - одна из минимального набора конечных последовательностей от начала до конца, когда все дуги охвачены (перекрывающиеся комбинации последовательностей в этом базовом наборе могут сформировать любую последовательность через эту часть программы). Тесты всех базовых последовательностей показали свою эффективность при обнаружении ошибок.<br/><br/></p><p id="P025B_12" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P025B_13" class="formattext topleveltext indenttext" align="justify">The Art of Software Testing, second edition. G.J. Myers, T. Badgett, T.M. Codd, С. Sandler, John Wiley and Sons, 2004, ISBN 0471469122, 9780471469124.<br/><br/></p><p id="P025B_14" class="formattext topleveltext indenttext" align="justify">Software engineering: Update. Ian Sommerville, Addison-Wesley Longman, Amsterdam; 8<img class="base64" src="data:image;base64,R0lGODdhDwAXAIABAAAAAP///ywAAAAADwAXAAACJIyPqcvtHwBw01R2r5J1apR5S2aNR2eW0ehJ0QfF8kzX9o0fBQA7" width="15" height="23"/> ed., 2006, ISBN 0321313798, 9780321313799.<br/><br/></p><p id="P025B_15" class="formattext topleveltext indenttext" align="justify">Software Engineering. Ian Sommerville, Pearson Studium, 8. Auflage, 2007, ISBN 3827372577, 9783827372574.<br/><br/></p><p id="P025B_16" class="formattext topleveltext indenttext" align="justify">RTCA, Inc. document DO-178B and EUROCAE document ED-12B, Software Considerations in Airborne Systems and Equipment Certification, dated December 1, 1992.<br/><br/></p><p id="P025D" class="formattext topleveltext indenttext" align="justify"><b>C.5.9 Анализ потоков управления</b><br/><br/></p><p id="P025D_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблица В.8).<br/><br/><br/></p><p id="P025D_2" class="formattext topleveltext indenttext" align="justify">Цель. Обнаружение низкокачественных и потенциально некорректных структур программ.<br/><br/></p><p id="P025D_3" class="formattext topleveltext indenttext" align="justify">Описание. Анализ потока управления представляет собой метод статического тестирования для нахождения подозреваемых областей программы, которые не соответствуют оправдавшей себя практике программирования. Программа анализируется, формируя направленный граф, который может быть проанализирован на наличие:<br/><br/></p><p id="P025D_4" class="formattext topleveltext indenttext" align="justify">- недоступных фрагментов программы, например, безусловных переходов, которые делают фрагменты программы недостижимыми;<br/><br/></p><p id="P025D_5" class="formattext topleveltext indenttext" align="justify">- запутанных кодов. Хорошо структурированный код имеет управляющий граф, допускающий сокращение путем последовательного сокращения графа до одного узла. В отличие от этого плохо структурированный код может быть сокращен только до группы, состоящей из нескольких узлов.<br/><br/></p><p id="P025D_6" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P025D_7" class="formattext topleveltext indenttext" align="justify">Software engineering: Update. Ian Sommerville, Addison-Wesley Longman, Amsterdam; 8<img class="base64" src="data:image;base64,R0lGODdhDwAXAIABAAAAAP///ywAAAAADwAXAAACJIyPqcvtHwBw01R2r5J1apR5S2aNR2eW0ehJ0QfF8kzX9o0fBQA7" width="15" height="23"/> ed., 2006, ISBN 0321313798, 9780321313799.<br/><br/></p><p id="P025D_8" class="formattext topleveltext indenttext" align="justify">Software Engineering. Ian Sommerville, Pearson Studium, 8. Auflage, 2007, ISBN 3827372577, 9783827372574.<br/><br/></p><p id="P025F" class="formattext topleveltext indenttext" align="justify"><b>C.5.10 Анализ потока данных</b><br/><br/></p><p id="P025F_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблица В.8).<br/><br/><br/></p><p id="P025F_2" class="formattext topleveltext indenttext" align="justify">Цель. Обнаружение низкокачественных и потенциально некорректных структур программ.<br/><br/></p><p id="P025F_3" class="formattext topleveltext indenttext" align="justify">Описание. Анализ потока данных представляет собой метод статического тестирования, объединяющий информацию, полученную из анализа потока управления, с информацией о том, какие переменные считываются или записываются в различных частях кода. Данный метод может проверять:<br/><br/></p><p id="P025F_4" class="formattext topleveltext indenttext" align="justify">- переменные, которые могут быть считаны до присвоения им значений. Такую ситуацию можно исключить, если всегда присваивать значение при объявлении новой переменной;<br/><br/></p><p id="P025F_5" class="formattext topleveltext indenttext" align="justify">- переменные, записанные несколько раз, но несчитанные. Такая ситуация может указывать на пропущенный код;<br/><br/></p><p id="P025F_6" class="formattext topleveltext indenttext" align="justify">- переменные, которые записаны, но никогда не считываются. Такая ситуация может указывать избыточный код.<br/><br/></p><p id="P025F_7" class="formattext topleveltext indenttext" align="justify">Аномальный поток данных не всегда непосредственно соответствует программным ошибкам, но если аномалии исключены, то маловероятно, что код будет содержать ошибки.<br/><br/></p><p id="P025F_8" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P025F_9" class="formattext topleveltext indenttext" align="justify">Software engineering: Update. Ian Sommerville, Addison-Wesley Longman, Amsterdam; 8<img class="base64" src="data:image;base64,R0lGODdhDwAXAIABAAAAAP///ywAAAAADwAXAAACJIyPqcvtHwBw01R2r5J1apR5S2aNR2eW0ehJ0QfF8kzX9o0fBQA7" width="15" height="23"/> ed., 2006, ISBN 0321313798, 9780321313799.<br/><br/></p><p><img class="base64 sign" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZIAAAARCAMAAADAD9oKAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MTg4Q0U3ODQ0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MTg4Q0U3ODU0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoxODhDRTc4MjRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDoxODhDRTc4MzRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pos3t18AAAAzUExURfX19SQkJOrq6oeHh7y8vD8/P9/f31RUVMjIyLCwsHh4eJaWlmdnZ6Ojo9TU1AAAAP////kimdMAAAWSSURBVHja7FiJcuQoDAVzGcz1/1+7TwLRuDs9mZ2karZqQ1ViGz90PUngVv1nfMOo9fg2WarnNkf9FGxMHdDkf1jo3bXBg7o0YhIkfrXV0npvBfd48y94HQtV97XWZvBPfbpG29oikGfQ6oeRs4WLb4K2CGNq5wsltpX6B5TQYEa5/u6h9rdn31QdtXS0iKX1WZ360/o9Pl/3NmVq/ahk/cfwZ0X+bSL6T01Kxmq6Fj0MSDNPj+atGzF1+Y17z9IZMRfulHiH+ivMFvE7nm2ffQ26Q5+U0AKLatWUGFm63kU3SJycuwqNLgNJ1ONf6crorUNyEySMStQLlegNgSuSmiT5agizm0YyZwPNbEXLM64y2X0YcGgdN3ytU9FaLDCecHbCyFWVh0kjMvBEHK+rvx/tVIgOWSoTcZrRa+aVJxeOuLc5nG8Oj2cjCzdKDm1Uj9BCSFeO7sKBgKCxRWpXKNAiFtV2njBAGeqm2QBQaZKCjjDCA+vqnZJD802sAzu9q4EwRtde4djUG4kJeFObpsag4cXNNJKJejRY7pVO9EJiQf2XRJLlBEcW1Toooc48FcniBeN2nOALwwzMDXhDJv2CkoKENkS/NKzu0p74rRyOk0vcezgs0iXQhLDixE4J6YAALgUqoEq6VKpih0KosOuUUihxM+eGo6KIA3DEaTI8oJS7UZIybnhmOVX1wCiqLJSYmnr52WjShadTA7Obtsyl2lP22PquxG9kJ1VbSWN2gEXRfF4wlnri36xnTJBYC+R7ShyX17HNDIcXJSg8ddMqDi/p0+HOCGNfKclwPmdHBsVgp9mbHaemuwBMwtvmCK2pQqtwdpakiZIQg7pTAitwc+m6OVWyWFhnzQy9aMrcDZASSAJjgNlMo5R4UIJ1xbhnSsYr+p/LRslS1FfshQFIpb4v06WRvgBky4VfseOmPqy3zaKiZqp/SEmpOqhdqzi8pE+H6/2wu1PiCg9AkvOvlJi0r2ZbS7FooaMpdo8WYy6ixPFRZKcEE9Iz115irhdKWC/y1VquyIpWqU+i5GEapcRWJaGFFN9T4s7foyRQdqmNkqHvGJmn82AtUzed1s9vB63U6jj6ulOCnnbtWsXhJX06/J6S5LbDmKYuy/W11rgbobKpdRvmtNFKGpfS142SqEcL8CE99hIKV+ZmbDnr/NQL2Slx46wxoDSB2U27NS77eN4oGZaj91G6PChZiubzgo2+i9AKJbEd/S5yKA5ZAnCwLL6IcfYe2aHWb1rF4SV9OjwQ9XylZGwwORFSIeLUakYnHEVAgh6U0D7elY49C1OZNrM09pIC8EaJtnyjdHiIqE4qiY+K2YleProNrUcLhk8Lm2k3SgrF/KVKhuUQVUzfKFmK5vOCvVBytMSb69NeolwS66954oXTvnF2en3b3XmlIo3LPXF4SReHXZ5b3zMlCKcpAVse9z38XXh2kvo9htvuppy+LqeP0LgvBo/IpIJ+b/kQrGUDaM4XPvlBR9IPVq3mlkDldKIJ5k0vnGyzNh2myYvdtJ0S3wLtJeZOybT8uEabQ3kPSkSRUDRhs3HpI2uhKwKZKC8elADStJcASJOg7IcrF9BZvVBCPVi0bg6LdHF4IOqNkvmNaVM2iMWBHqoKLD9TvghAE92ecjdXxkxveb8tHElMxB7PblETZ1G2zDe1eNbBMkVEGdsDl4k3d709uAk86RPY3k2b5lZOIzbxnN2c5xk+LM9jv8PZaIBFkSwWBw9CRWwlLJ3fVZPTuYkUyLT+KPP7VBGAQmGev5tHTGMUrbvDU/pyeNn1oOQLQ74d6yeA51Hyfnn6FWDtmF8bueyXvzx+5XB/3d6/4rbfL+8Bz8Ne++X+s4z5pp/QLrtf/vJ47/B3U/L9Q/Fp4P87fn7R/c+NfwQYAFx9eFOvgdoSAAAAAElFTkSuQmCC"/></p><style>.base64.sign {display: none;}</style><p id="P025F_10" class="formattext topleveltext indenttext" align="justify">Software Engineering. Ian Sommerville, Pearson Studium, 8. Auflage, 2007, ISBN 3827372577, 9783827372574.<br/><br/></p><p id="P0261" class="formattext topleveltext indenttext" align="justify"><b>C.5.11 Тестирование на символьном уровне</b><br/><br/></p><p id="P0261_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблица В.8).<br/><br/><br/></p><p id="P0261_2" class="formattext topleveltext indenttext" align="justify">Цель. Показать соответствие между исходным кодом и спецификацией.<br/><br/></p><p id="P0261_3" class="formattext topleveltext indenttext" align="justify">Описание. Переменные программы оцениваются после замены во всех операторах присваивания левой его части на правую. Условные ветви и циклы преобразуются в булевские выражения. Окончательный результат представляет собой символьное выражение для каждой переменной программы. Это выражение является формулой для значения, которое программа вычислила бы, если задать реальные данные. Оно может быть проверено относительно предполагаемого выражения.<br/><br/></p><p id="P0261_4" class="formattext topleveltext indenttext" align="justify">Такое использование символьного выполнения является систематическим способом генерации тестовых данных для ветвей логики программы. Символьное средство выполнения может быть включено в интегрированный комплекс инструментальных средств для выполнения тестирования и анализа кода элемента программного обеспечения.<br/><br/></p><p id="P0261_5" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0261_6" class="formattext topleveltext indenttext" align="justify">Using symbolic execution for verifying safety-critical systems. A. Coen-Porisini, G. Denaro, С. Ghezzi, M. <img class="base64" src="data:image;base64,R0lGODdhJQAQAIABAAAAAP///ywAAAAAJQAQAAACQIyPqcvtD6MEDFgra6OH54l4l3GVY3AqHkp24cu2aunKdiwua0ffYp/Y3Xywja62StaCFQzK1Et9ptSq9YqdFgAAOw==" width="37" height="16"/>. Proceedings of the 8<img class="base64" src="data:image;base64,R0lGODdhDwAXAIABAAAAAP///ywAAAAADwAXAAACJIyPqcvtHwBw01R2r5J1apR5S2aNR2eW0ehJ0QfF8kzX9o0fBQA7" width="15" height="23"/> European software engineering conference, and 9th ACM SIGSOFT international symposium on Foundations of software engineering. ACM, 2001, ISBN:1-58113-390-1.<br/><br/></p><p id="P0261_7" class="formattext topleveltext indenttext" align="justify">Using symbolic execution to guide test generation. G. Lee, J. Morris, K. Parker, G. Bundell, P. Lam. In Software Testing, Verification and Reliability, vol. 15, No. 1, 2005. John Wiley &amp; Sons, Ltd.<br/><br/></p><p id="P0263" class="formattext topleveltext indenttext" align="justify"><b>C.5.12 Формальное доказательство (верификация)</b><br/><br/></p><p id="P0263_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблицы А.5 и А.9).<br/><br/><br/></p><p id="P0263_2" class="formattext topleveltext indenttext" align="justify">Цель. Доказать правильность программы относительно некоторой абстрактной модели программы, используя теоретические и математические модели и правила.<br/><br/></p><p id="P0263_3" class="formattext topleveltext indenttext" align="justify">Описание. Тестирование - распространенный способ исследовать правильность программы. Однако исчерпывающее тестирование обычно недостижимо ввиду сложности программ, имеющих практическое значение, поэтому таким способом может быть исследована только часть возможного поведения программы. Напротив, формальная верификация применяет математические операции к математическому представлению программы, чтобы установить, что программа ведет себя, как определено для всех возможных входных данных.<br/><br/></p><p id="P0263_4" class="formattext topleveltext indenttext" align="justify">Для формальной верификации системы требуется абстрактная модель программы и ее заданное поведение (то есть спецификация), представленные на формальном языке. Спецификация может быть полной или она может быть ограничена определенными свойствами программы:<br/><br/></p><p id="P0263_5" class="formattext topleveltext indenttext" align="justify">- свойствами функциональной корректности, то есть программа должна продемонстрировать определенную функциональность;<br/><br/></p><p id="P0263_6" class="formattext topleveltext indenttext" align="justify">- свойствами безопасности (то есть неправильное поведение никогда не будет происходить), и живучести (то есть в конечном счете будет вести себя правильно);<br/><br/></p><p id="P0263_7" class="formattext topleveltext indenttext" align="justify">- синхронизирующими свойствами, то есть события, реализующие поведение, произойдут в определенное время.<br/><br/></p><p id="P0263_8" class="formattext topleveltext indenttext" align="justify">Результатом формальной верификации является строгий вывод о том, что абстрактная модель программы корректна относительно спецификации для всех возможных входных данных, то есть модель удовлетворяет заданным свойствам.<br/><br/></p><p id="P0263_9" class="formattext topleveltext indenttext" align="justify">Однако правильность модели непосредственно не доказывает правильность фактической программы, поэтому далее необходим шаг, который должен показать, что модель - точная абстракция фактической программы для моделируемых свойств. Некоторые свойства программы, представляющие практический интерес, не могут быть формально описаны (например большинство проблем синхронизации и планирования или субъективные свойства, такие как &quot;ясный и простой&quot; пользовательский интерфейс, или, на самом деле, любое свойство или цель проекта, которые не могут быть легко представлены на формальном языке). Поэтому формальная верификация не полностью заменяет моделирование и тестирование, но зато она дополняет эти методы, обеспечивая их доказательством корректности работы программы для всех входных данных. Формальная верификация может гарантировать корректность абстрактной модели программы, а тестирование гарантирует, что фактическая программа ведет себя, как ожидалось.<br/><br/></p><p id="P0263_10" class="formattext topleveltext indenttext" align="justify">Использование формальной верификации на стадии проектирования может значительно уменьшить время разработки, обнаруживая существенные ошибки и упущения на ранних стадиях проектирования, и таким образом сократить время, необходимое на итерации между проектированием и тестированием.<br/><br/></p><p id="P0263_11" class="formattext topleveltext indenttext" align="justify">Ряд формальных методов, применяющихся на практике, описаны в С.2.4: например, CCS, CSP, HOL, LOTOS, OBJ, временная логика, VDM и Z.<br/><br/></p><p id="P0265" class="formattext topleveltext indenttext" align="justify">С.5.12.1 Проверка модели<br/><br/></p><p id="P0265_1" class="formattext topleveltext indenttext" align="justify">Проверка модели - метод для формальной верификации реактивных и конкурентных систем. Задавая конечное состояние структуры, которая описывает поведение системы, проверяется свойство, записанное в виде формулы во временной логике, удовлетворяет оно или нет структуре. Для автоматического и исчерпывающего прохода всех состояний структуры используются эффективные алгоритмы (например SPIN, SMV и UPPAAL). Если свойство не удовлетворяется, то генерируется контрпример. Эта процедура показывает, как свойства нарушаются в структуре, и содержит очень полезную информацию для исследования системы. Метод проверки модели может обнаружить &quot;глубокие ошибки&quot;, которые могут быть не обнаружены при обычном контроле и тестировании.<br/><br/></p><p id="P0265_2" class="formattext topleveltext indenttext" align="justify">Необходимо отметить, что метод проверки модели полезен при анализе нюансов сложной структуры. Это может быть полезно для некоторых приложений с низким УПБ, но необходимо быть очень внимательным, если нюансы сложной структуры существуют в приложениях с высоким УПБ.<br/><br/></p><p id="P0265_3" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0265_4" class="formattext topleveltext indenttext" align="justify">Is Proof More Cost-Effective Than Testing? S. King, R. Chapman, J. Hammond, A. Pryor. IEEE Transactions on Software Engineering, vol. 26, No. 8, August 2000.<br/><br/></p><p id="P0265_5" class="formattext topleveltext indenttext" align="justify">Model Checking. E.M. Clarke, O. Grumberg, and D.A. Peled. MIT Press, 1999, ISBN 0262032708, 9780262032704.<br/><br/></p><p id="P0265_6" class="formattext topleveltext indenttext" align="justify">Systems and Software Verification: Model-Checking Techniques and Tools. B. Berard, M. Bidoit, A. Finkel, F. Laroussinie, A. Petit, L. Petrucci, Ph. Schnoebelen, and P. Mckenzie, Springer, 2001, ISBN 3-540-41523-8.<br/><br/></p><p id="P0265_7" class="formattext topleveltext indenttext" align="justify">Logic in Computer Science: Modelling and Reasoning about Systems. M. Huth and M. Ryan. Cambridge University Press, 2000, ISBN 0521652006, 0521656028.<br/><br/></p><p id="P0265_8" class="formattext topleveltext indenttext" align="justify">The Spin Model Checker: Primer and Reference Manual. G.J. Holzmann. Addison-Wesley, 2003, ISBN 0321228626, 9780321228628.<br/><br/></p><p id="P0267" class="formattext topleveltext indenttext" align="justify">C.5.12.2 (He используется.)<br/><br/></p><p id="P0269" class="formattext topleveltext indenttext" align="justify"><b>C.5.13 Метрики сложности программного обеспечения</b><br/><br/></p><p id="P0269_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблицы А.9 и С.19).<br/><br/></p><p id="P0269_2" class="formattext topleveltext indenttext" align="justify">Цель. Прогнозирование характеристик программ исходя из свойств самих программ или их разработки, либо предысторий тестирования.<br/><br/></p><p id="P0269_3" class="formattext topleveltext indenttext" align="justify">Описание. Данные методы оценивают некоторые структурные свойства программных средств и их отношения к требуемым характеристикам, например, надежность или сложность. Для оценки большинства средств требуются программные инструменты. Некоторые применяющиеся метрики перечислены ниже:<br/><br/></p><p id="P0269_4" class="formattext topleveltext indenttext" align="justify">- теоретическая сложность графа. Эта метрика может быть применена на раннем этапе жизненного цикла для оценки компромиссных решений и основана на величине сложности графа управления программы, представленной ее цикломатическим числом;<br/><br/></p><p id="P0269_5" class="formattext topleveltext indenttext" align="justify">- число способов активизации некоторых программных модулей (доступность) - чем больше программных модулей может быть доступно, тем должна быть большая вероятность их отладки;<br/><br/></p><p id="P0269_6" class="formattext topleveltext indenttext" align="justify">- теория метрик Холстеда. При помощи этих средств вычисляют длину программы путем подсчета количества операторов и операндов; данная метрика дает меру сложности и размеры, которые формируют основу для сравнений при оценке будущих разрабатываемых ресурсов;<br/><br/></p><p id="P0269_7" class="formattext topleveltext indenttext" align="justify">- число входов и выходов на программный модуль. Сведение к минимуму числа точек входов/выходов является ключевой особенностью методов структурного проектирования и программирования.<br/><br/></p><p id="P0269_8" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0269_9" class="formattext topleveltext indenttext" align="justify">Metrics and Models in Software Quality Engineering. S.H. Kan. Addison-Wesley, 2003, ISBN 0201729156, 9780201729153.<br/><br/></p><p id="P026B" class="formattext topleveltext indenttext" align="justify"><b>C.5.14 Формальные проверки</b><br/><br/></p><p id="P026B_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблица В.8).<br/><br/></p><p id="P026B_2" class="formattext topleveltext indenttext" align="justify">Цель. Обнаружение ошибок в элементе программного обеспечения.<br/><br/></p><p id="P026B_3" class="formattext topleveltext indenttext" align="justify">Описание. Формальный контроль - структурированный процесс проверки материалов о программном обеспечении, который выполняется коллегами разработчика этого материала в целях найти ошибки и помочь разработчику улучшить материал. Разработчик не должен принимать участие в процессе контроля, кроме информирования проверяющих на этапе их ознакомления с материалами. Формальные проверки могут быть выполнены для конкретных элементов программного обеспечения, созданных на любой стадии жизненного цикла разработки программного обеспечения.<br/><br/></p><p id="P026B_4" class="formattext topleveltext indenttext" align="justify">Проверяющие должны ознакомиться с проверяемыми материалами до выполнения проверки. Роли проверяющих в процессе проверки должны быть ясно определены. Должна быть подготовлена программа проверки. Должны быть определены входные и выходные критерии, основанные на требуемых характеристиках элемента программного обеспечения. Входные критерии - это такие критерии или требования, которые должны быть удовлетворены до выполнения проверки. Выходные критерии - это такие критерии или требования, которые должны быть удовлетворены, чтобы считать процесс проверки завершенным успешно.<br/><br/></p><p id="P026B_5" class="formattext topleveltext indenttext" align="justify">В процессе проверки ее результаты должны быть формально зафиксированы модератором, роль которого должна упростить проверку. По результатам всеми проверяющими должно быть достигнуто согласие. Ошибки должны быть разделены на: а) требующие исправления до принятия элемента программного обеспечения и b) требующие исправления к заданному моменту времени или этапу. После завершения проверки выявленные ошибки должны быть переданы разработчику для последующего исправления. В зависимости от количества и контекста выявленных ошибок модератор может решить вопрос о необходимости повторной проверки материалов о программном обеспечении.<br/><br/></p><p id="P026B_6" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P026B_7" class="formattext topleveltext indenttext" align="justify">Software engineering: Update. Ian Sommerville, Addison-Wesley Longman, Amsterdam; 8<img class="base64" src="data:image;base64,R0lGODdhDwAXAIABAAAAAP///ywAAAAADwAXAAACJIyPqcvtHwBw01R2r5J1apR5S2aNR2eW0ehJ0QfF8kzX9o0fBQA7" width="15" height="23"/> ed., 2006, ISBN 0321313798, 9780321313799.<br/><br/></p><p id="P026B_8" class="formattext topleveltext indenttext" align="justify">Software Engineering. Ian Sommerville, Pearson Studium, 8. Auflage, 2007, ISBN 3827372577, 9783827372574.<br/><br/></p><p id="P026B_9" class="formattext topleveltext indenttext" align="justify">The Art of Software Testing, second edition. G.J. Myers, T. Badgett, T.M. Codd, С. Sandler, John Wiley and Sons, 2004, ISBN 0471469122, 9780471469124.<br/><br/></p><p id="P026B_10" class="formattext topleveltext indenttext" align="justify">Fagan, M. Design and Code Inspections to Reduce Errors in Program Development. IBM Systems Journal 15, 3 (1976): 182-211.<br/><br/></p><p id="P026D" class="formattext topleveltext indenttext" align="justify"><b>C.5.15 Сквозной контроль (программного обеспечения)</b><br/><br/></p><p id="P026D_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблица В.8).<br/><br/></p><p id="P026D_2" class="formattext topleveltext indenttext" align="justify">Цель. Обнаружение несоответствий между спецификацией и реализацией.<br/><br/></p><p id="P026D_3" class="formattext topleveltext indenttext" align="justify">Описание. Сквозной контроль является неформальным методом, выполняемым разработчиком элемента программного обеспечения в присутствии его коллег в целях обнаружения ошибок в элементе программного обеспечения. Он может быть выполнен для конкретных элементов программного обеспечения, созданных на любой стадии жизненного цикла разработки программного обеспечения.<br/><br/></p><p id="P026D_4" class="formattext topleveltext indenttext" align="justify">Чтобы гарантировать, что система, связанная с безопасностью, соответствует требованиям, заданным в спецификации, необходимо исследовать и оценить заданные в спецификации функции системы, связанной с безопасностью. Любые сомнения, связанные с реализацией и использованием создаваемой системы, документально оформляются в целях их дальнейшего решения. В отличие от формальной проверки в процедуре сквозного контроля разработчик принимает активное участие.<br/><br/></p><p id="P026D_5" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P026D_6" class="formattext topleveltext indenttext" align="justify">Software engineering: Update. Ian Sommerville, Addison-Wesley Longman, Amsterdam; 8<img class="base64" src="data:image;base64,R0lGODdhDwAXAIABAAAAAP///ywAAAAADwAXAAACJIyPqcvtHwBw01R2r5J1apR5S2aNR2eW0ehJ0QfF8kzX9o0fBQA7" width="15" height="23"/> ed., 2006, ISBN 0321313798, 9780321313799.<br/><br/></p><p id="P026D_7" class="formattext topleveltext indenttext" align="justify">Software Engineering. Ian Sommerville, Pearson Studium, 8. Auflage, 2007, ISBN 3827372577, 9783827372574.<br/><br/></p><p id="P026D_8" class="formattext topleveltext indenttext" align="justify">The Art of Software Testing, second edition. G.J. Myers, T. Badgett, T.M. Codd, С. Sandler, John Wiley and Sons, 2004, ISBN 0471469122, 9780471469124.<br/><br/></p><p id="P026F" class="formattext topleveltext indenttext" align="justify"><b>C.5.16 Анализ проекта</b><br/><br/></p><p id="P026F_1" class="formattext topleveltext indenttext" align="justify">Примечаниe - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблица В.8).<br/><br/><br/></p><p id="P026F_2" class="formattext topleveltext indenttext" align="justify">Цель. Выявление дефектов в проекте программного обеспечения.<br/><br/></p><p id="P026F_3" class="formattext topleveltext indenttext" align="justify">Описание. Под анализом проекта понимается формальное, документально оформленное, всестороннее и систематическое исследование проекта программного обеспечения в целях оценки требований к проекту и возможности проекта удовлетворить этим требованиям, а также для определения проблем и предложений по их решению.<br/><br/></p><p id="P026F_4" class="formattext topleveltext indenttext" align="justify">Анализ проекта является средством оценки соответствия состояния проекта входным требованиям, а также средством идентификации возможностей для его дальнейшего усовершенствования. Даже если разработка проекта на этапах жизненного цикла выполняется успешно и основные конкретные проектные требования удовлетворены, то анализ проекта должен быть выполнен, чтобы исследовать все интерфейсные аспекты; гарантировать, что проект может быть верифицирован, чтобы быть уверенным, что он удовлетворяет проектным требованиям; и гарантировать, что проект в наибольшей степени удовлетворяет требованиям безопасности. Такой анализ, прежде всего, предназначен для проверки результатов работы разработчиков и должен рассматриваться как действия по подтверждению и совершенствованию этих результатов.<br/><br/></p><p id="P026F_5" class="formattext topleveltext indenttext" align="justify">Чтобы обнаружить неправильное поведение программного обеспечения, такое как непредвиденные последовательности выполнения операторов или логики, непреднамеренные выходы, неправильная синхронизация, нежелательные действия, может использоваться строгий метод проверки, такой как &quot;анализ скрытых схем&quot;.<br/><br/></p><p id="P026F_6" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P026F_7" class="formattext topleveltext indenttext" align="justify">Software engineering: Update. Ian Sommerville, Addison-Wesley Longman, Amsterdam; 8<img class="base64" src="data:image;base64,R0lGODdhDwAXAIABAAAAAP///ywAAAAADwAXAAACJIyPqcvtHwBw01R2r5J1apR5S2aNR2eW0ehJ0QfF8kzX9o0fBQA7" width="15" height="23"/> ed., 2006, ISBN 0321313798, 9780321313799.<br/><br/></p><p id="P026F_8" class="formattext topleveltext indenttext" align="justify">Software Engineering. Ian Sommerville, Pearson Studium, 8. Auflage, 2007, ISBN 3827372577, 9783827372574.<br/><br/></p><p id="P026F_9" class="formattext topleveltext indenttext" align="justify">The Art of Software Testing, second edition. G.J. Myers, T. Badgett, T.M. Codd, С. Sandler, John Wiley and Sons, 2004, ISBN 0471469122, 9780471469124.<br/><br/></p><p id="P026F_10" class="formattext topleveltext indenttext" align="justify">IEC 61160:2005, Design review.<br/><br/></p><p id="P026F_11" class="formattext topleveltext indenttext" align="justify">Space Product Assurance, Sneak analysis - Part 2: Clue list. ECSS-Q-40-04A Part 2. ESA Publications Division, Noordwijk, 1997, ISSN 1028-396X, htpp://www.everyspec.com/ESA/ECSS-Q-40-04A_Part-2_14981/.<br/><br/></p><p id="P0271" class="formattext topleveltext indenttext" align="justify"><b>C.5.17 Макетирование/анимация</b><br/><br/></p><p id="P0271_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблицы В.3 и В.5).<br/><br/><br/></p><p id="P0271_2" class="formattext topleveltext indenttext" align="justify">Цель. Проверка возможности реализации системы при наличии заданных ограничений. Увязка интерпретации разработчика спецификации системы с ее потребителем для исключения непонимания между ними.<br/><br/></p><p id="P0271_3" class="formattext topleveltext indenttext" align="justify">Описание. Выделяются подмножество системных функций, ограничения и требования к рабочим параметрам. С помощью инструментов высокого уровня строится макет. На данном этапе не требуется рассматривать ограничения, например, используемый компьютер, язык реализации, объем программ, обслуживание, надежность и доступность. Макет оценивается по критериям потребителя, и системные требования могут быть модифицированы в свете этой оценки.<br/><br/></p><p id="P0271_4" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0271_5" class="formattext topleveltext indenttext" align="justify">Software Engineering for Real-time Systems. J.E. Cooling, Pearson Education, 2003, ISBN 0201596202, 9780201596205.<br/><br/></p><p id="P0273" class="formattext topleveltext indenttext" align="justify"><b>C.5.18 Моделирование процесса</b><br/><br/></p><p id="P0273_1" class="formattext topleveltext indenttext" align="justify">Примечаниe - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблицы A.7, С.7, В.3 и С.13).<br/><br/><br/></p><p><img class="base64 sign" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZIAAAARCAMAAADAD9oKAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MTg4Q0U3ODQ0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MTg4Q0U3ODU0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoxODhDRTc4MjRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDoxODhDRTc4MzRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pos3t18AAAAzUExURfX19SQkJOrq6oeHh7y8vD8/P9/f31RUVMjIyLCwsHh4eJaWlmdnZ6Ojo9TU1AAAAP////kimdMAAAWSSURBVHja7FiJcuQoDAVzGcz1/1+7TwLRuDs9mZ2karZqQ1ViGz90PUngVv1nfMOo9fg2WarnNkf9FGxMHdDkf1jo3bXBg7o0YhIkfrXV0npvBfd48y94HQtV97XWZvBPfbpG29oikGfQ6oeRs4WLb4K2CGNq5wsltpX6B5TQYEa5/u6h9rdn31QdtXS0iKX1WZ360/o9Pl/3NmVq/ahk/cfwZ0X+bSL6T01Kxmq6Fj0MSDNPj+atGzF1+Y17z9IZMRfulHiH+ivMFvE7nm2ffQ26Q5+U0AKLatWUGFm63kU3SJycuwqNLgNJ1ONf6crorUNyEySMStQLlegNgSuSmiT5agizm0YyZwPNbEXLM64y2X0YcGgdN3ytU9FaLDCecHbCyFWVh0kjMvBEHK+rvx/tVIgOWSoTcZrRa+aVJxeOuLc5nG8Oj2cjCzdKDm1Uj9BCSFeO7sKBgKCxRWpXKNAiFtV2njBAGeqm2QBQaZKCjjDCA+vqnZJD802sAzu9q4EwRtde4djUG4kJeFObpsag4cXNNJKJejRY7pVO9EJiQf2XRJLlBEcW1Toooc48FcniBeN2nOALwwzMDXhDJv2CkoKENkS/NKzu0p74rRyOk0vcezgs0iXQhLDixE4J6YAALgUqoEq6VKpih0KosOuUUihxM+eGo6KIA3DEaTI8oJS7UZIybnhmOVX1wCiqLJSYmnr52WjShadTA7Obtsyl2lP22PquxG9kJ1VbSWN2gEXRfF4wlnri36xnTJBYC+R7ShyX17HNDIcXJSg8ddMqDi/p0+HOCGNfKclwPmdHBsVgp9mbHaemuwBMwtvmCK2pQqtwdpakiZIQg7pTAitwc+m6OVWyWFhnzQy9aMrcDZASSAJjgNlMo5R4UIJ1xbhnSsYr+p/LRslS1FfshQFIpb4v06WRvgBky4VfseOmPqy3zaKiZqp/SEmpOqhdqzi8pE+H6/2wu1PiCg9AkvOvlJi0r2ZbS7FooaMpdo8WYy6ixPFRZKcEE9Iz115irhdKWC/y1VquyIpWqU+i5GEapcRWJaGFFN9T4s7foyRQdqmNkqHvGJmn82AtUzed1s9vB63U6jj6ulOCnnbtWsXhJX06/J6S5LbDmKYuy/W11rgbobKpdRvmtNFKGpfS142SqEcL8CE99hIKV+ZmbDnr/NQL2Slx46wxoDSB2U27NS77eN4oGZaj91G6PChZiubzgo2+i9AKJbEd/S5yKA5ZAnCwLL6IcfYe2aHWb1rF4SV9OjwQ9XylZGwwORFSIeLUakYnHEVAgh6U0D7elY49C1OZNrM09pIC8EaJtnyjdHiIqE4qiY+K2YleProNrUcLhk8Lm2k3SgrF/KVKhuUQVUzfKFmK5vOCvVBytMSb69NeolwS66954oXTvnF2en3b3XmlIo3LPXF4SReHXZ5b3zMlCKcpAVse9z38XXh2kvo9htvuppy+LqeP0LgvBo/IpIJ+b/kQrGUDaM4XPvlBR9IPVq3mlkDldKIJ5k0vnGyzNh2myYvdtJ0S3wLtJeZOybT8uEabQ3kPSkSRUDRhs3HpI2uhKwKZKC8elADStJcASJOg7IcrF9BZvVBCPVi0bg6LdHF4IOqNkvmNaVM2iMWBHqoKLD9TvghAE92ecjdXxkxveb8tHElMxB7PblETZ1G2zDe1eNbBMkVEGdsDl4k3d709uAk86RPY3k2b5lZOIzbxnN2c5xk+LM9jv8PZaIBFkSwWBw9CRWwlLJ3fVZPTuYkUyLT+KPP7VBGAQmGev5tHTGMUrbvDU/pyeNn1oOQLQ74d6yeA51Hyfnn6FWDtmF8bueyXvzx+5XB/3d6/4rbfL+8Bz8Ne++X+s4z5pp/QLrtf/vJ47/B3U/L9Q/Fp4P87fn7R/c+NfwQYAFx9eFOvgdoSAAAAAElFTkSuQmCC"/></p><style>.base64.sign {display: none;}</style><p id="P0273_2" class="formattext topleveltext indenttext" align="justify">Цель. Тестирование функции программной системы вместе с ее интерфейсами во внешнем окружении, не допуская модификации реального окружения.<br/><br/></p><p id="P0273_3" class="formattext topleveltext indenttext" align="justify">Описание. Создание системы только для целей тестирования, имитирующей поведение управляемого оборудования (УО).<br/><br/></p><p id="P0273_4" class="formattext topleveltext indenttext" align="justify">Имитация может осуществляться только программными средствами либо сочетанием программных и аппаратных средств. Она должна:<br/><br/></p><p id="P0273_5" class="formattext topleveltext indenttext" align="justify">- обеспечить входные данные, эквивалентные тем, которые реализуются на реальной установке УО;<br/><br/></p><p id="P0273_6" class="formattext topleveltext indenttext" align="justify">- реагировать на выходные результаты тестирования программных средств способом, точно отражающим объект управления;<br/><br/></p><p id="P0273_7" class="formattext topleveltext indenttext" align="justify">- иметь возможность для оператора вводить входные данные, чтобы обеспечить любые возмущения, с которыми должна справиться тестируемая система.<br/><br/></p><p id="P0273_8" class="formattext topleveltext indenttext" align="justify">Когда тестируется программное обеспечение, то моделируются заданные аппаратные средства с их входными и выходными данными.<br/><br/></p><p id="P0273_9" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0273_10" class="formattext topleveltext indenttext" align="justify">EmStar: An Environment for Developing Wireless Embedded Systems Software. J. Elson et al. htpp://cens.ucla.edu/TechReports/9_emstar.pdf.<br/><br/></p><p id="P0275" class="formattext topleveltext indenttext" align="justify">A hardware-software co-simulator for embedded system design and debugging. A. Ghosh et al. In Proceedings of the IFIP International Conference on Computer Hardware Description Languages and Their Applications, IFIP International Conference on Very Large Scale Integration, 1995. IEEE, 1995, ISBN 4930813670, 9784930813671.<br/><br/></p><p id="P0277" class="formattext topleveltext indenttext" align="justify"><b>C.5.19 Требования к реализации</b><br/><br/></p><p id="P0277_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблица В.6).<br/><br/><br/></p><p id="P0277_2" class="formattext topleveltext indenttext" align="justify">Цель. Установление демонстрируемых требований к функционированию системы программных средств.<br/><br/></p><p id="P0277_3" class="formattext topleveltext indenttext" align="justify">Описание. Выполняется анализ как системы, так и спецификаций требований программного обеспечения в целях спецификации всех общих и конкретных, явных и неявных требований к функционированию.<br/><br/></p><p id="P0277_4" class="formattext topleveltext indenttext" align="justify">Каждое требование к функционированию анализируется по очереди для того, чтобы определить:<br/><br/></p><p id="P0277_5" class="formattext topleveltext indenttext" align="justify">- критерии успешности результата, который следует получить;<br/><br/></p><p id="P0277_6" class="formattext topleveltext indenttext" align="justify">- возможность получения меры критерия успешности;<br/><br/></p><p id="P0277_7" class="formattext topleveltext indenttext" align="justify">- потенциальную точность таких результатов измерения;<br/><br/></p><p id="P0277_8" class="formattext topleveltext indenttext" align="justify">- этапы проектирования, на которых эти результаты измерения могут быть оценены;<br/><br/></p><p id="P0277_9" class="formattext topleveltext indenttext" align="justify">- этапы проектирования, на которых могут быть получены эти результаты измерений.<br/><br/></p><p id="P0277_10" class="formattext topleveltext indenttext" align="justify">Затем анализируется целесообразность каждого требования к функционированию для получения списка требований к функционированию, критериев успешности результата и возможных результатов измерений. Основными целями являются:<br/><br/></p><p id="P0277_11" class="formattext topleveltext indenttext" align="justify">- связь каждого требования к функционированию по крайней мере с одной мерой;<br/><br/></p><p id="P0277_12" class="formattext topleveltext indenttext" align="justify">- выбор (где это возможно) точных и эффективных мер, которые могут быть использованы на самых ранних стадиях разработки;<br/><br/></p><p id="P0277_13" class="formattext topleveltext indenttext" align="justify">- спецификация важных и факультативных требований к функционированию и критериев успешности результата;<br/><br/></p><p id="P0277_14" class="formattext topleveltext indenttext" align="justify">- использование (по возможности) преимуществ применения одной меры для нескольких требований к функционированию.<br/><br/></p><p id="P0277_15" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0277_16" class="formattext topleveltext indenttext" align="justify">Software Engineering for Real-time Systems. J.E. Cooling, Pearson Education, 2003, ISBN 0201596202, 9780201596205.<br/><br/></p><p id="P0279" class="formattext topleveltext indenttext" align="justify"><b>C.5.20 Моделирование реализации</b><br/><br/></p><p id="P0279_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблицы В.2 и В.5).<br/><br/><br/></p><p id="P0279_2" class="formattext topleveltext indenttext" align="justify">Цель. Гарантировать, что рабочая производительность системы достаточна для удовлетворения специфицированных требований.<br/><br/></p><p id="P0279_3" class="formattext topleveltext indenttext" align="justify">Описание. Спецификация требований включает в себя требования к пропускной способности и реакции конкретных функций, возможно, объединенных с ограничениями на использование общих системных ресурсов. Предложенный проект системы сравнивается с установленными требованиями путем:<br/><br/></p><p id="P0279_4" class="formattext topleveltext indenttext" align="justify">- создания модели процессов системы и их взаимодействий;<br/><br/></p><p id="P0279_5" class="formattext topleveltext indenttext" align="justify">- определения используемых каждым процессом ресурсов (время процессора, полоса пропускания канала связи, объем памяти и  т.п.);<br/><br/></p><p id="P0279_6" class="formattext topleveltext indenttext" align="justify">- определения распределения запросов, выдаваемых системе при средних и наихудших условиях;<br/><br/></p><p id="P0279_7" class="formattext topleveltext indenttext" align="justify">- вычисления средних и для наихудших случаев значений величин пропускной способности и времени ответа для конкретных функций системы.<br/><br/></p><p id="P0279_8" class="formattext topleveltext indenttext" align="justify">Для простых систем может оказаться достаточным аналитическое решение, тогда как для более сложных систем более подходящим для получения точных результатов является создание модели системы.<br/><br/></p><p id="P0279_9" class="formattext topleveltext indenttext" align="justify">Перед детальным моделированием может быть использована более простая проверка &quot;бюджета ресурсов&quot;, которая суммирует требования к ресурсам всех процессов. Если сумма этих требований к системе превышает возможности спроектированной системы, проект считается нереализуемым. Даже в случае, если проект проходит эту простую проверку, моделирование выполнения может показать, что слишком большие задержки и времена ответов происходят из-за недостатка ресурсов. Для исключения такой ситуации инженеры часто проектируют системы, использующие только часть (например, 50%) общих ресурсов для уменьшения вероятности нехватки ресурсов.<br/><br/></p><p id="P0279_10" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0279_11" class="formattext topleveltext indenttext" align="justify">Software Engineering for Real-time Systems. J.E. Cooling, Pearson Education, 2003, ISBN 0201596202, 9780201596205.<br/><br/></p><p id="P027B" class="formattext topleveltext indenttext" align="justify"><b>C.5.21 Проверка на критические нагрузки/стресс-тестирование</b><br/><br/></p><p id="P027B_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблица В.6).<br/><br/><br/></p><p id="P027B_2" class="formattext topleveltext indenttext" align="justify">Цель. Подвергнуть тестируемый объект исключительно высокой нагрузке, чтобы показать, что тестируемый объект будет легко выдерживать нормальную рабочую нагрузку.<br/><br/></p><p id="P027B_3" class="formattext topleveltext indenttext" align="justify">Описание. Существует множество тестов для проверки на критические нагрузки или стресс-тестирование, например:<br/><br/></p><p id="P027B_4" class="formattext topleveltext indenttext" align="justify">- если работа объекта происходит в режиме упорядоченного опроса, то объект тестирования подвергается в единицу времени гораздо большим входным изменениям, чем при нормальных условиях;<br/><br/></p><p id="P027B_5" class="formattext topleveltext indenttext" align="justify">- если работа объекта происходит по запросам, то число запросов в единицу времени для тестируемого объекта увеличивается относительно нормальных условий;<br/><br/></p><p id="P027B_6" class="formattext topleveltext indenttext" align="justify">- если объем базы данных играет важную роль, то этот объем увеличивается относительно ее объема при нормальных условиях;<br/><br/></p><p id="P027B_7" class="formattext topleveltext indenttext" align="justify">- имеющие решающее влияние устройства настраиваются на свои максимальные скорости или самые малые скорости соответственно;<br/><br/></p><p id="P027B_8" class="formattext topleveltext indenttext" align="justify">- для экстремальных тестов все факторы, имеющие решающее влияние, по возможности вводятся одновременно в граничные условия.<br/><br/></p><p id="P027B_9" class="formattext topleveltext indenttext" align="justify">Для указанных выше тестов может быть оценено поведение во времени тестируемого объекта. Можно также исследовать изменения нагрузки и проверить размер внутренних буферов или динамических переменных, стеков и  т.п.<br/><br/></p><p id="P027D" class="formattext topleveltext indenttext" align="justify"><b>С.5.22 Ограничения на время ответа и объем памяти</b><br/><br/></p><p id="P027D_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблица В.6).<br/><br/><br/></p><p id="P027D_2" class="formattext topleveltext indenttext" align="justify">Цель. Обеспечение соответствия системы требованиям к параметрам времени и памяти.<br/><br/></p><p id="P027D_3" class="formattext topleveltext indenttext" align="justify">Описание. Спецификация требований к системе и программному обеспечению включает в себя требования к памяти и времени выполнения системой конкретных функций, возможно, объединенных с ограничениями на использование общих системных ресурсов.<br/><br/></p><p id="P027D_4" class="formattext topleveltext indenttext" align="justify">Данный метод выполняется для определения распределения запросов при средних и наихудших условиях. Рассматриваемый метод требует оценки используемых ресурсов и затраченного времени каждой функцией системы. Такие оценки могут быть получены различными способами, например, сравнением с существующей системой или макетированием и дальнейшим сравнением времени реакции с критическими системами.<br/><br/></p><p id="P027F" class="formattext topleveltext indenttext" align="justify"><b>С.5.23 Анализ влияния</b><br/><br/></p><p id="P027F_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблица А.8).<br/><br/><br/></p><p id="P027F_2" class="formattext topleveltext indenttext" align="justify">Цель. Определение влияния, изменяющего или расширяющего программную систему, которому могут подвергаться также и другие программные модули в данной программной системе, а также другие системы.<br/><br/></p><p id="P027F_3" class="formattext topleveltext indenttext" align="justify">Описание. Перед выполнением модификации или расширением программного обеспечения следует определить влияние модификаций или расширений на программное обеспечение, а также определить, на какие программные системы и программные модули это повлияет.<br/><br/></p><p id="P027F_4" class="formattext topleveltext indenttext" align="justify">Далее принимается решение о повторной верификации программной системы. Это зависит от числа подвергнувшихся воздействию программных модулей, их критичности и характера изменений. Возможными решениями могут быть:<br/><br/></p><p id="P027F_5" class="formattext topleveltext indenttext" align="justify">- повторная проверка только изменений программного модуля;<br/><br/></p><p id="P027F_6" class="formattext topleveltext indenttext" align="justify">- повторная проверка всех подвергнувшихся воздействию программных модулей;<br/><br/></p><p id="P027F_7" class="formattext topleveltext indenttext" align="justify">- повторная проверка всей системы.<br/><br/></p><p id="P027F_8" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P027F_9" class="formattext topleveltext indenttext" align="justify">Requirements Engineering. Е. Hull, K. Jackson, J. Dick. Springer, 2005, ISBN 1852338792, 9781852338794.<br/><br/></p><p id="P0281" class="formattext topleveltext indenttext" align="justify"><b>C.5.24 Управление конфигурацией программного обеспечения</b><br/><br/></p><p id="P0281_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблица А.8).<br/><br/><br/></p><p id="P0281_2" class="formattext topleveltext indenttext" align="justify">Цель. Обеспечение согласованности результатов работы групп поставщиков проекта, а также изменений в этих поставках. В общем случае управление конфигурацией применимо к разработке как аппаратных, так и программных средств.<br/><br/></p><p id="P0281_3" class="formattext topleveltext indenttext" align="justify">Описание. Управление конфигурацией программных средств представляет собой метод, используемый в течение всей разработки (см. МЭК 61508-3, пункт 6.2.3). В сущности он требует документального оформления разработки каждой версии, каждой значимой ее поставки и каждой взаимосвязи между различными версиями разработки различных поставщиков. Полученная документация позволяет разработчику определять, как влияет на другие поставки изменение в первой поставке (особенно одного из его элементов). В частности, системы или подсистемы могут надежно компоноваться (конфигурироваться) из согласованных наборов версий элементов.<br/><br/></p><p id="P0281_4" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0281_5" class="formattext topleveltext indenttext" align="justify">Software engineering: Update. Ian Sommerville, Addison-Wesley Longman, Amsterdam; 8<img class="base64" src="data:image;base64,R0lGODdhDwAXAIABAAAAAP///ywAAAAADwAXAAACJIyPqcvtHwBw01R2r5J1apR5S2aNR2eW0ehJ0QfF8kzX9o0fBQA7" width="15" height="23"/> ed., 2006, ISBN 0321313798, 9780321313799<br/><br/></p><p id="P0281_6" class="formattext topleveltext indenttext" align="justify">Software Engineering. Ian Sommerville, Pearson Studium, 8. Auflage, 2007, ISBN 3827372577, 9783827372574.<br/><br/></p><p id="P0281_7" class="formattext topleveltext indenttext" align="justify">Software Configuration Management: Coordination for Team Productivity. W.A. Babich. Addison-Wesley, 1986, ISBN 0201101610, 9780201101614.<br/><br/></p><p id="P0281_8" class="formattext topleveltext indenttext" align="justify">CMMI: guidelines for process integration and product improvement, Mary Beth Chrissis, Mike Konrad, Sandy Shrum, Addison-Wesley, 2003, ISBN 0321154967, 9780321154965.<br/><br/></p><p id="P0283" class="formattext topleveltext indenttext" align="justify"><b>C.5.25 Регрессионное подтверждение соответствия</b><br/><br/></p><p id="P0283_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблица А.8).<br/><br/><br/></p><p id="P0283_2" class="formattext topleveltext indenttext" align="justify">Цель. Гарантировать, что обоснованные выводы сделаны из регрессионного тестирования.<br/><br/></p><p id="P0283_3" class="formattext topleveltext indenttext" align="justify">Описание. Полное регрессионное тестирование большой или сложной системы обычно требует больших усилий и ресурсов. По возможности желательно ограничить регрессионное тестирование, охватив только системные аспекты, представляющие в данный момент основной интерес для разрабатываемой системы. В таком частичном регрессионном тестировании важно иметь четкое понимание области применения этого частичного тестирования и сделать строго обоснованные выводы о тестируемом состоянии системы.<br/><br/></p><p id="P0283_4" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0283_5" class="formattext topleveltext indenttext" align="justify">Managing the Testing Process: Practical Tools and Techniques for Managing Hardware and Software Testing. R. Black, John Wiley and Sons, 2002, ISBN 0471223980, 9780471223986.<br/><br/></p><p id="P0285" class="formattext topleveltext indenttext" align="justify"><b>C.5.26 Анимация спецификации и проектирования</b><br/><br/></p><p id="P0285_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблица А.9).<br/><br/><br/></p><p id="P0285_2" class="formattext topleveltext indenttext" align="justify">Цель. Проводить верификацию программного обеспечения посредством систематической проверки спецификации.<br/><br/></p><p id="P0285_3" class="formattext topleveltext indenttext" align="justify">Описание. Проверяется представление программного обеспечения (спецификация или описание проекта), являющееся более абстрактным, чем исполняемый код, чтобы определить поведение возможного исполнимого программного обеспечения. Проверка до некоторой степени автоматизирована (в зависимости от возможностей, по своей природе и уровнем абстракции представления), чтобы промоделировать поведение и получить результаты исполнимого программного обеспечения. Одним из результатов этого подхода являются сгенерированные тесты (или &quot;оракулы&quot;), которые могут быть позже применены к исполнимому программному обеспечению, таким образом, автоматизируя, в некоторой степени, процесс тестирования. Другим результатом является анимация пользовательского интерфейса для того, чтобы конечные пользователи, не являющиеся техническими специалистами, смогли подробно разобраться в спецификации, с которой будут работать разработчики программного обеспечения, что обеспечивает ценный метод взаимодействия между этими двумя группами.<br/><br/></p><p id="P0285_4" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0285_5" class="formattext topleveltext indenttext" align="justify">Supporting the Software Testing Process through Specification Animation. T. Miller, P. Strooper. In Proceedings of the First International Conference on Software Engineering and Formal Methods (SEFM'03), ed. P. Lindsay. IEEE Computer Society, IEEE Computer Society, 2003, ISBN 0769519490, 9780769519494.<br/><br/></p><p id="P0285_6" class="formattext topleveltext indenttext" align="justify">В model animation for external verification. H. Waeselynck, S. Behnia, In Proceedings of the Second International Conference on Formal Engineering Methods, 1998. IEEE Computer Society, 1998, ISBN 0-8186-9198-0.<br/><br/></p><p id="P0287" class="formattext topleveltext indenttext" align="justify"><b>C.5.27 Тестирование, основанное на модели (генерация тестов)</b><br/><br/></p><p id="P0287_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблица А.5).<br/><br/><br/></p><p><img class="base64 sign" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZIAAAARCAMAAADAD9oKAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MTg4Q0U3ODQ0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MTg4Q0U3ODU0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoxODhDRTc4MjRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDoxODhDRTc4MzRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pos3t18AAAAzUExURfX19SQkJOrq6oeHh7y8vD8/P9/f31RUVMjIyLCwsHh4eJaWlmdnZ6Ojo9TU1AAAAP////kimdMAAAWSSURBVHja7FiJcuQoDAVzGcz1/1+7TwLRuDs9mZ2karZqQ1ViGz90PUngVv1nfMOo9fg2WarnNkf9FGxMHdDkf1jo3bXBg7o0YhIkfrXV0npvBfd48y94HQtV97XWZvBPfbpG29oikGfQ6oeRs4WLb4K2CGNq5wsltpX6B5TQYEa5/u6h9rdn31QdtXS0iKX1WZ360/o9Pl/3NmVq/ahk/cfwZ0X+bSL6T01Kxmq6Fj0MSDNPj+atGzF1+Y17z9IZMRfulHiH+ivMFvE7nm2ffQ26Q5+U0AKLatWUGFm63kU3SJycuwqNLgNJ1ONf6crorUNyEySMStQLlegNgSuSmiT5agizm0YyZwPNbEXLM64y2X0YcGgdN3ytU9FaLDCecHbCyFWVh0kjMvBEHK+rvx/tVIgOWSoTcZrRa+aVJxeOuLc5nG8Oj2cjCzdKDm1Uj9BCSFeO7sKBgKCxRWpXKNAiFtV2njBAGeqm2QBQaZKCjjDCA+vqnZJD802sAzu9q4EwRtde4djUG4kJeFObpsag4cXNNJKJejRY7pVO9EJiQf2XRJLlBEcW1Toooc48FcniBeN2nOALwwzMDXhDJv2CkoKENkS/NKzu0p74rRyOk0vcezgs0iXQhLDixE4J6YAALgUqoEq6VKpih0KosOuUUihxM+eGo6KIA3DEaTI8oJS7UZIybnhmOVX1wCiqLJSYmnr52WjShadTA7Obtsyl2lP22PquxG9kJ1VbSWN2gEXRfF4wlnri36xnTJBYC+R7ShyX17HNDIcXJSg8ddMqDi/p0+HOCGNfKclwPmdHBsVgp9mbHaemuwBMwtvmCK2pQqtwdpakiZIQg7pTAitwc+m6OVWyWFhnzQy9aMrcDZASSAJjgNlMo5R4UIJ1xbhnSsYr+p/LRslS1FfshQFIpb4v06WRvgBky4VfseOmPqy3zaKiZqp/SEmpOqhdqzi8pE+H6/2wu1PiCg9AkvOvlJi0r2ZbS7FooaMpdo8WYy6ixPFRZKcEE9Iz115irhdKWC/y1VquyIpWqU+i5GEapcRWJaGFFN9T4s7foyRQdqmNkqHvGJmn82AtUzed1s9vB63U6jj6ulOCnnbtWsXhJX06/J6S5LbDmKYuy/W11rgbobKpdRvmtNFKGpfS142SqEcL8CE99hIKV+ZmbDnr/NQL2Slx46wxoDSB2U27NS77eN4oGZaj91G6PChZiubzgo2+i9AKJbEd/S5yKA5ZAnCwLL6IcfYe2aHWb1rF4SV9OjwQ9XylZGwwORFSIeLUakYnHEVAgh6U0D7elY49C1OZNrM09pIC8EaJtnyjdHiIqE4qiY+K2YleProNrUcLhk8Lm2k3SgrF/KVKhuUQVUzfKFmK5vOCvVBytMSb69NeolwS66954oXTvnF2en3b3XmlIo3LPXF4SReHXZ5b3zMlCKcpAVse9z38XXh2kvo9htvuppy+LqeP0LgvBo/IpIJ+b/kQrGUDaM4XPvlBR9IPVq3mlkDldKIJ5k0vnGyzNh2myYvdtJ0S3wLtJeZOybT8uEabQ3kPSkSRUDRhs3HpI2uhKwKZKC8elADStJcASJOg7IcrF9BZvVBCPVi0bg6LdHF4IOqNkvmNaVM2iMWBHqoKLD9TvghAE92ecjdXxkxveb8tHElMxB7PblETZ1G2zDe1eNbBMkVEGdsDl4k3d709uAk86RPY3k2b5lZOIzbxnN2c5xk+LM9jv8PZaIBFkSwWBw9CRWwlLJ3fVZPTuYkUyLT+KPP7VBGAQmGev5tHTGMUrbvDU/pyeNn1oOQLQ74d6yeA51Hyfnn6FWDtmF8bueyXvzx+5XB/3d6/4rbfL+8Bz8Ne++X+s4z5pp/QLrtf/vJ47/B3U/L9Q/Fp4P87fn7R/c+NfwQYAFx9eFOvgdoSAAAAAElFTkSuQmCC"/></p><style>.base64.sign {display: none;}</style><p id="P0287_2" class="formattext topleveltext indenttext" align="justify">Цель. Обеспечить эффективную автоматическую генерацию тестовых примеров из моделей системы и создавать наборы тестов с высокой воспризводимостью.<br/><br/></p><p id="P0287_3" class="formattext topleveltext indenttext" align="justify">Описание. Метод тестирования, основанный на модели (МВТ), использует подход &quot;черного ящика&quot;, в котором общие задачи тестирования, такие как генерация тестовой комбинации (TCG) и оценка результатов тестирования, основаны на модели тестируемой (прикладной) системы (SUT). Как правило, но не всегда, данные о системе и поведение пользователя смоделированы с использованием методов конечных автоматов, марковских процессов, таблиц решений и  т.п. (El-Far, 2001). Кроме того, тестирование, основанное на модели, может быть объединено с измерением тестового охвата на уровне исходного кода, а функциональные модели могут быть основаны на существующем исходном коде.<br/><br/></p><p id="P0287_4" class="formattext topleveltext indenttext" align="justify">Тестирование, основанное на модели, обеспечивает автоматическую генерацию эффективных контрольных примеров/процедур, используя модели системных требований и заданной функциональности (SoftwareTech, 2009).<br/><br/></p><p id="P0287_5" class="formattext topleveltext indenttext" align="justify">Так как тестирование - очень дорогой процесс, существует большой спрос на автоматические средства генерации тестов. Поэтому направление тестирования, основанное на модели, в настоящий момент очень активно исследуется и создается большое число доступных средств генерации тестов (TCG). Эти средства обычно формируют тестовый набор из модели поведения системы, гарантируя при этом, что требования диагностического охвата будут удовлетворены.<br/><br/></p><p id="P0287_6" class="formattext topleveltext indenttext" align="justify">Модель является абстрактным частичным представлением требуемого поведения тестируемой системы. Из этой модели формируются модели тестов, создавая абстрактный тестовый набор. Из этого абстрактного тестового набора выводятся контрольные примеры и проверяют систему, кроме того, эти контрольные примеры могут проверять также и модель системы. Метод тестирования, основанный на модели, с генерацией тестов базируется и тесно связан с использованием формальных методов, поэтому понятны рекомендации для уровней полноты безопасности (УПБ): КР (крайне рекомендованный) для более высоких УПБ и не требуется для низких УПБ.<br/><br/></p><p id="P0287_7" class="formattext topleveltext indenttext" align="justify">В общем случае метод состоит из набора следующих действий:<br/><br/></p><p id="P0287_8" class="formattext topleveltext indenttext" align="justify">- создание модели (из системных требований);<br/><br/></p><p id="P0287_9" class="formattext topleveltext indenttext" align="justify">- генерация ожидаемых входов;<br/><br/></p><p id="P0287_10" class="formattext topleveltext indenttext" align="justify">- генерация ожидаемых выходов;<br/><br/></p><p id="P0287_11" class="formattext topleveltext indenttext" align="justify">- выполнение тестов;<br/><br/></p><p id="P0287_12" class="formattext topleveltext indenttext" align="justify">- сравнение фактических результатов с ожидаемыми выходами;<br/><br/></p><p id="P0287_13" class="formattext topleveltext indenttext" align="justify">- выбор дальнейших действий (изменение модели, генерация дальнейших тестов, оценка надежности/качества программного обеспечения).<br/><br/></p><p id="P0287_14" class="formattext topleveltext indenttext" align="justify">Для получения тестов могут быть использованы различные методы и средства представления моделей поведения пользователя/системы, например:<br/><br/></p><p id="P0287_15" class="formattext topleveltext indenttext" align="justify">- таблицы решений;<br/><br/></p><p id="P0287_16" class="formattext topleveltext indenttext" align="justify">- конечные автоматы;<br/><br/></p><p id="P0287_17" class="formattext topleveltext indenttext" align="justify">- формальные грамматики;<br/><br/></p><p id="P0287_18" class="formattext topleveltext indenttext" align="justify">- цепи Маркова;<br/><br/></p><p id="P0287_19" class="formattext topleveltext indenttext" align="justify">- диаграммы состояний;<br/><br/></p><p id="P0287_20" class="formattext topleveltext indenttext" align="justify">- доказательство теорем;<br/><br/></p><p id="P0287_21" class="formattext topleveltext indenttext" align="justify">- логическое программирование с ограничениями;<br/><br/></p><p id="P0287_22" class="formattext topleveltext indenttext" align="justify">- модель проверки;<br/><br/></p><p id="P0287_23" class="formattext topleveltext indenttext" align="justify">- моделирование на символьном уровне;<br/><br/></p><p id="P0287_24" class="formattext topleveltext indenttext" align="justify">- использование модели потока событий;<br/><br/></p><p id="P0287_25" class="formattext topleveltext indenttext" align="justify">- параллельные иерархические конечные автоматы для тестирования реактивных систем и т.д.<br/><br/></p><p id="P0287_26" class="formattext topleveltext indenttext" align="justify">Тестирование, основанное на модели, с недавних пор целенаправленно используется в областях, критических к безопасности. Оно позволяет на ранних стадиях выявить неоднозначности в спецификации и проекте, обеспечивает возможность автоматически генерировать много неповторяемых эффективных тестов, оценить регрессионный набор тестов и оценить надежность и качество программного обеспечения, а также облегчает обновление наборов тестов.<br/><br/></p><p id="P0287_27" class="formattext topleveltext indenttext" align="justify">Полный обзор дан в El-Far (2001) и SoftwareTech (2009), другие подробности, а также проблемы, зависящие от предметной области, рассмотрены в других источниках.<br/><br/></p><p id="P0287_28" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0289" class="formattext topleveltext indenttext" align="justify">Т. Bauer, F. <img class="base64" src="data:image;base64,R0lGODdhHwAQAIABAAAAAP///ywAAAAAHwAQAAACO4yPqcvtD2MClCIQsNGR5+Y9HlcdmLV905W2qIZO1Wu2aljnpA0zIw9UKX7Cnss3u8R2QonzCY1Kp4sCADs=" width="31" height="16"/>, D. Landmann, Т. Beletski, R. Eschbach, Robert and J.H. Poore, From Requirements to Statistical Testing of Embedded Systems Software Engineering for Automotive Systems - SEAS 2007, ICSE Workshops, Minneapolis, USA.<br/><br/></p><p id="P0289_1" class="formattext topleveltext indenttext" align="justify">Eckard Bringmann, Andreas <img class="normal" src="https://api.docs.cntd.ru/img/12/00/10/32/42/135f542c-1dc5-4db8-9c2d-74263b12735c/P02890001.png" width="41" height="13"/>; Model-based Testing of Automotive Systems In: ICST, pp.485-493, 2008 International Conference on Software Testing, Verification, and Validation, 2008.<br/><br/></p><p id="P0289_2" class="formattext topleveltext indenttext" align="justify">Broy M., Challenges in automotive software engineering, International conference on Software engineering (ICSE '06), Shanghai, China, 2006.<br/><br/></p><p id="P028B" class="formattext topleveltext indenttext" align="justify">I.K. El-Far and J.A. Whittaker, Model-Based Software Testing. Encyclopedia of Software Engineering (edited by J.J. Marciniak). Wiley, 2001.<br/><br/></p><p id="P028B_1" class="formattext topleveltext indenttext" align="justify">Heimdahl, M.P. E.: Model-based testing: challenges ahead, Computer Software and Applications Conference (COMPSAC 2005), 25-28 July 2005, Edinburgh, Scotland, UK, 2005.<br/><br/></p><p id="P028B_2" class="formattext topleveltext indenttext" align="justify">Jonathan Jacky, Margus Veanes, Colin Campbell, and Wolfram Schulte, Model-Based Software Testing and Analysis with C#, ISBN 978-0-521-68761-4, Cambridge University Press, 2008.<br/><br/></p><p id="P028D" class="formattext topleveltext indenttext" align="justify">A. Paradkar, Case Studies on Fault Detection Effectiveness of Model-based Test Generation Techniques, in ACM SIGSOFT SW Engineering Notes, Proc. of the first int. workshop on Advances in model-based testing A-MOST '05, Vol. 30, Issue 4. ACM Press, 2005.<br/><br/></p><p id="P028F" class="formattext topleveltext indenttext" align="justify">S.J. Prowell, Using Markov Chain Usage Models to Test Complex Systems, HICSS '05: 38<img class="base64" src="data:image;base64,R0lGODdhDwAXAIABAAAAAP///ywAAAAADwAXAAACJIyPqcvtHwBw01R2r5J1apR5S2aNR2eW0ehJ0QfF8kzX9o0fBQA7" width="15" height="23"/> Annual Hawaii, International Conference on System Sciences, 2005.<br/><br/></p><p id="P028F_1" class="formattext topleveltext indenttext" align="justify">Mark Utting and Bruno Legeard, Practical Model-Based Testing: A Tools Approach, ISBN 978-0-12-372501-1, Morgan-Kaufmann, 2007.<br/><br/></p><p id="P028F_2" class="formattext topleveltext indenttext" align="justify">Hong Zhu et al. (2008). AST '08: Proceedings of the 3rd International Workshop on Automation of Software Test. ACM Press. ISBN 978-1-60558-030-2.<br/><br/></p><p id="P028F_3" class="formattext topleveltext indenttext" align="justify">Model-Based Testing of Reactive Systems Advanced Lecture Series, LNCS 3472, Springer-Verlag, 2005, ISBN 978-3-540-26278-7.<br/><br/></p><p id="P028F_4" class="formattext topleveltext indenttext" align="justify">Model-based Testing, SoftwareTech, July 2009, Vol. 12, No. 2, Software Testing: A Life Cycle Perspective, htpp://www.goldpractices.com/practices/mbt/.<br/><br/></p><h3 id="P0292" class="formattext topleveltext indenttext" align="justify" title-level="3"><b>C.6 Оценка функциональной безопасности</b><br/><br/></h3><p id="P0292_1" class="formattext topleveltext indenttext" align="justify">Примечание - Соответствующие методы и средства см. также в В.6.<br/><br/></p><p id="P0294" class="formattext topleveltext indenttext" align="justify"><b>С.6.1 Таблицы решений (таблицы истинности)</b><br/><br/></p><p id="P0294_1" class="formattext topleveltext indenttext" align="justify">Примечание - Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблицы А.10 и В.7).<br/><br/><br/></p><p id="P0294_2" class="formattext topleveltext indenttext" align="justify">Цель. Обеспечение ясных и согласующихся спецификаций и анализа сложных логических комбинаций и их отношений.<br/><br/></p><p id="P0294_3" class="formattext topleveltext indenttext" align="justify">Описание. Данный метод использует бинарные таблицы для точного описания логических отношений между булевыми переменными программы.<br/><br/></p><p id="P0294_4" class="formattext topleveltext indenttext" align="justify">Использование таблиц и точность метода позволили применить его в качестве средства анализа сложных логических комбинаций, выраженных в бинарных кодах.<br/><br/></p><p id="P0294_5" class="formattext topleveltext indenttext" align="justify">Рассматриваемый метод достаточно легко автоматизируется, поэтому его можно использовать в качестве средства спецификации систем.<br/><br/></p><p id="P0296" class="formattext topleveltext indenttext" align="justify"><b>С.6.2 Исследование опасности и работоспособности программного обеспечения (CHAZOP, FMEA)</b><br/><br/></p><p id="P0296_1" class="formattext topleveltext indenttext" align="justify">Цель. Определение угроз безопасности в предлагаемой или существующей системе, их возможных причин и последствий и рекомендуемых действий по минимизации вероятности их появления.<br/><br/></p><p id="P0296_2" class="formattext topleveltext indenttext" align="justify">Описание. Группа специалистов в области создаваемой системы принимает участие в структурном анализе проекта системы путем ряда запланированных совещаний. Они рассматривают как реализацию функций проекта системы, так и способы работы системы на практике (включая действия персонала и процедуры эксплуатации системы). Руководитель группы специалистов инициирует ее участников создавать потенциальные опасности и управляет этой процедурой, описывая каждую часть системы в сочетании с отдельными ключевыми словами: &quot;отсутствует&quot;, &quot;более&quot;, &quot;менее&quot;, &quot;часть целого&quot;, &quot;больше чем&quot; (или &quot;так же, как и&quot;) и &quot;иначе чем&quot;. Каждое применимое условие или режим отказа рассматривается с точки зрения реализуемости, причин возникновения, возможных последствий (появляется ли опасность), способа устранения и, в случае устранения, выбора наиболее целесообразного метода.<br/><br/></p><p id="P0296_3" class="formattext topleveltext indenttext" align="justify">Исследование опасностей может выполняться на разных стадиях разработки проекта, однако наиболее эффективным такое исследование может быть на начальных стадиях с тем, чтобы как можно раньше повлиять на основные решения по проектированию и работоспособности.<br/><br/></p><p id="P0296_4" class="formattext topleveltext indenttext" align="justify">Метод HAZOP создавался для производственных процессов и требует модификации при его применении к программному обеспечению. Были предложены различные производные методы (Computer HAZOPs - &quot;CHAZOPs&quot;), которые сопровождались новыми руководящими материалами и/или реализовывали способы систематического охвата системной и программной архитектур.<br/><br/></p><p id="P0296_5" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0296_6" class="formattext topleveltext indenttext" align="justify">OF-FMEA: an approach to safety analysis of object-oriented software intensive systems, T. Cichocki, J. Gorski. In Artificial Intelligence and Security in Computing Systems: 9th International Conference, ACS '2002. Ed. J. Soldek. Springer, 2003, ISBN 1402073968, 9781402073960.<br/><br/></p><p id="P0296_7" class="formattext topleveltext indenttext" align="justify">Software FMEA techniques. P.L. Goddard. In Proc Annual 2000 Reliability and Maintainability Symposium, IEEE, 2000, ISBN: 0-7803-5848-1.<br/><br/></p><p id="P0297" class="formattext topleveltext indenttext" align="justify">Software criticality analysis of COTS/SOUP P. Bishop, T. Clement, S. Guerra. In Reliability Engineering &amp; System Safety, Volume 81, Issue 3, September 2003, Elsevier Ltd., 2003.<br/><br/></p><p id="P0299" class="formattext topleveltext indenttext" align="justify"><b>C.6.3 Анализ отказов по общей причине</b><br/><br/></p><p id="P0299_1" class="formattext topleveltext indenttext" align="justify">Примечания<br/><br/></p><p id="P029B" class="formattext topleveltext indenttext" align="justify">1 Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблица А.10).<br/><br/></p><p id="P029D" class="formattext topleveltext indenttext" align="justify">2 См. также МЭК 61508-6 (приложение D).<br/><br/><br/></p><p id="P029D_1" class="formattext topleveltext indenttext" align="justify">Цель. Определение возможных отказов в нескольких системах или нескольких подсистемах, которые могут свести к нулю преимущества избыточности из-за одновременного появления одних и тех же отказов во многих частях системы.<br/><br/></p><p id="P029D_2" class="formattext topleveltext indenttext" align="justify">Описание. Системы, ориентированные на безопасность объекта, часто используют избыточность аппаратных средств и мажоритарный принцип голосования. Этот подход исключает случайные отказы в компонентах или подсистемах аппаратных средств, которые могут помешать корректной обработке данных.<br/><br/></p><p id="P029D_3" class="formattext topleveltext indenttext" align="justify">Однако некоторые отказы могут оказаться общими для нескольких компонентов или подсистем. Например, если система установлена в одном помещении, то недостатки вентиляции могут снизить преимущества избыточности. Это может оказаться верным и для других внешних влияний на систему (например пожар, затопление, электромагнитные влияния, трещины в панелях и землетрясение). Система может быть также подвержена воздействиям, относящимся к ее функционированию и эксплуатации. Поэтому важно, чтобы в рабочих инструкциях были предусмотрены адекватные и хорошо задокументированные процедуры по функционированию и эксплуатации системы, а обслуживающий персонал был хорошо обучен.<br/><br/></p><p id="P029D_4" class="formattext topleveltext indenttext" align="justify">Внутренние причины также вносят большой вклад в общее число отказов. Их основой могут являться ошибки проектирования общих или идентичных компонентов и их интерфейсов, в том числе и устаревших компонентов. Анализ отказов по общей причине должен отыскивать также общие дефекты в системе. К методам анализа отказов по общей причине относятся: общее управление качеством; анализ проектов; верификация и тестирование независимой группой; анализ реальных ситуаций, полученных из опыта работы аналогичных систем. Однако область применения такого анализа выходит за рамки только аппаратных средств. Даже если разные программы используются в разных каналах избыточных систем, возможна некоторая общность в программных подходах, которая может привести к росту отказов по общей причине (например ошибки в общей спецификации).<br/><br/></p><p id="P029D_5" class="formattext topleveltext indenttext" align="justify">Если отказы по общей причине не появляются точно в одно и то же время, то должны быть предприняты меры предосторожности путем сравнения методов, применяемых в различных каналах. При этом применение каждого метода должно обнаруживать отказ до того, как он окажется общим для всех каналов. Анализ отказов по общей причине должен использовать этот подход.<br/><br/></p><p id="P029D_6" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P029D_7" class="formattext topleveltext indenttext" align="justify">Reliability analysis of hierarchical computer-based systems subject to common-cause failures L. Xing, L. Meshkat, S. Donohue. Reliability Engineering &amp; System Safety Volume 92, Issue 3, March 2007.<br/><br/></p><p id="P029F" class="formattext topleveltext indenttext" align="justify"><b>C.6.4 Структурные схемы надежности</b><br/><br/></p><p id="P029F_1" class="formattext topleveltext indenttext" align="justify">Примечания<br/><br/></p><p id="P02A1" class="formattext topleveltext indenttext" align="justify">1 Ссылка на данный метод/средство приведена в МЭК 61508-3 (таблица А.10) и метод также использован в МЭК 61508-6 (приложение В).<br/><br/></p><p id="P02A3" class="formattext topleveltext indenttext" align="justify">2 См. также В.6.6.7 &quot;Структурные схемы надежности&quot;.<br/><br/><br/></p><p id="P02A3_1" class="formattext topleveltext indenttext" align="justify">Цель. Моделирование в форме диаграмм набора событий, которые должны происходить, и условий, которые должны быть удовлетворены для успешного выполнения операций системы или задач.<br/><br/></p><p id="P02A3_2" class="formattext topleveltext indenttext" align="justify">Описание. Данный метод позволяет сформировать успешный маршрут, состоящий из блоков, линий и логических переходов. Такой успешный маршрут начинается от одной стороны диаграммы и проходит через блоки и логические переходы до другой стороны диаграммы. Блок представляет собой условие или событие, маршрут проходит через него, если условие истинно или событие произошло. Когда маршрут подходит к логическому переходу, то он продолжается, если критерий логического перехода выполняется. Если маршрут достигает какой-либо вершины, то он может продолжаться по всем исходящим из нее путям. Если существует по меньшей мере один успешный маршрут через всю диаграмму, то цель анализа считается достигнутой.<br/><br/></p><p id="P02A3_3" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P02A3_4" class="formattext topleveltext indenttext" align="justify">IEC 61025:2006, Fault tree analysis (FTA).<br/><br/></p><p id="P02A3_5" class="formattext topleveltext indenttext" align="justify">From safety analysis to software requirements. K.M. Hansen, A.P. Ravn, A.P, V Stavridou. IEEE Trans Software Engineering, Volume 24, Issue 7, Jul 1998.<br/><br/></p><p id="P02A3_6" class="formattext topleveltext indenttext" align="justify">IEC 61078:2006, Analysis techniques for dependability - Reliability block diagram and boolean methods.<br/><br/></p><h2 id="P02A6" class="formattext topleveltext centertext" align="center" title-level="2">Приложение D<br/>(справочное)<br/></h2><p id="P02A7" class="headertext topleveltext centertext" align="center">Вероятностный подход определения полноты безопасности предварительно разработанных программных средств </p><p id="P02A8" class="formattext topleveltext empty_line" align="justify"></p><h3 id="P02AB" class="formattext topleveltext indenttext" align="justify" title-level="3"><b>D.1 Общие положения</b><br/><br/></h3><p id="P02AB_1" class="formattext topleveltext indenttext" align="justify">Настоящее приложение содержит исходные руководящие материалы по использованию вероятностного подхода к определению полноты безопасности программных средств для предварительно разработанных программ на основе их опыта эксплуатации. Вероятностный подход является наиболее подходящим для оценки операционных систем, компонентов библиотек, компиляторов и других программных систем. Настоящее приложение также содержит описание возможностей вероятностного подхода, однако его следует использовать только тем специалистам, кто компетентен в статистическом анализе.<br/><br/></p><p id="P02AB_2" class="formattext topleveltext indenttext" align="justify">Примечание - В настоящем приложении используется термин &quot;уровень доверия&quot;, который описан в [9]. Эквивалентный термин &quot;уровень значимости&quot; приведен в [10].<br/><br/><br/></p><p><img class="base64 sign" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZIAAAARCAMAAADAD9oKAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MTg4Q0U3ODQ0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MTg4Q0U3ODU0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoxODhDRTc4MjRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDoxODhDRTc4MzRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pos3t18AAAAzUExURfX19SQkJOrq6oeHh7y8vD8/P9/f31RUVMjIyLCwsHh4eJaWlmdnZ6Ojo9TU1AAAAP////kimdMAAAWSSURBVHja7FiJcuQoDAVzGcz1/1+7TwLRuDs9mZ2karZqQ1ViGz90PUngVv1nfMOo9fg2WarnNkf9FGxMHdDkf1jo3bXBg7o0YhIkfrXV0npvBfd48y94HQtV97XWZvBPfbpG29oikGfQ6oeRs4WLb4K2CGNq5wsltpX6B5TQYEa5/u6h9rdn31QdtXS0iKX1WZ360/o9Pl/3NmVq/ahk/cfwZ0X+bSL6T01Kxmq6Fj0MSDNPj+atGzF1+Y17z9IZMRfulHiH+ivMFvE7nm2ffQ26Q5+U0AKLatWUGFm63kU3SJycuwqNLgNJ1ONf6crorUNyEySMStQLlegNgSuSmiT5agizm0YyZwPNbEXLM64y2X0YcGgdN3ytU9FaLDCecHbCyFWVh0kjMvBEHK+rvx/tVIgOWSoTcZrRa+aVJxeOuLc5nG8Oj2cjCzdKDm1Uj9BCSFeO7sKBgKCxRWpXKNAiFtV2njBAGeqm2QBQaZKCjjDCA+vqnZJD802sAzu9q4EwRtde4djUG4kJeFObpsag4cXNNJKJejRY7pVO9EJiQf2XRJLlBEcW1Toooc48FcniBeN2nOALwwzMDXhDJv2CkoKENkS/NKzu0p74rRyOk0vcezgs0iXQhLDixE4J6YAALgUqoEq6VKpih0KosOuUUihxM+eGo6KIA3DEaTI8oJS7UZIybnhmOVX1wCiqLJSYmnr52WjShadTA7Obtsyl2lP22PquxG9kJ1VbSWN2gEXRfF4wlnri36xnTJBYC+R7ShyX17HNDIcXJSg8ddMqDi/p0+HOCGNfKclwPmdHBsVgp9mbHaemuwBMwtvmCK2pQqtwdpakiZIQg7pTAitwc+m6OVWyWFhnzQy9aMrcDZASSAJjgNlMo5R4UIJ1xbhnSsYr+p/LRslS1FfshQFIpb4v06WRvgBky4VfseOmPqy3zaKiZqp/SEmpOqhdqzi8pE+H6/2wu1PiCg9AkvOvlJi0r2ZbS7FooaMpdo8WYy6ixPFRZKcEE9Iz115irhdKWC/y1VquyIpWqU+i5GEapcRWJaGFFN9T4s7foyRQdqmNkqHvGJmn82AtUzed1s9vB63U6jj6ulOCnnbtWsXhJX06/J6S5LbDmKYuy/W11rgbobKpdRvmtNFKGpfS142SqEcL8CE99hIKV+ZmbDnr/NQL2Slx46wxoDSB2U27NS77eN4oGZaj91G6PChZiubzgo2+i9AKJbEd/S5yKA5ZAnCwLL6IcfYe2aHWb1rF4SV9OjwQ9XylZGwwORFSIeLUakYnHEVAgh6U0D7elY49C1OZNrM09pIC8EaJtnyjdHiIqE4qiY+K2YleProNrUcLhk8Lm2k3SgrF/KVKhuUQVUzfKFmK5vOCvVBytMSb69NeolwS66954oXTvnF2en3b3XmlIo3LPXF4SReHXZ5b3zMlCKcpAVse9z38XXh2kvo9htvuppy+LqeP0LgvBo/IpIJ+b/kQrGUDaM4XPvlBR9IPVq3mlkDldKIJ5k0vnGyzNh2myYvdtJ0S3wLtJeZOybT8uEabQ3kPSkSRUDRhs3HpI2uhKwKZKC8elADStJcASJOg7IcrF9BZvVBCPVi0bg6LdHF4IOqNkvmNaVM2iMWBHqoKLD9TvghAE92ecjdXxkxveb8tHElMxB7PblETZ1G2zDe1eNbBMkVEGdsDl4k3d709uAk86RPY3k2b5lZOIzbxnN2c5xk+LM9jv8PZaIBFkSwWBw9CRWwlLJ3fVZPTuYkUyLT+KPP7VBGAQmGev5tHTGMUrbvDU/pyeNn1oOQLQ74d6yeA51Hyfnn6FWDtmF8bueyXvzx+5XB/3d6/4rbfL+8Bz8Ne++X+s4z5pp/QLrtf/vJ47/B3U/L9Q/Fp4P87fn7R/c+NfwQYAFx9eFOvgdoSAAAAAElFTkSuQmCC"/></p><style>.base64.sign {display: none;}</style><p id="P02AB_3" class="formattext topleveltext indenttext" align="justify">Предложенные в настоящем приложении методы могут быть также использованы для демонстрации роста уровня полноты безопасности программных средств, которые некоторое время успешно эксплуатировались. Например, программные средства, созданные в соответствии с требованиями МЭК 61508-3 для УПБ 1, после соответствующего периода успешной работы в большом числе применений могут продемонстрировать соответствие уровню полноты безопасности УПБ 2.<br/><br/></p><p id="P02AB_4" class="formattext topleveltext indenttext" align="justify">Число запросов без отказов при испытании или число часов, необходимое для работы без отказов, для определения конкретного уровня полноты безопасности представлено в таблице D.1. В таблице D.1 также обобщены результаты, приведенные в D.2.1 и D.2.3.<br/><br/></p><p id="P02AB_5" class="formattext topleveltext indenttext" align="justify">Опыт эксплуатации может быть выражен математически, как показано в D.2, для дополнения или замены статистического тестирования, а опыт эксплуатации, полученный из нескольких мест эксплуатации, может быть объединен (путем добавления конкретного числа обработанных запросов или часов работы в течение эксплуатации), но только в случае, если:<br/><br/></p><p id="P02AB_6" class="formattext topleveltext indenttext" align="justify">- программная версия, подлежащая использованию в Э/Э/ПЭ системе, связанной с безопасностью, будет идентична версии, для которой предъявлен результат опыта ее эксплуатации;<br/><br/></p><p id="P02AB_7" class="formattext topleveltext indenttext" align="justify">- эксплуатационный профиль входного пространства очень близок друг другу;<br/><br/></p><p id="P02AB_8" class="formattext topleveltext indenttext" align="justify">- существует эффективная система уведомлений и документирования отказов;<br/><br/></p><p id="P02AC" class="formattext topleveltext indenttext" align="justify">- справедливы принятые в D.2 предположения. <br/><br/><br/></p><p id="P02AC_1" class="formattext topleveltext" align="justify">Таблица D.1 - Необходимая предыстория для определения уровня полноты безопасности<br/></p><p id="X1927"></p><div element-type="table" class="table-container" id="X1928"><style type="text/css">#P02AD .td1 {width: 3.08em}#P02AD .td2 {width: 10.01em}#P02AD .td3 {width: 6.16em}#P02AD .td4 {width: 10.78em}#P02AD .td5 {width: 5.39em}#P02AD .td6 {width: 3.08em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px none black; border-right: 1px solid black; }#P02AD .td7 {width: 10.01em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px none black; border-right: 1px solid black; }#P02AD .td8 {width: 12.32em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }#P02AD .td9 {width: 10.78em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px none black; border-right: 1px solid black; }#P02AD .td10 {width: 11.55em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }#P02AD .td11 {width: 3.08em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px none black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }#P02AD .td12 {width: 10.01em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px none black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }#P02AD .td13 {width: 6.16em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }#P02AD .td14 {width: 10.78em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px none black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }#P02AD .td15 {width: 5.39em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }#P02AD .td16 {width: 3.08em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }#P02AD .td17 {width: 10.01em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }#P02AD .td18 {width: 10.78em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }#P02AD .td19 {width: 47.74em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }</style><table id="P02AD" class="wideTable"><tr height="1"><td class="td1"></td><td class="td2"></td><td class="td3"></td><td class="td3"></td><td class="td4"></td><td class="td5"></td><td class="td3"></td></tr><tr><td valign="top" class="td6"><p id="P02AD0000" class="formattext" align="center">УПБ </p></td><td valign="top" class="td7"><p id="P02AD0001" class="formattext" align="center">Режим работы с низкой интенсивностью запросов (вероятность отказа при выполнении планируемых функций по запросу)</p></td><td colspan="2" valign="top" class="td8"><p id="P02AD0002" class="formattext" align="center">Количество реальных запросов </p></td><td valign="top" class="td9"><p id="P02AD0003" class="formattext" align="center">Режим с высокой интенсивностью запросов или в режиме с непрерывным запросом (вероятность опасного отказа в час)</p></td><td colspan="2" valign="top" class="td10"><p id="P02AD0004" class="formattext" align="center">Общее количество часов эксплуатации </p></td></tr><tr><td valign="top" class="td11"><p id="P02AD0005" class="formattext"></p></td><td valign="top" class="td12"><p id="P02AD0006" class="formattext"></p></td><td valign="top" class="td13"><p id="P02AD0007" class="formattext" align="center"><img class="base64" src="data:image;base64,R0lGODdhHwATAIABAAAAAP///ywAAAAAHwATAAACM4yPqcvtD6OcDVAI8o12v85pBpiQDmiZiLqQaXVksjyWbI2VJ6fD/NhR0ULBm+eITColBQA7" width="31" height="19"/>=0,99 </p></td><td valign="top" class="td13"><p id="P02AD0008" class="formattext" align="center"><img class="base64" src="data:image;base64,R0lGODdhHwATAIABAAAAAP///ywAAAAAHwATAAACM4yPqcvtD6OcDVAI8o12v85pBpiQDmiZiLqQaXVksjyWbI2VJ6fD/NhR0ULBm+eITColBQA7" width="31" height="19"/>=0,95 </p></td><td valign="top" class="td14"><p id="P02AD0009" class="formattext" align="center"><br/><br/></p></td><td valign="top" class="td15"><p id="P02AD000A" class="formattext" align="center"><img class="base64" src="data:image;base64,R0lGODdhHwATAIABAAAAAP///ywAAAAAHwATAAACM4yPqcvtD6OcDVAI8o12v85pBpiQDmiZiLqQaXVksjyWbI2VJ6fD/NhR0ULBm+eITColBQA7" width="31" height="19"/>=0,99 </p></td><td valign="top" class="td13"><p id="P02AD000B" class="formattext" align="center"><img class="base64" src="data:image;base64,R0lGODdhHwATAIABAAAAAP///ywAAAAAHwATAAACM4yPqcvtD6OcDVAI8o12v85pBpiQDmiZiLqQaXVksjyWbI2VJ6fD/NhR0ULBm+eITColBQA7" width="31" height="19"/>=0,95 </p></td></tr><tr><td valign="top" class="td16"><p id="P02AD000C" class="formattext" align="center">4 </p></td><td valign="top" class="td17"><p id="P02AD000D" class="formattext" align="center"><img class="base64" src="data:image;base64,R0lGODdhDQAQAIABAAAAAP///ywAAAAADQAQAAACF4yPqcsJjYCEZ9JgW1Y79niF0kiGplkAADs=" width="13" height="16"/>10<img class="base64" src="data:image;base64,R0lGODdhEQAXAIABAAAAAP///ywAAAAAEQAXAAACHoyPqcvtDwOYEcRDr7FapglyWCdCZQN26sq27guzBQA7" width="17" height="23"/> до &lt;10<img class="base64" src="data:image;base64,R0lGODdhEQAXAIABAAAAAP///ywAAAAAEQAXAAACIIyPqcvtDw+IBsw4L8y4Jgty3hNaVKB158q27gvHclAAADs=" width="17" height="23"/></p></td><td valign="top" class="td13"><p id="P02AD000E" class="formattext" align="center">4,6·10<img class="base64" src="data:image;base64,R0lGODdhCwAXAIABAAAAAP///ywAAAAACwAXAAACF4yPqct9ABdwkbowW2Zb9Vdd4kiW5mkWADs=" width="11" height="23"/><br/></p></td><td valign="top" class="td13"><p id="P02AD000F" class="formattext" align="center">3·10<img class="base64" src="data:image;base64,R0lGODdhCwAXAIABAAAAAP///ywAAAAACwAXAAACF4yPqct9ABdwkbowW2Zb9Vdd4kiW5mkWADs=" width="11" height="23"/></p></td><td valign="top" class="td18"><p id="P02AD0010" class="formattext" align="center"><img class="base64" src="data:image;base64,R0lGODdhDQAQAIABAAAAAP///ywAAAAADQAQAAACF4yPqcsJjYCEZ9JgW1Y79niF0kiGplkAADs=" width="13" height="16"/>10<img class="base64" src="data:image;base64,R0lGODdhEQAXAIABAAAAAP///ywAAAAAEQAXAAACIIyPqcvtD4GEARz7cI2XG/1JYjhRmwk6pcm27gvH8gwVADs=" width="17" height="23"/> до &lt;10<img class="base64" src="data:image;base64,R0lGODdhEQAXAIABAAAAAP///ywAAAAAEQAXAAACIIyPqcvtD4GEARz7cKVWxyWFWMddn+E1IcW27gvH8jwXADs=" width="17" height="23"/></p></td><td valign="top" class="td15"><p id="P02AD0011" class="formattext" align="center">4,6·10<img class="base64" src="data:image;base64,R0lGODdhCwAXAIABAAAAAP///ywAAAAACwAXAAACG4yPqcttABc4M9VwqbbbwswxIDU65omm6soeBQA7" width="11" height="23"/></p></td><td valign="top" class="td13"><p id="P02AD0012" class="formattext" align="center">3·10<img class="base64" src="data:image;base64,R0lGODdhCwAXAIABAAAAAP///ywAAAAACwAXAAACG4yPqcttABc4M9VwqbbbwswxIDU65omm6soeBQA7" width="11" height="23"/></p></td></tr><tr><td valign="top" class="td16"><p id="P02AD0013" class="formattext" align="center">3 </p></td><td valign="top" class="td17"><p id="P02AD0014" class="formattext" align="center"><img class="base64" src="data:image;base64,R0lGODdhDQAQAIABAAAAAP///ywAAAAADQAQAAACF4yPqcsJjYCEZ9JgW1Y79niF0kiGplkAADs=" width="13" height="16"/>10<img class="base64" src="data:image;base64,R0lGODdhEQAXAIABAAAAAP///ywAAAAAEQAXAAACIIyPqcvtDw+IBsw4L8y4Jgty3hNaVKB158q27gvHclAAADs=" width="17" height="23"/> до &lt;10<img class="base64" src="data:image;base64,R0lGODdhEQAXAIABAAAAAP///ywAAAAAEQAXAAACIIyPqcvtD4GEARxLDaY7di2FyfeQjjmK2cq27gvH8lMAADs=" width="17" height="23"/></p></td><td valign="top" class="td13"><p id="P02AD0015" class="formattext" align="center">4,6·10<img class="base64" src="data:image;base64,R0lGODdhCwAXAIABAAAAAP///ywAAAAACwAXAAACGoyPqcut0ABccL5g0czGciyFkfM55omm6roWADs=" width="11" height="23"/><br/></p></td><td valign="top" class="td13"><p id="P02AD0016" class="formattext" align="center">3·10<img class="base64" src="data:image;base64,R0lGODdhCwAXAIABAAAAAP///ywAAAAACwAXAAACGoyPqcut0ABccL5g0czGciyFkfM55omm6roWADs=" width="11" height="23"/></p></td><td valign="top" class="td18"><p id="P02AD0017" class="formattext" align="center"><img class="base64" src="data:image;base64,R0lGODdhDQAQAIABAAAAAP///ywAAAAADQAQAAACF4yPqcsJjYCEZ9JgW1Y79niF0kiGplkAADs=" width="13" height="16"/>10<img class="base64" src="data:image;base64,R0lGODdhEQAXAIABAAAAAP///ywAAAAAEQAXAAACIIyPqcvtD4GEARz7cKVWxyWFWMddn+E1IcW27gvH8jwXADs=" width="17" height="23"/> до &lt;10<img class="base64" src="data:image;base64,R0lGODdhEQAXAIABAAAAAP///ywAAAAAEQAXAAACHYyPqcvtD4EE8VBosbma2ykhXtVpm4mm6sq27osUADs=" width="17" height="23"/></p></td><td valign="top" class="td15"><p id="P02AD0018" class="formattext" align="center">4,6·10<img class="base64" src="data:image;base64,R0lGODdhCwAXAIABAAAAAP///ywAAAAACwAXAAACHIyPqcttABc4M9Vw0cy2bUkpF/dEzomm6sq2SgEAOw==" width="11" height="23"/></p></td><td valign="top" class="td13"><p id="P02AD0019" class="formattext" align="center">3·10<img class="base64" src="data:image;base64,R0lGODdhCwAXAIABAAAAAP///ywAAAAACwAXAAACHIyPqcttABc4M9Vw0cy2bUkpF/dEzomm6sq2SgEAOw==" width="11" height="23"/></p></td></tr><tr><td valign="top" class="td16"><p id="P02AD001A" class="formattext" align="center">2 </p></td><td valign="top" class="td17"><p id="P02AD001B" class="formattext" align="center"><img class="base64" src="data:image;base64,R0lGODdhDQAQAIABAAAAAP///ywAAAAADQAQAAACF4yPqcsJjYCEZ9JgW1Y79niF0kiGplkAADs=" width="13" height="16"/>10<img class="base64" src="data:image;base64,R0lGODdhEQAXAIABAAAAAP///ywAAAAAEQAXAAACIIyPqcvtD4GEARxLDaY7di2FyfeQjjmK2cq27gvH8lMAADs=" width="17" height="23"/> до &lt;10<img class="base64" src="data:image;base64,R0lGODdhEQAXAIABAAAAAP///ywAAAAAEQAXAAACIYyPqcvtD4GEARxLDc6b9iqFyOeQDWYm4ZS17gvH8kw7BQA7" width="17" height="23"/></p></td><td valign="top" class="td13"><p id="P02AD001C" class="formattext" align="center">4,6·10<img class="base64" src="data:image;base64,R0lGODdhCwAXAIABAAAAAP///ywAAAAACwAXAAACGYyPqcttABc4s1VpL9OKJw9FzkiW5ommSgEAOw==" width="11" height="23"/><br/></p></td><td valign="top" class="td13"><p id="P02AD001D" class="formattext" align="center">3·10<img class="base64" src="data:image;base64,R0lGODdhCwAXAIABAAAAAP///ywAAAAACwAXAAACGYyPqcttABc4s1VpL9OKJw9FzkiW5ommSgEAOw==" width="11" height="23"/></p></td><td valign="top" class="td18"><p id="P02AD001E" class="formattext" align="center"><img class="base64" src="data:image;base64,R0lGODdhDQAQAIABAAAAAP///ywAAAAADQAQAAACF4yPqcsJjYCEZ9JgW1Y79niF0kiGplkAADs=" width="13" height="16"/>10<img class="base64" src="data:image;base64,R0lGODdhEQAXAIABAAAAAP///ywAAAAAEQAXAAACHYyPqcvtD4EE8VBosbma2ykhXtVpm4mm6sq27osUADs=" width="17" height="23"/> до  &lt;10<img class="base64" src="data:image;base64,R0lGODdhEQAXAIABAAAAAP///ywAAAAAEQAXAAACIYyPqcvtDw0AMdB6I536ZjmF1vExWbmcHVq17gvH8kwrBQA7" width="17" height="23"/></p></td><td valign="top" class="td15"><p id="P02AD001F" class="formattext" align="center">4,6·10<img class="base64" src="data:image;base64,R0lGODdhCwAXAIABAAAAAP///ywAAAAACwAXAAACF4yPqcttAIGSz9F1sd0sTweG4kiWJlMAADs=" width="11" height="23"/></p></td><td valign="top" class="td13"><p id="P02AD0020" class="formattext" align="center">3·10<img class="base64" src="data:image;base64,R0lGODdhCwAXAIABAAAAAP///ywAAAAACwAXAAACF4yPqcttAIGSz9F1sd0sTweG4kiWJlMAADs=" width="11" height="23"/></p></td></tr><tr><td valign="top" class="td16"><p id="P02AD0021" class="formattext" align="center">1 </p></td><td valign="top" class="td17"><p id="P02AD0022" class="formattext" align="center"><img class="base64" src="data:image;base64,R0lGODdhDQAQAIABAAAAAP///ywAAAAADQAQAAACF4yPqcsJjYCEZ9JgW1Y79niF0kiGplkAADs=" width="13" height="16"/>10<img class="base64" src="data:image;base64,R0lGODdhEQAXAIABAAAAAP///ywAAAAAEQAXAAACIYyPqcvtD4GEARxLDc6b9iqFyOeQDWYm4ZS17gvH8kw7BQA7" width="17" height="23"/> до &lt;10<img class="base64" src="data:image;base64,R0lGODdhEQAXAIABAAAAAP///ywAAAAAEQAXAAACHYyPqcvtDwOIBkwqccY32d91kQiRzqel6sq27qsWADs=" width="17" height="23"/></p></td><td valign="top" class="td13"><p id="P02AD0023" class="formattext" align="center">4,6·10<img class="base64" src="data:image;base64,R0lGODdhCwAXAIABAAAAAP///ywAAAAACwAXAAACGoyPqct9ABd4bjbLsNKJI+tBokOW5ommalIAADs=" width="11" height="23"/><br/></p></td><td valign="top" class="td13"><p id="P02AD0024" class="formattext" align="center">3·10<img class="base64" src="data:image;base64,R0lGODdhCwAXAIABAAAAAP///ywAAAAACwAXAAACGoyPqct9ABd4bjbLsNKJI+tBokOW5ommalIAADs=" width="11" height="23"/><br/></p></td><td valign="top" class="td18"><p id="P02AD0025" class="formattext" align="center"><img class="base64" src="data:image;base64,R0lGODdhDQAQAIABAAAAAP///ywAAAAADQAQAAACF4yPqcsJjYCEZ9JgW1Y79niF0kiGplkAADs=" width="13" height="16"/>10<img class="base64" src="data:image;base64,R0lGODdhEQAXAIABAAAAAP///ywAAAAAEQAXAAACIYyPqcvtDw0AMdB6I536ZjmF1vExWbmcHVq17gvH8kwrBQA7" width="17" height="23"/> до &lt;10<img class="base64" src="data:image;base64,R0lGODdhEQAXAIABAAAAAP///ywAAAAAEQAXAAACHoyPqcvtDwOYEcRDr7FapglyWCdCZQN26sq27guzBQA7" width="17" height="23"/></p></td><td valign="top" class="td15"><p id="P02AD0026" class="formattext" align="center">4,6·10<img class="base64" src="data:image;base64,R0lGODdhCwAXAIABAAAAAP///ywAAAAACwAXAAACG4yPqcuNAFiULcJ1w3xn959sXpc55omm6somBQA7" width="11" height="23"/></p></td><td valign="top" class="td13"><p id="P02AD0027" class="formattext" align="center">3·10<img class="base64" src="data:image;base64,R0lGODdhCwAXAIABAAAAAP///ywAAAAACwAXAAACG4yPqcuNAFiULcJ1w3xn959sXpc55omm6somBQA7" width="11" height="23"/></p></td></tr><tr><td colspan="7" valign="top" class="td19"><p id="P02AD0028" class="formattext">     Примечания<br/><br/>     1 Величина <img class="base64" src="data:image;base64,R0lGODdhHwATAIABAAAAAP///ywAAAAAHwATAAACM4yPqcvtD6OcDVAI8o12v85pBpiQDmiZiLqQaXVksjyWbI2VJ6fD/NhR0ULBm+eITColBQA7" width="31" height="19"/> представляет собой уровень доверия.<br/><br/>     2 Предпосылки и описание процедур получения числовых значений в настоящей таблице см. в D.2.1 и D.2.3.<br/><br/></p></td></tr></table></div><p id="P02AE" class="formattext topleveltext empty_line" align="justify"></p><h3 id="P02B1" class="formattext topleveltext indenttext" align="justify" title-level="3"><b>D.2 Формулы статистического тестирования и примеры их использования</b><br/><br/></h3><p id="P02B3" class="formattext topleveltext indenttext" align="justify"><b>D.2.1 Простой статистический тест для режима работы с низкой интенсивностью запросов</b><br/><br/></p><p id="P02B5" class="formattext topleveltext indenttext" align="justify">D.2.1.1 Исходные предпосылки<br/><br/></p><p id="P02B7" class="formattext topleveltext indenttext" align="justify">a) Распределение тестовых данных равно распределению запросов при выполнении операций в режиме онлайн.<br/><br/></p><p id="P02B9" class="formattext topleveltext indenttext" align="justify">b) Прохождения тестов статистически не зависят друг от друга в отношении причины отказа.<br/><br/></p><p id="P02BB" class="formattext topleveltext indenttext" align="justify">c) Для обнаружения любых отказов, которые могут появиться, существует адекватный механизм.<br/><br/></p><p id="P02BD" class="formattext topleveltext indenttext" align="justify">d) Число тестовых примеров <img class="base64" src="data:image;base64,R0lGODdhDQAPAIABAAAAAP///ywAAAAADQAPAAACGYyPqcvtAAxksdIYcJqZHo1o1vaBzommSwEAOw==" width="13" height="15"/>&gt;100.<br/><br/></p><p id="P02BF" class="formattext topleveltext indenttext" align="justify">e) Во время прогона <img class="base64" src="data:image;base64,R0lGODdhDQAPAIABAAAAAP///ywAAAAADQAPAAACGYyPqcvtAAxksdIYcJqZHo1o1vaBzommSwEAOw==" width="13" height="15"/> тестовых примеров отказы отсутствуют.<br/><br/></p><p id="P02C1" class="formattext topleveltext indenttext" align="justify">D.2.1.2 Результаты<br/><br/></p><p id="P02C1_1" class="formattext topleveltext indenttext" align="justify">Вероятность отказа <img class="base64" src="data:image;base64,R0lGODdhEAARAIABAAAAAP///ywAAAAAEAARAAACHYyPqcu9AEN0EhjbpnT48tM9IAVpGTWiVai27qsWADs=" width="16" height="17"/> (на один запрос) при уровне доверия <img class="base64" src="data:image;base64,R0lGODdhHwATAIABAAAAAP///ywAAAAAHwATAAACM4yPqcvtD6OcDVAI8o12v85pBpiQDmiZiLqQaXVksjyWbI2VJ6fD/NhR0ULBm+eITColBQA7" width="31" height="19"/> определяется из выражения<br/><br/></p><p id="P02C2" class="formattext topleveltext centertext" align="center"><img class="normal" src="https://api.docs.cntd.ru/img/12/00/10/32/42/135f542c-1dc5-4db8-9c2d-74263b12735c/P02C20000.png" width="65" height="25"/>  или  <img class="normal" src="https://api.docs.cntd.ru/img/12/00/10/32/42/135f542c-1dc5-4db8-9c2d-74263b12735c/P02C20001.png" width="60" height="44"/>.</p><p id="P02C3" class="formattext topleveltext empty_line" align="justify"></p><p id="P02C5" class="formattext topleveltext indenttext" align="justify">D.2.1.3 Пример<br/><br/><br/></p><p id="P02C5_1" class="formattext topleveltext" align="justify">Таблица D.2 - Вероятности отказа режима работы с низкой интенсивностью запросов<br/></p><p id="X1944"></p><div element-type="table" class="table-container" id="X1945"><style type="text/css">#P02C6 .td1 {width: 23.10em}#P02C6 .td2 {width: 22.33em}#P02C6 .td3 {width: 23.10em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }#P02C6 .td4 {width: 22.33em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }</style><table id="P02C6"><tr height="1"><td class="td1"></td><td class="td2"></td></tr><tr><td valign="top" class="td3"><p id="P02C60000" class="formattext" align="center"><img class="base64" src="data:image;base64,R0lGODdhHwATAIABAAAAAP///ywAAAAAHwATAAACM4yPqcvtD6OcDVAI8o12v85pBpiQDmiZiLqQaXVksjyWbI2VJ6fD/NhR0ULBm+eITColBQA7" width="31" height="19"/><br/></p></td><td valign="top" class="td4"><p align="center"><img class="base64" src="data:image;base64,R0lGODdhEAARAIABAAAAAP///ywAAAAAEAARAAACHYyPqcvdAKMLANVncWbX9BVBzjeR43SYnIS27msUADs=" width="16" height="17"/></p></td></tr><tr><td valign="top" class="td3"><p id="P02C60002" class="formattext" align="center">0,95<br/></p></td><td valign="top" class="td4"><p id="P02C60003" class="formattext" align="center">3/<img class="base64" src="data:image;base64,R0lGODdhDQAPAIABAAAAAP///ywAAAAADQAPAAACGYyPqcvtAAxksdIYcJqZHo1o1vaBzommSwEAOw==" width="13" height="15"/><br/></p></td></tr><tr><td valign="top" class="td3"><p id="P02C60004" class="formattext" align="center">0,99<br/></p></td><td valign="top" class="td4"><p id="P02C60005" class="formattext" align="center">4,6/<img class="base64" src="data:image;base64,R0lGODdhDQAPAIABAAAAAP///ywAAAAADQAPAAACGYyPqcvtAAxksdIYcJqZHo1o1vaBzommSwEAOw==" width="13" height="15"/><br/></p></td></tr></table></div><p id="P02C7" class="formattext topleveltext" align="justify">          <br/></p><p id="P02C7_1" class="formattext topleveltext indenttext" align="justify">Для вероятности отказа при запросе для уровня полноты безопасности УПБ 3 при 95%-ном уровне доверия применение указанной формулы дает 30000 тестовых примеров при выполнении условий принятых предпосылок. Результаты для каждого уровня полноты безопасности объединены в таблице D.1.<br/><br/></p><p id="P02C9" class="formattext topleveltext indenttext" align="justify"><b>D.2.2 Тестирование входного массива (предметной области) для режима работы с низкой интенсивностью запросов</b><br/><br/></p><p id="P02CB" class="formattext topleveltext indenttext" align="justify">D.2.2.1 Исходные предпосылки<br/><br/></p><p id="P02CB_1" class="formattext topleveltext indenttext" align="justify">Единственная исходная предпосылка состоит в том, что тестируемые данные выбираются так, чтобы обеспечить случайное унифицированное распределение по входному массиву (предметной области).<br/><br/></p><p id="P02CD" class="formattext topleveltext indenttext" align="justify">D.2.2.2 Результаты<br/><br/></p><p id="P02CD_1" class="formattext topleveltext indenttext" align="justify">Необходимо определить количество тестов <img class="base64" src="data:image;base64,R0lGODdhDQAPAIABAAAAAP///ywAAAAADQAPAAACGYyPqcvtAAxksdIYcJqZHo1o1vaBzommSwEAOw==" width="13" height="15"/>, которые требуются, исходя из порога точности <img class="base64" src="data:image;base64,R0lGODdhDQATAIABAAAAAP///ywAAAAADQATAAACHoyPqcvtASJo01R1XXxzr5sdYQgl5IiBjEQ+7gsHBQA7" width="13" height="19"/> входов для тестируемой функции с низкой интенсивностью запросов (например безопасное отключение).<br/><br/><br/></p><p id="P02CD_2" class="formattext topleveltext" align="justify">Таблица D.3 - Средние расстояния между двумя точками тестирования<br/></p><p id="X1954"></p><div element-type="table" class="table-container" id="X1955"><style type="text/css">#P02CE .td1 {width: 18.48em}#P02CE .td2 {width: 29.26em}#P02CE .td3 {width: 18.48em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }#P02CE .td4 {width: 29.26em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }#P02CE .td5 {width: 47.74em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }</style><table id="P02CE" class="wideTable"><tr height="1"><td class="td1"></td><td class="td2"></td></tr><tr><td valign="top" class="td3"><p id="P02CE0000" class="formattext" align="center">Размер предметного пространства </p></td><td valign="top" class="td4"><p id="P02CE0001" class="formattext" align="center">Среднее расстояние между двумя точками тестирования в произвольном направлении<br/></p></td></tr><tr><td valign="top" class="td3"><p id="P02CE0002" class="formattext" align="center">1<br/></p></td><td valign="top" class="td4"><p id="P02CE0003" class="formattext" align="center"><img class="normal" src="https://api.docs.cntd.ru/img/12/00/10/32/42/135f542c-1dc5-4db8-9c2d-74263b12735c/P02CE00030000.png" width="44" height="19"/><br/></p></td></tr><tr><td valign="top" class="td3"><p id="P02CE0004" class="formattext" align="center">2<br/></p></td><td valign="top" class="td4"><p id="P02CE0005" class="formattext" align="center"><img class="normal" src="https://api.docs.cntd.ru/img/12/00/10/32/42/135f542c-1dc5-4db8-9c2d-74263b12735c/P02CE00050000.png" width="56" height="24"/><br/></p></td></tr><tr><td valign="top" class="td3"><p id="P02CE0006" class="formattext" align="center">3<br/></p></td><td valign="top" class="td4"><p id="P02CE0007" class="formattext" align="center"><img class="normal" src="https://api.docs.cntd.ru/img/12/00/10/32/42/135f542c-1dc5-4db8-9c2d-74263b12735c/P02CE00070000.png" width="56" height="24"/><br/></p></td></tr><tr><td valign="top" class="td3"><p id="P02CE0008" class="formattext" align="center"><img class="base64" src="data:image;base64,R0lGODdhEQARAIABAAAAAP///ywAAAAAEQARAAACIYyPqcvtBiKMoNVz7Xw3u+p9oTYy3QNhXFJOUkC16EwzBQA7" width="17" height="17"/><br/></p></td><td valign="top" class="td4"><p id="P02CE0009" class="formattext" align="center"><img class="normal" src="https://api.docs.cntd.ru/img/12/00/10/32/42/135f542c-1dc5-4db8-9c2d-74263b12735c/P02CE00090000.png" width="59" height="24"/><br/></p></td></tr><tr><td colspan="2" valign="top" class="td5"><p id="P02CE000A" class="formattext indenttext" align="justify">Примечание - <img class="base64" src="data:image;base64,R0lGODdhEQARAIABAAAAAP///ywAAAAAEQARAAACIYyPqcvtBiKMoNVz7Xw3u+p9oTYy3QNhXFJOUkC16EwzBQA7" width="17" height="17"/> может быть любым положительным целым числом. Значения 1, 2 и 3 приведены только в качестве примеров.<br/><br/></p></td></tr></table></div><p id="P02CF" class="formattext topleveltext empty_line" align="justify"></p><p id="P02D1" class="formattext topleveltext indenttext" align="justify">D.2.2.3 Пример<br/><br/></p><p id="P02D1_1" class="formattext topleveltext indenttext" align="justify">Рассмотрим безопасное отключение, которое зависит только от двух переменных А и В. Если проверкой было установлено, что пороговые значения, которые разделяют входную пару переменных А и В, определены с точностью до 1% от диапазона измерения А или В, то число равномерно распределенных тестовых примеров, требуемое в области А и В, будет равно<br/><br/></p><p id="P02D2" class="formattext topleveltext centertext" align="center"><img class="normal" src="https://api.docs.cntd.ru/img/12/00/10/32/42/135f542c-1dc5-4db8-9c2d-74263b12735c/P02D20000.png" width="84" height="24"/>.</p><p id="P02D3" class="formattext topleveltext empty_line" align="justify"></p><p id="P02D5" class="formattext topleveltext indenttext" align="justify"><b>D.2.3 Простой статистический тест для режима с высокой интенсивностью запросов или в режиме с непрерывным запросом</b><br/><br/></p><p id="P02D7" class="formattext topleveltext indenttext" align="justify">D.2.3.1 Исходные предпосылки<br/><br/></p><p id="P02D9" class="formattext topleveltext indenttext" align="justify">а) Распределение данных такое же, как и распределение при выполнении операций в режиме онлайн.<br/><br/></p><p id="P02DB" class="formattext topleveltext indenttext" align="justify">b) Относительное уменьшение вероятности отсутствия отказа пропорционально длительности рассматриваемого интервала времени и постоянно в противном случае.<br/><br/></p><p id="P02DD" class="formattext topleveltext indenttext" align="justify">c) Для обнаружения любых отказов, которые могут появиться, существует адекватный механизм.<br/><br/></p><p id="P02DF" class="formattext topleveltext indenttext" align="justify">d) Тест выполняется в течение времени тестирования <img class="base64" src="data:image;base64,R0lGODdhCwAQAIABAAAAAP///ywAAAAACwAQAAACEoyPqcsG/RiYsFppY5q6+Q8mBQA7" width="11" height="16"/>.<br/><br/></p><p id="P02E1" class="formattext topleveltext indenttext" align="justify">e) Во время тестирования <img class="base64" src="data:image;base64,R0lGODdhCwAQAIABAAAAAP///ywAAAAACwAQAAACEoyPqcsG/RiYsFppY5q6+Q8mBQA7" width="11" height="16"/> никаких отказов не происходит.<br/><br/></p><p id="P02E3" class="formattext topleveltext indenttext" align="justify">D.2.3.2 Результаты<br/><br/></p><p id="P02E3_1" class="formattext topleveltext indenttext" align="justify">Соотношение между интенсивностью отказов <img class="base64" src="data:image;base64,R0lGODdhDQATAIABAAAAAP///ywAAAAADQATAAACHIyPqcvtAYCT8NVHZ15yqz5dnOEhGWiakcW2bgEAOw==" width="13" height="19"/>, уровнем доверия <img class="base64" src="data:image;base64,R0lGODdhHwATAIABAAAAAP///ywAAAAAHwATAAACM4yPqcvtD6OcDVAI8o12v85pBpiQDmiZiLqQaXVksjyWbI2VJ6fD/NhR0ULBm+eITColBQA7" width="31" height="19"/> и временем тестирования <img class="base64" src="data:image;base64,R0lGODdhCwAQAIABAAAAAP///ywAAAAACwAQAAACEoyPqcsG/RiYsFppY5q6+Q8mBQA7" width="11" height="16"/> имеет вид<br/><br/></p><p id="P02E4" class="formattext topleveltext centertext" align="center"><img class="normal" src="https://api.docs.cntd.ru/img/12/00/10/32/42/135f542c-1dc5-4db8-9c2d-74263b12735c/P02E40000.png" width="61" height="41"/>.</p><p id="P02E5" class="formattext topleveltext indenttext" align="justify"><br/></p><p id="P02E5_1" class="formattext topleveltext indenttext" align="justify">Интенсивность отказов обратно пропорциональна среднему времени наработки на отказ<br/><br/></p><p id="P02E6" class="formattext topleveltext centertext" align="center"><img class="normal" src="https://api.docs.cntd.ru/img/12/00/10/32/42/135f542c-1dc5-4db8-9c2d-74263b12735c/P02E60000.png" width="81" height="41"/>.</p><p id="P02E7" class="formattext topleveltext indenttext" align="justify"><br/></p><p id="P02E7_1" class="formattext topleveltext indenttext" align="justify">Примечание - Настоящий стандарт не делает различий между интенсивностью отказов в час и частотой отказов в час. Строго говоря, вероятность отказа <img class="base64" src="data:image;base64,R0lGODdhEQARAIABAAAAAP///ywAAAAAEQARAAACHoyPqcvtBqIEjx7bcNAK8+U921RdYliKkApJ7AvDBQA7" width="17" height="17"/> связана с частотой отказов <img class="base64" src="data:image;base64,R0lGODdhEAAVAIABAAAAAP///ywAAAAAEAAVAAACHYyPqcvtB8AzUk57Z4hRb49l4Ehq4WKdaOe17jsVADs=" width="16" height="21"/> выражением <img class="normal" src="https://api.docs.cntd.ru/img/12/00/10/32/42/135f542c-1dc5-4db8-9c2d-74263b12735c/P02E70002.png" width="68" height="24"/>, однако область применения настоящего стандарта охватывает частоту отказов менее 10<img class="base64" src="data:image;base64,R0lGODdhEQAXAIABAAAAAP///ywAAAAAEQAXAAACHoyPqcvtDwOYEcRDr7FapglyWCdCZQN26sq27guzBQA7" width="17" height="23"/> 1 /ч, а для небольших значений частоты справедливо <img class="normal" src="https://api.docs.cntd.ru/img/12/00/10/32/42/135f542c-1dc5-4db8-9c2d-74263b12735c/P02E70004.png" width="49" height="21"/>.<br/><br/></p><p id="P02E9" class="formattext topleveltext indenttext" align="justify">D.2.3.3 Пример<br/><br/><br/></p><p id="P02E9_1" class="formattext topleveltext" align="justify">Таблица D.4 - Вероятности отказа для режима с высокой интенсивностью запросов или для режима с непрерывным запросом<br/></p><p id="X1978"></p><div element-type="table" class="table-container" id="X1979"><style type="text/css">#P02EA .td1 {width: 23.87em}#P02EA .td2 {width: 22.33em}#P02EA .td3 {width: 23.87em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }#P02EA .td4 {width: 22.33em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }</style><table id="P02EA"><tr height="1"><td class="td1"></td><td class="td2"></td></tr><tr><td valign="top" class="td3"><p id="P02EA0000" class="formattext" align="center"><img class="base64" src="data:image;base64,R0lGODdhHwATAIABAAAAAP///ywAAAAAHwATAAACM4yPqcvtD6OcDVAI8o12v85pBpiQDmiZiLqQaXVksjyWbI2VJ6fD/NhR0ULBm+eITColBQA7" width="31" height="19"/><br/></p></td><td valign="top" class="td4"><p align="center"><img class="base64" src="data:image;base64,R0lGODdhDAARAIABAAAAAP///ywAAAAADAARAAACGYyPqQp9kCAMk5lqcdR2PX+BochF4ommSwEAOw==" width="12" height="17"/></p></td></tr><tr><td valign="top" class="td3"><p id="P02EA0002" class="formattext" align="center">0,95<br/></p></td><td valign="top" class="td4"><p id="P02EA0003" class="formattext" align="center">3<img class="base64" src="data:image;base64,R0lGODdhCwAQAIABAAAAAP///ywAAAAACwAQAAACEoyPqcsG/RiYsFppY5q6+Q8mBQA7" width="11" height="16"/></p></td></tr><tr><td valign="top" class="td3"><p id="P02EA0004" class="formattext" align="center">0,99<br/></p></td><td valign="top" class="td4"><p id="P02EA0005" class="formattext" align="center">4,6/<img class="base64" src="data:image;base64,R0lGODdhCwAQAIABAAAAAP///ywAAAAACwAQAAACEoyPqcsG/RiYsFppY5q6+Q8mBQA7" width="11" height="16"/></p></td></tr></table></div><p id="P02EB" class="formattext topleveltext" align="justify">          <br/></p><p id="P02EB_1" class="formattext topleveltext indenttext" align="justify">Для подтверждения того, что среднее время наработки на отказ составляет по меньшей мере 108 ч с уровнем доверия 95%, требуется время тестирования 3·10<img class="base64" src="data:image;base64,R0lGODdhCwAXAIABAAAAAP///ywAAAAACwAXAAACHIyPqcttABc4M9Vw0cy2bUkpF/dEzomm6sq2SgEAOw==" width="11" height="23"/> ч и должны быть соблюдены исходные предпосылки. Число тестов, необходимое для каждого уровня полноты безопасности, - в соответствии с таблицей D.1.<br/><br/></p><p id="P02ED" class="formattext topleveltext indenttext" align="justify"><b>D.2.4 Полное тестирование</b><br/><br/></p><p id="P02ED_1" class="formattext topleveltext indenttext" align="justify">Программу можно рассматривать как урну, содержащую <img class="base64" src="data:image;base64,R0lGODdhEwATAIABAAAAAP///ywAAAAAEwATAAACKIyPqcvtDw+YaNIGUn7XbBx8ITd60IaSZgmaIvNlr/J2ixVH+s73TQEAOw==" width="19" height="19"/> шаров. Каждый шар представляет собой конкретное свойство программы. Шары извлекаются случайно и заменяются после проверки. Полное тестирование достигается, если все шары извлечены.<br/><br/></p><p id="P02EF" class="formattext topleveltext indenttext" align="justify">D.2.4.1 Исходные предпосылки<br/><br/></p><p id="P02F1" class="formattext topleveltext indenttext" align="justify">a) Распределение тестируемых данных таково, что каждое из <img class="base64" src="data:image;base64,R0lGODdhEwATAIABAAAAAP///ywAAAAAEwATAAACKIyPqcvtDw+YaNIGUn7XbBx8ITd60IaSZgmaIvNlr/J2ixVH+s73TQEAOw==" width="19" height="19"/> свойств программы тестируется с равной вероятностью.<br/><br/></p><p id="P02F3" class="formattext topleveltext indenttext" align="justify">b) Тесты проводятся независимо друг от друга.<br/><br/></p><p id="P02F5" class="formattext topleveltext indenttext" align="justify">c) Каждый появляющийся отказ обнаруживается.<br/><br/></p><p id="P02F7" class="formattext topleveltext indenttext" align="justify">d) Число тестовых примеров <img class="normal" src="https://api.docs.cntd.ru/img/12/00/10/32/42/135f542c-1dc5-4db8-9c2d-74263b12735c/P02F70000.png" width="47" height="19"/>.<br/><br/></p><p id="P02F9" class="formattext topleveltext indenttext" align="justify">e) Во время прогона <img class="base64" src="data:image;base64,R0lGODdhDQAPAIABAAAAAP///ywAAAAADQAPAAACGYyPqcvtAAxksdIYcJqZHo1o1vaBzommSwEAOw==" width="13" height="15"/> тестовых примеров отказы не появляются.<br/><br/></p><p id="P02FB" class="formattext topleveltext indenttext" align="justify">f) Каждый прогон теста контролирует одно свойство программы (свойство программы - это то, что может быть протестировано во время одного прогона теста).<br/><br/></p><p id="P02FD" class="formattext topleveltext indenttext" align="justify">D.2.4.2 Результаты<br/><br/></p><p id="P02FD_1" class="formattext topleveltext indenttext" align="justify">Вероятность тестирования всех свойств программы <img class="base64" src="data:image;base64,R0lGODdhEAARAIABAAAAAP///ywAAAAAEAARAAACHYyPqcu9AEN0EhjbpnT48tM9IAVpGTWiVai27qsWADs=" width="16" height="17"/> определяется выражением<br/><br/></p><p id="P02FE" class="formattext topleveltext centertext" align="center"><img class="normal" src="https://api.docs.cntd.ru/img/12/00/10/32/42/135f542c-1dc5-4db8-9c2d-74263b12735c/P02FE0000.png" width="169" height="53"/>  или  <img class="normal" src="https://api.docs.cntd.ru/img/12/00/10/32/42/135f542c-1dc5-4db8-9c2d-74263b12735c/P02FE0001.png" width="184" height="53"/>,</p><p id="P02FF" class="formattext topleveltext indenttext" align="justify"><br/></p><p id="P02FF_1" class="formattext topleveltext" align="justify">где   <img class="normal" src="https://api.docs.cntd.ru/img/12/00/10/32/42/135f542c-1dc5-4db8-9c2d-74263b12735c/P02FF0000.png" width="196" height="44"/>.<br/><br/></p><p id="P02FF_2" class="formattext topleveltext indenttext" align="justify">При оценке этого выражения обычно только первые его члены имеют значение, поскольку в реальных условиях выполняется соотношение <img class="normal" src="https://api.docs.cntd.ru/img/12/00/10/32/42/135f542c-1dc5-4db8-9c2d-74263b12735c/P02FF0001.png" width="47" height="19"/>, что делает все члены этого выражения при большом <img class="base64" src="data:image;base64,R0lGODdhDQAUAIABAAAAAP///ywAAAAADQAUAAACGYyPqctt4KJEAEbbcJZ6dc8x1ndU5ISmUQEAOw==" width="13" height="20"/> несущественными. Это видно из таблицы D.5.<br/><br/></p><p><img class="base64 sign" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZIAAAARCAMAAADAD9oKAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MTg4Q0U3ODQ0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MTg4Q0U3ODU0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoxODhDRTc4MjRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDoxODhDRTc4MzRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pos3t18AAAAzUExURfX19SQkJOrq6oeHh7y8vD8/P9/f31RUVMjIyLCwsHh4eJaWlmdnZ6Ojo9TU1AAAAP////kimdMAAAWSSURBVHja7FiJcuQoDAVzGcz1/1+7TwLRuDs9mZ2karZqQ1ViGz90PUngVv1nfMOo9fg2WarnNkf9FGxMHdDkf1jo3bXBg7o0YhIkfrXV0npvBfd48y94HQtV97XWZvBPfbpG29oikGfQ6oeRs4WLb4K2CGNq5wsltpX6B5TQYEa5/u6h9rdn31QdtXS0iKX1WZ360/o9Pl/3NmVq/ahk/cfwZ0X+bSL6T01Kxmq6Fj0MSDNPj+atGzF1+Y17z9IZMRfulHiH+ivMFvE7nm2ffQ26Q5+U0AKLatWUGFm63kU3SJycuwqNLgNJ1ONf6crorUNyEySMStQLlegNgSuSmiT5agizm0YyZwPNbEXLM64y2X0YcGgdN3ytU9FaLDCecHbCyFWVh0kjMvBEHK+rvx/tVIgOWSoTcZrRa+aVJxeOuLc5nG8Oj2cjCzdKDm1Uj9BCSFeO7sKBgKCxRWpXKNAiFtV2njBAGeqm2QBQaZKCjjDCA+vqnZJD802sAzu9q4EwRtde4djUG4kJeFObpsag4cXNNJKJejRY7pVO9EJiQf2XRJLlBEcW1Toooc48FcniBeN2nOALwwzMDXhDJv2CkoKENkS/NKzu0p74rRyOk0vcezgs0iXQhLDixE4J6YAALgUqoEq6VKpih0KosOuUUihxM+eGo6KIA3DEaTI8oJS7UZIybnhmOVX1wCiqLJSYmnr52WjShadTA7Obtsyl2lP22PquxG9kJ1VbSWN2gEXRfF4wlnri36xnTJBYC+R7ShyX17HNDIcXJSg8ddMqDi/p0+HOCGNfKclwPmdHBsVgp9mbHaemuwBMwtvmCK2pQqtwdpakiZIQg7pTAitwc+m6OVWyWFhnzQy9aMrcDZASSAJjgNlMo5R4UIJ1xbhnSsYr+p/LRslS1FfshQFIpb4v06WRvgBky4VfseOmPqy3zaKiZqp/SEmpOqhdqzi8pE+H6/2wu1PiCg9AkvOvlJi0r2ZbS7FooaMpdo8WYy6ixPFRZKcEE9Iz115irhdKWC/y1VquyIpWqU+i5GEapcRWJaGFFN9T4s7foyRQdqmNkqHvGJmn82AtUzed1s9vB63U6jj6ulOCnnbtWsXhJX06/J6S5LbDmKYuy/W11rgbobKpdRvmtNFKGpfS142SqEcL8CE99hIKV+ZmbDnr/NQL2Slx46wxoDSB2U27NS77eN4oGZaj91G6PChZiubzgo2+i9AKJbEd/S5yKA5ZAnCwLL6IcfYe2aHWb1rF4SV9OjwQ9XylZGwwORFSIeLUakYnHEVAgh6U0D7elY49C1OZNrM09pIC8EaJtnyjdHiIqE4qiY+K2YleProNrUcLhk8Lm2k3SgrF/KVKhuUQVUzfKFmK5vOCvVBytMSb69NeolwS66954oXTvnF2en3b3XmlIo3LPXF4SReHXZ5b3zMlCKcpAVse9z38XXh2kvo9htvuppy+LqeP0LgvBo/IpIJ+b/kQrGUDaM4XPvlBR9IPVq3mlkDldKIJ5k0vnGyzNh2myYvdtJ0S3wLtJeZOybT8uEabQ3kPSkSRUDRhs3HpI2uhKwKZKC8elADStJcASJOg7IcrF9BZvVBCPVi0bg6LdHF4IOqNkvmNaVM2iMWBHqoKLD9TvghAE92ecjdXxkxveb8tHElMxB7PblETZ1G2zDe1eNbBMkVEGdsDl4k3d709uAk86RPY3k2b5lZOIzbxnN2c5xk+LM9jv8PZaIBFkSwWBw9CRWwlLJ3fVZPTuYkUyLT+KPP7VBGAQmGev5tHTGMUrbvDU/pyeNn1oOQLQ74d6yeA51Hyfnn6FWDtmF8bueyXvzx+5XB/3d6/4rbfL+8Bz8Ne++X+s4z5pp/QLrtf/vJ47/B3U/L9Q/Fp4P87fn7R/c+NfwQYAFx9eFOvgdoSAAAAAElFTkSuQmCC"/></p><style>.base64.sign {display: none;}</style><p id="P0301" class="formattext topleveltext indenttext" align="justify">D.2.4.3 Пример<br/><br/></p><p id="P0301_1" class="formattext topleveltext indenttext" align="justify">Рассмотрим программу, которая имела несколько инсталляций в течение нескольких лет. За это время она выполнялась по меньшей мере 7,5·10<img class="base64" src="data:image;base64,R0lGODdhCwAXAIABAAAAAP///ywAAAAACwAXAAACG4yPqcuNAFiULcJ1w3xn959sXpc55omm6somBQA7" width="11" height="23"/> раз. Предположим, что каждое сотое выполнение программы соответствует перечисленным выше исходным предпосылкам (см. D.2.4.1). Поэтому для статистической оценки могут быть приняты 7,5·10<img class="base64" src="data:image;base64,R0lGODdhCwAXAIABAAAAAP///ywAAAAACwAXAAACGoyPqcut0ABccL5g0czGciyFkfM55omm6roWADs=" width="11" height="23"/> выполнений программы. Если предположить, что 4000 тестовых прохождений программы могут выполнить исчерпывающее тестирование, считая такую оценку консервативной, то в соответствии с таблицей D.5, вероятность того, что не все будет протестировано, составляет 2,87·10<img class="base64" src="data:image;base64,R0lGODdhEQAXAIABAAAAAP///ywAAAAAEQAXAAACHoyPqcvtDwOYEcRDr7FapglyWCdCZQN26sq27guzBQA7" width="17" height="23"/>.<br/><br/></p><p id="P0301_2" class="formattext topleveltext indenttext" align="justify">При <img class="base64" src="data:image;base64,R0lGODdhEwATAIABAAAAAP///ywAAAAAEwATAAACKIyPqcvtDw+YaNIGUn7XbBx8ITd60IaSZgmaIvNlr/J2ixVH+s73TQEAOw==" width="19" height="19"/>=4000 значения первых членов в зависимости от <img class="base64" src="data:image;base64,R0lGODdhDQAPAIABAAAAAP///ywAAAAADQAPAAACGYyPqcvtAAxksdIYcJqZHo1o1vaBzommSwEAOw==" width="13" height="15"/> представлены в таблице D.5.<br/><br/><br/></p><p id="P0301_3" class="formattext topleveltext" align="justify">Таблица D.5 - Вероятность тестирования всех свойств программы<br/></p><p id="X2001"></p><div element-type="table" class="table-container" id="X2002"><style type="text/css">#P0302 .td1 {width: 25.41em}#P0302 .td2 {width: 22.33em}#P0302 .td3 {width: 25.41em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }#P0302 .td4 {width: 22.33em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }</style><table id="P0302" class="wideTable"><tr height="1"><td class="td1"></td><td class="td2"></td></tr><tr><td valign="top" class="td3"><p id="P03020000" class="formattext" align="center"><img class="base64" src="data:image;base64,R0lGODdhDQAPAIABAAAAAP///ywAAAAADQAPAAACGYyPqcvtAAxksdIYcJqZHo1o1vaBzommSwEAOw==" width="13" height="15"/><br/><br/></p></td><td valign="top" class="td4"><p align="center"><img class="base64" src="data:image;base64,R0lGODdhEAARAIABAAAAAP///ywAAAAAEAARAAACHYyPqcu9AEN0EhjbpnT48tM9IAVpGTWiVai27qsWADs=" width="16" height="17"/></p></td></tr><tr><td valign="top" class="td3"><p id="P03020002" class="formattext" align="center">5·10<img class="base64" src="data:image;base64,R0lGODdhCwAXAIABAAAAAP///ywAAAAACwAXAAACGoyPqcut0ABccL5g0czGciyFkfM55omm6roWADs=" width="11" height="23"/><br/></p></td><td valign="top" class="td4"><p id="P03020003" class="formattext" align="center">1-1,9·10<img class="base64" src="data:image;base64,R0lGODdhEQAXAIABAAAAAP///ywAAAAAEQAXAAACIYyPqcvtD4GEARxLDc6b9iqFyOeQDWYm4ZS17gvH8kw7BQA7" width="17" height="23"/>+1,10·10<img class="base64" src="data:image;base64,R0lGODdhEQAXAIABAAAAAP///ywAAAAAEQAXAAACIIyPqcvtDw+IBsw4L8y4Jgty3hNaVKB158q27gvHclAAADs=" width="17" height="23"/> -...</p></td></tr><tr><td valign="top" class="td3"><p id="P03020004" class="formattext" align="center">7, 5·10<img class="base64" src="data:image;base64,R0lGODdhCwAXAIABAAAAAP///ywAAAAACwAXAAACGoyPqcut0ABccL5g0czGciyFkfM55omm6roWADs=" width="11" height="23"/><br/></p></td><td valign="top" class="td4"><p id="P03020005" class="formattext" align="center">1-2,87·10<img class="base64" src="data:image;base64,R0lGODdhEQAXAIABAAAAAP///ywAAAAAEQAXAAACHoyPqcvtDwOYEcRDr7FapglyWCdCZQN26sq27guzBQA7" width="17" height="23"/>+4·10<img class="base64" src="data:image;base64,R0lGODdhGAAXAIABAAAAAP///ywAAAAAGAAXAAACLIyPqcvtD6M0AIE7MT1V9vB9UMhl5aZcakeiUQuaruionDbl+s73/g8MCoEFADs=" width="24" height="23"/> -...</p></td></tr><tr><td valign="top" class="td3"><p id="P03020006" class="formattext" align="center">1·10<img class="base64" src="data:image;base64,R0lGODdhCwAXAIABAAAAAP///ywAAAAACwAXAAACF4yPqct9ABdwkbowW2Zb9Vdd4kiW5mkWADs=" width="11" height="23"/><br/></p></td><td valign="top" class="td4"><p id="P03020007" class="formattext" align="center">1-5,54·10<img class="base64" src="data:image;base64,R0lGODdhEQAXAIABAAAAAP///ywAAAAAEQAXAAACIIyPqcvtD4GEARz7cKVWxyWFWMddn+E1IcW27gvH8jwXADs=" width="17" height="23"/>+1,52·10<img class="base64" src="data:image;base64,R0lGODdhGAAXAIABAAAAAP///ywAAAAAGAAXAAACK4yPqcvtD6M0IIEr8amTIj1xXyeOyoVy5RYuq/O+DUqB3Y3n+s73/g+EFAAAOw==" width="24" height="23"/>-...</p></td></tr><tr><td valign="top" class="td3"><p id="P03020008" class="formattext" align="center">2·10<img class="base64" src="data:image;base64,R0lGODdhCwAXAIABAAAAAP///ywAAAAACwAXAAACF4yPqct9ABdwkbowW2Zb9Vdd4kiW5mkWADs=" width="11" height="23"/><br/></p></td><td valign="top" class="td4"><p id="P03020009" class="formattext" align="center">1-7,67·10<img class="base64" src="data:image;base64,R0lGODdhGAAXAIABAAAAAP///ywAAAAAGAAXAAACK4yPqcvtD6M0AIE7MT1V9vB9UMhl5aZcaieuZiKO8ARqGo3n+s73/g8MSgoAOw==" width="24" height="23"/>+2, 9·10<img class="base64" src="data:image;base64,R0lGODdhGAAXAIABAAAAAP///ywAAAAAGAAXAAACK4yPqcvtD6MMoJ5qIbiUz45sk+hJWZlgWMh+oEGO6KO27o3n+s73/g80FAAAOw==" width="24" height="23"/> -...</p></td></tr></table></div><p id="P0303" class="formattext topleveltext" align="justify">          <br/></p><p id="P0303_1" class="formattext topleveltext indenttext" align="justify">На практике такие оценки должны быть консервативными.<br/><br/></p><h3 id="P0306" class="formattext topleveltext indenttext" align="justify" title-level="3"><b>D.3 Литература</b><br/><br/></h3><p id="P0306_1" class="formattext topleveltext indenttext" align="justify">Более подробную информацию по указанным выше методам можно найти в [9]-[13].<br/></p><p id="P0307" class="formattext topleveltext centertext" align="center"></p><h2 id="P030A" class="formattext topleveltext centertext" align="center" title-level="2">Приложение Е<br/>(справочное)<br/></h2><p id="P030B" class="headertext topleveltext centertext" align="center">Краткий обзор методов и мер для проектирования СИС </p><p id="P030C" class="formattext topleveltext indenttext" align="justify"><br/></p><p id="P030C_1" class="formattext topleveltext indenttext" align="justify">Примечание - В данном приложении дан обзор методов и мер, на которые ссылается МЭК 61508-2. Данное приложение не должно рассматриваться как полное или исчерпывающее.<br/><br/></p><p id="P030E" class="formattext topleveltext indenttext" align="justify"><b>Е.1 Описание проекта на языке (V)HDL</b><br/><br/></p><p id="P030E_1" class="formattext topleveltext indenttext" align="justify">Цель. Функциональное описание на высокоуровневом языке описания технических средств, например, VHDL или Verilog.<br/><br/></p><p id="P030E_2" class="formattext topleveltext indenttext" align="justify">Описание. Высокоуровневое абстрактное функциональное описание проекта на языке описания аппаратных средств, например, VHDL или Verilog. Используемый язык описания аппаратных средств должен позволить функциональное и/или ориентированное на применение описание и должен быть абстрагирован от последующих деталей реализации. Потоки данных, условные переходы, арифметические и/или логические операции должны быть реализованы присваиванием и операторами языка описания аппаратных средств без ручного преобразования в логические вентили из прикладной библиотеки.<br/><br/></p><p id="P030E_3" class="formattext topleveltext indenttext" align="justify">Примечание - Для простоты &quot;функциональное описание на высокоуровневом языке описания технических средств&quot; будем далее обозначать (V)HDL.<br/><br/><br/></p><p id="P030E_4" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P030E_5" class="formattext topleveltext indenttext" align="justify">IEEE VHDL, Verilog+Standard VHDL Design guide.<br/><br/></p><p id="P0310" class="formattext topleveltext indenttext" align="justify"><b>E.2 Ввод описаний схем</b><br/><br/></p><p id="P0310_1" class="formattext topleveltext indenttext" align="justify">Цель. Функциональное описание компонуемой схемы при ее представлении на уровне логических элементов и/или макросов библиотеки поставщика.<br/><br/></p><p id="P0310_2" class="formattext topleveltext indenttext" align="justify">Описание. Описание функциональности компонуемой схемы формируется при вводе описаний схем и связей между ними. Функция, которая должна быть реализована, компонуется (собирается) из элементарных логических схем, таких как И, ИЛИ, НЕ, а также макросов, состоящих из сложных арифметических и логических функций, которые затем соединяются между собой. Сложные функциональные схемы должны быть иерархически декомпозированы и могут быть представлены на различных иерархически связанных рисунках. Межсоединения должны быть уникально определены и иметь конкретные имена сигналов по всей иерархии. Насколько это возможно, необходимо избегать использования глобальных сигналов (меток).<br/><br/></p><p id="P0312" class="formattext topleveltext indenttext" align="justify"><b>Е.3 Структурное описание</b><br/><br/></p><p id="P0312_1" class="formattext topleveltext indenttext" align="justify">Примечание - См. также С.2.7 &quot;Структурное программирование&quot; и Е.12 &quot;Разбиение на модули&quot;.<br/><br/></p><p id="P0313" class="formattext topleveltext indenttext" align="justify"><br/></p><p id="P0313_1" class="formattext topleveltext indenttext" align="justify">Цель. Описание функциональности схемы должно быть структурировано таким способом, чтобы оно было легко воспринимаемо, то есть функция схемы должна быть интуитивно понята из описания без привлечения моделирования.<br/><br/></p><p id="P0313_2" class="formattext topleveltext indenttext" align="justify">Описание. Описание функциональности схемы формируется на языке (V)HDL или вводом описания схем. Рекомендуется легко узнаваемая модульная структура. Каждый модуль также должен быть реализован одним и тем же способом и должен быть описан так, чтобы можно было легко понять все его подфункции. Рекомендуется строго различать описание реализуемой функции от описания структуры на уровне межсоединений, то есть модуль, реализуемый из нескольких других подмодулей, должен содержать только описание межсоединений этих подмодулей и не должен содержать описание логики схемы.<br/><br/></p><p id="P0315" class="formattext topleveltext indenttext" align="justify"><b>Е.4 Средства, проверенные в эксплуатации</b><br/><br/></p><p id="P0315_1" class="formattext topleveltext indenttext" align="justify">Цель. Применение средств, проверенных на практике, для предотвращения систематических отказов при условии, что эти средства достаточно долго и успешно применялись в различных проектах.<br/><br/></p><p id="P0315_2" class="formattext topleveltext indenttext" align="justify">Описание. Большинство используемых средств для разработки ASIC и FPGA включает сложное программное обеспечение, которое не может считаться работающим без каких-либо ошибок, а также довольно часто ошибки могут возникнуть вследствие неправильной эксплуатации таких средств. Поэтому для разработки ASIC и FPGA необходимо использовать только средства с атрибутом &quot;проверено на практике&quot;. Это подразумевает:<br/><br/></p><p id="P0315_3" class="formattext topleveltext indenttext" align="justify">- применение средств, которые использовались (в сопоставимой версии программного обеспечения) в течение длительного периода времени или большим числом пользователей в различных проектах такой же сложности;<br/><br/></p><p id="P0315_4" class="formattext topleveltext indenttext" align="justify">- наличие у каждого разработчика ASIC/FPGA опыта работы с этими средствами в течение длительного периода времени;<br/><br/></p><p id="P0315_5" class="formattext topleveltext indenttext" align="justify">- применение общеиспользуемых средств (соответствующим числом пользователей) так, чтобы была доступна информация об известных отказах от всех пользователей (в процессе управления версиями со &quot;Списком ошибок&quot;). Эта информация должна быть быстро интегрирована в процесс проектирования, чтобы помочь избежать систематических отказов;<br/><br/></p><p id="P0315_6" class="formattext topleveltext indenttext" align="justify">- проверку непротиворечивости внутренних средств базы данных и проверку достоверности данных, что поможет избежать ошибок данных, получаемых из базы данных. Непротиворечивость данных внутри базы данных должны проверять стандартные средства, которые, чтобы работать с уникальными данными, проверяют непротиворечивость данных, полученных в результате работы средств синтеза, размещения и трассировки.<br/><br/></p><p id="P0316" class="formattext topleveltext indenttext" align="justify">Примечание - Проверка непротиворечивости - обязательная функция используемого средства, и разработчик на нее влияет слабо. Поэтому, если существует возможность ручной проверки непротиворечивости, разработчик должен адекватно ее использовать.<br/><br/></p><p id="P0318" class="formattext topleveltext indenttext" align="justify"><b>Е.5 Моделирование на языке (V)HDL</b><br/><br/></p><p id="P0318_1" class="formattext topleveltext indenttext" align="justify">Примечание - См. также Е.6 &quot;Функциональное тестирование на уровне модулей&quot;.<br/><br/><br/></p><p id="P0318_2" class="formattext topleveltext indenttext" align="justify">Цель. Функциональная проверка схемы, описанной на языке (V)HDL, средствами моделирования.<br/><br/></p><p id="P0318_3" class="formattext topleveltext indenttext" align="justify">Описание. Проверка функции с помощью моделирования всей схемы или каждого подмодуля. Средство моделирования (V)HDL позволяет получить последовательность выходных сигналов, отражающих внутренние изменения состояний схемы, вызванные поданными входными сигналами. Проверка полученной выходной последовательности может быть выполнена или по предварительно известной последовательности выходных сигналов (&quot;форме сигнала&quot;), или на специальном испытательном стенде, который создается во время процесса проектирования. Выбранное средство моделирования должно иметь статус &quot;проверено в эксплуатации&quot;, чтобы обеспечить корректные результаты и заблокировать неправильное поведение сигналов синхронизации (импульсные помехи, отслеживание троичных состояний), которые могут быть вызваны самим средством моделирования или ошибкой моделирования.<br/><br/></p><p id="P031A" class="formattext topleveltext indenttext" align="justify"><b>Е.6 Функциональное тестирование на уровне модулей</b><br/><br/></p><p id="P031A_1" class="formattext topleveltext indenttext" align="justify">Примечание - См. также Е.5 &quot;Моделирование на языке (V)HDL&quot;, Е.13 &quot;Охват сценариями верификации (испытательный стенд)&quot;.<br/><br/><br/></p><p id="P031A_2" class="formattext topleveltext indenttext" align="justify">Цель. Функциональная проверка &quot;Снизу вверх&quot;<br/><br/></p><p id="P031A_3" class="formattext topleveltext indenttext" align="justify">Описание. Проверка реализуемой функции - например моделированием - на уровне модуля. Тестируемый модуль будет загружаться в типичную виртуальную среду тестирования, называемую &quot;испытательный стенд&quot;, и тестируется содержащимися в среде наборами тестов. Для указанной функции требуется по крайней мере достаточно высокий охват тестами, включая все особые случаи, если они существуют. Автоматическая проверка выходных сигналов средствами &quot;испытательного стенда&quot; должна быть более приоритетна по сравнению с их ручной проверкой.<br/><br/></p><p id="P031C" class="formattext topleveltext indenttext" align="justify"><b>Е.7 Функциональное тестирование на верхнем уровне</b><br/><br/></p><p id="P031D" class="formattext topleveltext indenttext" align="justify">Примечание - См. также Е.8 &quot;Функциональное тестирование во внешней системной среде&quot;.<br/><br/><br/></p><p id="P031D_1" class="formattext topleveltext indenttext" align="justify">Цель. Проверка СИС (всей схемы).<br/><br/></p><p id="P031D_2" class="formattext topleveltext indenttext" align="justify">Описание. Задача этого теста - проверка всей схемы (СИС).<br/><br/></p><p id="P031F" class="formattext topleveltext indenttext" align="justify"><b>Е.8 Функциональное тестирование во внешней системной среде</b><br/><br/></p><p id="P031F_1" class="formattext topleveltext indenttext" align="justify">Примечание - См. также Е.7 &quot;Функциональное тестирование на верхнем уровне&quot;.<br/><br/><br/></p><p id="P031F_2" class="formattext topleveltext indenttext" align="justify">Цель. Проверка заданной функции, встроенной в системное окружение.<br/><br/></p><p id="P031F_3" class="formattext topleveltext indenttext" align="justify">Описание. Этот тест проверяет всю функциональность схемы (СИС) в ее системной среде, например со всеми другими компонентами, которые расположены на печатных платах или в другом месте. Моделирование всех соответствующих компонентов на печатной плате и моделирование СИС, на основе ее модели, для проверки корректной функциональности рекомендуется проводить с учетом сигналов синхронизации. Полное функциональное тестирование включает также тестирование модулей, которые становятся активными только во время отказа.<br/><br/></p><p id="P0321" class="formattext topleveltext indenttext" align="justify"><b>Е.9 Ограниченное использование асинхронных структур</b><br/><br/></p><p id="P0321_1" class="formattext topleveltext indenttext" align="justify">Цель. Предотвращение типичных проблем синхронизации в процессе синтеза, предотвращение неоднозначности в процессе моделирования и синтеза, связанных с трудностями создаваемой модели, проектирование тестируемости.<br/><br/></p><p id="P0321_2" class="formattext topleveltext indenttext" align="justify">Описание. Асинхронные структуры, формирующие такие сигналы, как УСТАНОВКА и СБРОС, построенные на комбинационной логике, чувствительны к процедуре синтеза. В результате могут формироваться схемы, создающие импульсные помехи или срабатывающие от инверсной синхронизации, и поэтому их необходимо избегать. Такие проблемы при создании модели не могут быть интерпретированы должным образом средствами синтеза, что приводит к неоднозначным результатам при моделировании асинхронных структур. Так как асинхронные структуры являются плохо тестируемыми или нетестируемыми вовсе, то эффективность охвата тестами при заводских испытаниях или тестирования в режиме онлайн снижается. Поэтому рекомендуется реализовывать полностью синхронную систему с ограниченным числом синхросигналов. В системах с многофазной синхронизацией все синхросигналы должны формироваться из одного центрального генератора синхросигналов. Синхронизация на входе последовательностной логики всегда должна осуществляться только синхросигналом, который не содержит комбинационной логики. Входы последовательностных ячеек асинхронных структур УСТАНОВКА и СБРОС всегда должны обеспечиваться синхросигналами, которые не содержат комбинационной логики. Устройства, задающие сигналы УСТАНОВКА и СБРОС, должны синхронизироваться с помощью двух триггеров.<br/><br/></p><p id="P0323" class="formattext topleveltext indenttext" align="justify"><b>Е.10 Синхронизация основных входов и управление метастабильностью</b><br/><br/></p><p id="P0324" class="formattext topleveltext indenttext" align="justify">Цель. Предотвращение неоднозначного поведения схемы в результате нарушения времен установки и промежуточного хранения.<br/><br/></p><p id="P0324_1" class="formattext topleveltext indenttext" align="justify">Описание. Входные сигналы от внешних периферийных устройств являются обычно асинхронными и могут произвольно изменять свое состояние. Непосредственная обработка таких сигналов выполняется синхронными элементами последовательностных схем ASIC/FPGA. Например, использование триггеров ведет к нарушению времени установки и промежуточного хранения, что приводит к непредсказуемым нарушениям в синхронизации и функциональном поведении ASIC/FPGA. Это может привести к метастабильности элемента памяти. Поэтому, чтобы избежать функциональной неоднозначности, каждый асинхронный входной сигнал должен синхронизироваться системой синхронизации ASIC. Рекомендуются следующие меры:<br/><br/></p><p id="P0324_2" class="formattext topleveltext indenttext" align="justify">- входные сигналы должны синхронизироваться двумя последовательными элементами памяти (триггерами) или некоторой эквивалентной схемой, чтобы достигнуть предсказуемого функционального поведения;<br/><br/></p><p id="P0324_3" class="formattext topleveltext indenttext" align="justify">- каждый асинхронный входной сигнал должен обязательно синхронизироваться способом, определенным выше, то есть каждый асинхронный сигнал соединяется только с одной такой схемой синхронизации. В случае необходимости выход схемы синхронизации может использоваться для множественного доступа;<br/><br/></p><p id="P0324_4" class="formattext topleveltext indenttext" align="justify">- такая схема синхронизации должна использоваться для проверки устойчивости сигналов параллельной шины и управлять согласованностью данных в точке выборки.<br/><br/></p><p id="P0326" class="formattext topleveltext indenttext" align="justify"><b>Е.11. Проектирование тестируемости</b><br/><br/></p><p id="P0326_1" class="formattext topleveltext indenttext" align="justify">Примечание - См. также Е.31 &quot;Реализация тестовых структур&quot;<br/><br/><br/></p><p id="P0326_2" class="formattext topleveltext indenttext" align="justify">Цель. Предотвращение нетестируемых или плохо тестируемых структур, чтобы обеспечить высокий уровень тестового охвата при заводских испытаниях или тестирования в режиме онлайн.<br/><br/></p><p id="P0326_3" class="formattext topleveltext indenttext" align="justify">Описание. Проектом по тестированию необходимо управлять в целях предотвращения:<br/><br/></p><p id="P0326_4" class="formattext topleveltext indenttext" align="justify">- асинхронных структур;<br/><br/></p><p id="P0326_5" class="formattext topleveltext indenttext" align="justify">- защелок и сигналов с тремя состояниями на микросхеме;<br/><br/></p><p id="P0326_6" class="formattext topleveltext indenttext" align="justify">- монтажного И/монтажного ИЛИ и избыточной логики.<br/><br/></p><p id="P0326_7" class="formattext topleveltext indenttext" align="justify">Комбинационная глубина подсхем играет важную роль в процессе тестирования. Тестовый пример, необходимый для полного тестирования, экспоненциально возрастает с глубиной комбинационной схемы. Поэтому схемы с высокой комбинационной глубиной довольно плохо тестируются существующими средствами.<br/><br/></p><p id="P0327" class="formattext topleveltext indenttext" align="justify">Подход, ориентируемый на проектирование тестируемости, гарантирует, что требуемый тестовый охват достигнут. Поскольку фактический тестовый охват может быть определен на очень поздней стадии процесса проектирования, недостаточное внимание проблемам &quot;проектирования тестируемости&quot; может существенно уменьшить достижимый тестовый охват, приводя к дополнительному объему работ.<br/><br/></p><p id="P0327_1" class="formattext topleveltext indenttext" align="justify">Примечание - Тестовый охват обычно определяется процентом обнаруженных константных отказов.<br/><br/></p><p id="P0329" class="formattext topleveltext indenttext" align="justify"><b>Е.12 Разбиение на модули</b><br/><br/></p><p id="P0329_1" class="formattext topleveltext indenttext" align="justify">Примечание - См. также С.2.8 &quot;Ограничение доступа/инкапсуляция информации&quot;, С.2.9 &quot;Модульный подход&quot; и Е.3 &quot;Структурное описание&quot;.<br/><br/><br/></p><p id="P0329_2" class="formattext topleveltext indenttext" align="justify">Цель. Описание модулей, реализующих функции схемы.<br/><br/></p><p id="P0329_3" class="formattext topleveltext indenttext" align="justify">Описание. Строгое разделение полной функциональности по различным модулям с ограниченными функциями. Таким способом устанавливается прозрачность модулей с точно определенным интерфейсом. Каждая подсистема на всех уровнях проекта явно определена и ограничена по размеру (только несколько функций). Интерфейсы между подсистемами сохранены настолько простыми, насколько это возможно, и пересечение модулей (то есть совместно используемые данные, обмен информацией) минимизировано. Также ограничена сложность отдельных подсистем.<br/><br/></p><p id="P032B" class="formattext topleveltext indenttext" align="justify"><b>Е.13 Охват сценариями верификации (испытательные стенды)</b><br/><br/></p><p><img class="base64 sign" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZIAAAARCAMAAADAD9oKAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MTg4Q0U3ODQ0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MTg4Q0U3ODU0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoxODhDRTc4MjRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDoxODhDRTc4MzRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pos3t18AAAAzUExURfX19SQkJOrq6oeHh7y8vD8/P9/f31RUVMjIyLCwsHh4eJaWlmdnZ6Ojo9TU1AAAAP////kimdMAAAWSSURBVHja7FiJcuQoDAVzGcz1/1+7TwLRuDs9mZ2karZqQ1ViGz90PUngVv1nfMOo9fg2WarnNkf9FGxMHdDkf1jo3bXBg7o0YhIkfrXV0npvBfd48y94HQtV97XWZvBPfbpG29oikGfQ6oeRs4WLb4K2CGNq5wsltpX6B5TQYEa5/u6h9rdn31QdtXS0iKX1WZ360/o9Pl/3NmVq/ahk/cfwZ0X+bSL6T01Kxmq6Fj0MSDNPj+atGzF1+Y17z9IZMRfulHiH+ivMFvE7nm2ffQ26Q5+U0AKLatWUGFm63kU3SJycuwqNLgNJ1ONf6crorUNyEySMStQLlegNgSuSmiT5agizm0YyZwPNbEXLM64y2X0YcGgdN3ytU9FaLDCecHbCyFWVh0kjMvBEHK+rvx/tVIgOWSoTcZrRa+aVJxeOuLc5nG8Oj2cjCzdKDm1Uj9BCSFeO7sKBgKCxRWpXKNAiFtV2njBAGeqm2QBQaZKCjjDCA+vqnZJD802sAzu9q4EwRtde4djUG4kJeFObpsag4cXNNJKJejRY7pVO9EJiQf2XRJLlBEcW1Toooc48FcniBeN2nOALwwzMDXhDJv2CkoKENkS/NKzu0p74rRyOk0vcezgs0iXQhLDixE4J6YAALgUqoEq6VKpih0KosOuUUihxM+eGo6KIA3DEaTI8oJS7UZIybnhmOVX1wCiqLJSYmnr52WjShadTA7Obtsyl2lP22PquxG9kJ1VbSWN2gEXRfF4wlnri36xnTJBYC+R7ShyX17HNDIcXJSg8ddMqDi/p0+HOCGNfKclwPmdHBsVgp9mbHaemuwBMwtvmCK2pQqtwdpakiZIQg7pTAitwc+m6OVWyWFhnzQy9aMrcDZASSAJjgNlMo5R4UIJ1xbhnSsYr+p/LRslS1FfshQFIpb4v06WRvgBky4VfseOmPqy3zaKiZqp/SEmpOqhdqzi8pE+H6/2wu1PiCg9AkvOvlJi0r2ZbS7FooaMpdo8WYy6ixPFRZKcEE9Iz115irhdKWC/y1VquyIpWqU+i5GEapcRWJaGFFN9T4s7foyRQdqmNkqHvGJmn82AtUzed1s9vB63U6jj6ulOCnnbtWsXhJX06/J6S5LbDmKYuy/W11rgbobKpdRvmtNFKGpfS142SqEcL8CE99hIKV+ZmbDnr/NQL2Slx46wxoDSB2U27NS77eN4oGZaj91G6PChZiubzgo2+i9AKJbEd/S5yKA5ZAnCwLL6IcfYe2aHWb1rF4SV9OjwQ9XylZGwwORFSIeLUakYnHEVAgh6U0D7elY49C1OZNrM09pIC8EaJtnyjdHiIqE4qiY+K2YleProNrUcLhk8Lm2k3SgrF/KVKhuUQVUzfKFmK5vOCvVBytMSb69NeolwS66954oXTvnF2en3b3XmlIo3LPXF4SReHXZ5b3zMlCKcpAVse9z38XXh2kvo9htvuppy+LqeP0LgvBo/IpIJ+b/kQrGUDaM4XPvlBR9IPVq3mlkDldKIJ5k0vnGyzNh2myYvdtJ0S3wLtJeZOybT8uEabQ3kPSkSRUDRhs3HpI2uhKwKZKC8elADStJcASJOg7IcrF9BZvVBCPVi0bg6LdHF4IOqNkvmNaVM2iMWBHqoKLD9TvghAE92ecjdXxkxveb8tHElMxB7PblETZ1G2zDe1eNbBMkVEGdsDl4k3d709uAk86RPY3k2b5lZOIzbxnN2c5xk+LM9jv8PZaIBFkSwWBw9CRWwlLJ3fVZPTuYkUyLT+KPP7VBGAQmGev5tHTGMUrbvDU/pyeNn1oOQLQ74d6yeA51Hyfnn6FWDtmF8bueyXvzx+5XB/3d6/4rbfL+8Bz8Ne++X+s4z5pp/QLrtf/vJ47/B3U/L9Q/Fp4P87fn7R/c+NfwQYAFx9eFOvgdoSAAAAAElFTkSuQmCC"/></p><style>.base64.sign {display: none;}</style><p id="P032B_1" class="formattext topleveltext indenttext" align="justify">Цель. Количественная и качественная оценка применяемых сценариев верификации в процессе функционального тестирования.<br/><br/></p><p id="P032B_2" class="formattext topleveltext indenttext" align="justify">Описание. Качество сценариев верификации определяется в процессе функционального тестирования, то есть применяемый тестовый набор для верификации конкретной функции, включая все особые случаи, если они существуют, должен быть качественно и/или количественно документально оформлен. При количественном подходе должны быть документально оформлены достигнутый тестовый охват и глубина примененных функциональных тестов. Получающийся охват должен удовлетворять уровням, установленным для каждой из метрик охвата. Любое исключение должно быть документально оформлено. В случае качественного подхода должно быть оценено число проверенных строк кода, инструкций или путей (&quot;Охват кода&quot;) проверяемого кода схемы.<br/><br/></p><p id="P032B_3" class="formattext topleveltext indenttext" align="justify">Примечание - Особый метод анализа &quot;Охват кода&quot; имеет ограниченное применение из-за высокого параллелизма описания аппаратных средств и необходимости обоснования исчерпывающими проверками. &quot;Охват кода&quot; обычно служит для демонстрации неохваченного функционального кода.<br/></p><p id="P032C" class="formattext topleveltext empty_line" align="justify"></p><p id="P032E" class="formattext topleveltext indenttext" align="justify"><b>Е.14 Соблюдение руководств по кодированию</b><br/><br/></p><p id="P032E_1" class="formattext topleveltext indenttext" align="justify">Цель. Строгое соблюдение стиля кодирования приводит к синтаксически и семантически корректному коду схемы.<br/><br/></p><p id="P032E_2" class="formattext topleveltext indenttext" align="justify">Описание. Синтаксические правила кодирования помогают создать легко читаемый код и лучшую документацию, включая управление версиями. Обычно руководства содержат правила по организации и комментированию блоков или модулей схемы.<br/><br/></p><p id="P032E_3" class="formattext topleveltext indenttext" align="justify">Семантические правила кодирования помогают предотвратить типичные проблемы реализации с помощью устранения структур, которые приводят к ошибке синтеза - неоднозначной реализации функции схемы. Типичными правилами являются, например, предотвращение асинхронных структур или структур, которые производят непредсказуемую последовательность синхросигналов. Обычно к таким неоднозначностям приводит использование защелок или взаимодействие данных с синхросигналами.<br/><br/></p><p id="P032E_4" class="formattext topleveltext indenttext" align="justify">Руководства по проектированию рекомендуют избегать систематических отказов проекта во время процесса разработки СИС. Стиль кодирования в определенном смысле ограничивает эффективность проекта, однако, в свою очередь, дает преимущество в предотвращении отказов во время процесса разработки СИС. Он в частности:<br/><br/></p><p id="P032E_5" class="formattext topleveltext indenttext" align="justify">- предотвращает типичные недостатки кодирования или отказы;<br/><br/></p><p id="P032E_6" class="formattext topleveltext indenttext" align="justify">- ограниченно использует проблемные структуры, которые приводят к неоднозначным результатам синтеза;<br/><br/></p><p id="P032E_7" class="formattext topleveltext indenttext" align="justify">- применяется для проектирования тестируемости;<br/><br/></p><p id="P032E_8" class="formattext topleveltext indenttext" align="justify">- обеспечивает прозрачный и удобный код.<br/><br/></p><p id="P032E_9" class="formattext topleveltext indenttext" align="justify">Пример стиля кодирования.<br/><br/></p><p id="P0330" class="formattext topleveltext indenttext" align="justify">1 Код должен содержать столько комментариев, сколько это необходимо для понимания деталей реализации и функции. Используемые соглашения должны быть определены перед началом проекта. В течение стадии проектирования должно быть проверено соответствие определенных соглашений.<br/><br/></p><p id="P0332" class="formattext topleveltext indenttext" align="justify">1.1 Стандартные заголовки включают историю, перекрестные ссылки на спецификацию, информацию об ответственности и данные, сопровождающие проект, такие как номер версии, запросы на изменение и т.д.<br/><br/></p><p id="P0334" class="formattext topleveltext indenttext" align="justify">1.2 Легко читаемые шаблоны: эквивалентные процессы должны быть описаны одинаковой процедурой, то есть использование предопределенных шаблонов для повторяющихся процессов (если-то-иначе, для и т.д.).<br/><br/></p><p id="P0336" class="formattext topleveltext indenttext" align="justify">1.3 Точное и читаемое соглашение о присвоении имен, например, прописная/строчная буква, префикс и постфикс, точное дифференцирование между именем порта, внутренними сигналами, константами, переменными, низкий активный уровень (ххх_n) и т.д.<br/><br/></p><p id="P0338" class="formattext topleveltext indenttext" align="justify">1.4 Должны быть введены ограничения на размер модуля и число портов на модуле для увеличения читаемости кода.<br/><br/></p><p id="P033A" class="formattext topleveltext indenttext" align="justify">1.5 Структурированная и защищенная разработка кода, например, информация о состоянии должна инкапсулироваться в FSM (сокрытие информации), чтобы обеспечить легкое изменение кода.<br/><br/></p><p id="P033C" class="formattext topleveltext indenttext" align="justify">1.6 Должны быть реализованы проверки достоверности, такие как проверка диапазона и т.д.<br/><br/></p><p id="P033E" class="formattext topleveltext indenttext" align="justify">1.7 Предотвращение следующих структур/команд:<br/><br/></p><p id="P033E_1" class="formattext topleveltext indenttext" align="justify">- использование просмотра диапазона по индексу в порядке возрастания ключа (от <img class="base64" src="data:image;base64,R0lGODdhDQAPAIABAAAAAP///ywAAAAADQAPAAACFYyPqcvtASIETTr6cIWbL2s94kgiBQA7" width="13" height="15"/> к <img class="base64" src="data:image;base64,R0lGODdhDwARAIABAAAAAP///ywAAAAADwARAAACG4yPqcuNAA5s00RqXbgXd/ph2qZF4VKN6sqyBQA7" width="15" height="17"/>) для сигналов шины;<br/><br/></p><p id="P033E_2" class="formattext topleveltext indenttext" align="justify">- команды &quot;Отключить&quot; в Verilog (соответствует команде goto);<br/><br/></p><p id="P033E_3" class="formattext topleveltext indenttext" align="justify">- многомерных массивов (&gt;2), записей;<br/><br/></p><p id="P033E_4" class="formattext topleveltext indenttext" align="justify">- сочетания типов данных без знака и со знаком.<br/><br/></p><p id="P0340" class="formattext topleveltext indenttext" align="justify">2 Завершенный проект синхронизации (допускается получение тактовых импульсов только от центральных тактовых генераторов).<br/><br/></p><p id="P0342" class="formattext topleveltext indenttext" align="justify">2.1 Выходы модуля должны быть синхронизированы, это также обеспечит тестируемость и статический анализ временных диаграмм.<br/><br/></p><p id="P0344" class="formattext topleveltext indenttext" align="justify">2.2  Управляющие импульсы должны быть обработаны со специальной предосторожностью.<br/><br/></p><p id="P0346" class="formattext topleveltext indenttext" align="justify">3 Предотвращение связи сигналов данных с синхросигналами повышает тестируемость, воспроизводимость между данными до и после компоновки и уровень соответствия поведения на уровне межрегистровых пересылок.<br/><br/></p><p id="P0348" class="formattext topleveltext indenttext" align="justify">4 Избыточная логика не является тестируемой и ее необходимо избегать:     <br/><br/></p><p id="P0349" class="formattext topleveltext centertext" align="center"><br/></p><p align="center" id="X2106"></p><div element-type="table" class="table-container" id="X2107"><style type="text/css">#P034A .td1 {width: 36.96em}#P034A .td2 {width: 36.96em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px none black; border-left: 1px none black; border-bottom: 1px none black; border-right: 1px none black; }</style><table align="center" id="P034A"><tr height="1"><td class="td1"></td></tr><tr><td valign="top" class="td2"><p id="P034A0000" class="formattext" align="center"><img class="normal" src="https://api.docs.cntd.ru/img/12/00/10/32/42/135f542c-1dc5-4db8-9c2d-74263b12735c/P034A00000000.png" width="462" height="103"/></p></td></tr></table></div><p id="P034B" class="formattext topleveltext centertext" align="center"></p><p id="P034D" class="formattext topleveltext indenttext" align="justify">5 Необходимо избегать обратные связи в комбинационной логике, потому что это ведет к нестабильности проекта, и он не будет тестируемым.<br/><br/></p><p id="P034F" class="formattext topleveltext indenttext" align="justify">6 Рекомендуется, чтобы проект был полностью просматриваемым (прогоняемым при моделировании).<br/><br/></p><p id="P0351" class="formattext topleveltext indenttext" align="justify">7 Предотвращение защелок увеличивает тестируемость и сокращает ограничения синхронизации в процессе синтеза.<br/><br/></p><p id="P0353" class="formattext topleveltext indenttext" align="justify">8 Сигнал основного сброса и все асинхронные входные сигналы должны синхронизироваться двумя последовательными элементами памяти (триггерами) или эквивалентной(ыми) схемой(ами) (метастабильность).<br/><br/></p><p id="P0355" class="formattext topleveltext indenttext" align="justify">9 Рекомендуется избегать асинхронных сигналов установки/сброса, за исключением сигнала основного сброса.<br/><br/></p><p id="P0357" class="formattext topleveltext indenttext" align="justify">10 Сигналы на уровне порта модуля должны иметь тип std_logic или std_logic_vector.<br/><br/></p><p id="P0359" class="formattext topleveltext indenttext" align="justify"><b>Е.15 Применение средств проверки кода</b><br/><br/></p><p id="P0359_1" class="formattext topleveltext indenttext" align="justify">Цель. Автоматическая проверка правил кодирования (&quot;Стиль кодирования&quot;) инструментальными средствами проверки кода.<br/><br/></p><p id="P0359_2" class="formattext topleveltext indenttext" align="justify">Описание. Применение средств проверки кода помогает в значительной степени автоматически соблюдать стиль кодирования и генерирует документацию в режиме онлайн. Однако автоматическое средство проверки кода может проверить синтаксис и семантику кода в целом. Поэтому применение таких инструментов должно сопровождаться расширением общих правил кодирования (&quot;конкретный инструмент&quot;) с помощью проектирования специальных правил кодирования, которые разработчик должен реализовывать и оценивать отдельно.<br/><br/></p><p id="P035B" class="formattext topleveltext indenttext" align="justify"><b>Е.16 Программирование с защитой</b><br/><br/></p><p id="P035B_1" class="formattext topleveltext indenttext" align="justify">Примечание - См. С.2.5.<br/><br/></p><p id="P035D" class="formattext topleveltext indenttext" align="justify"><b>Е.17 Документальное оформление результатов моделирования</b><br/><br/></p><p id="P035D_1" class="formattext topleveltext indenttext" align="justify">Цель. Документальное оформление всех данных, необходимых для успешного моделирования, чтобы проверить указанную функцию схемы.<br/><br/></p><p id="P035D_2" class="formattext topleveltext indenttext" align="justify">Описание. Все данные, необходимые для функционального моделирования на уровне модуля, микросхемы или системы должны быть правильно документально оформлены и заархивированы для того, чтобы:<br/><br/></p><p id="P035D_3" class="formattext topleveltext indenttext" align="justify">- повторить моделирование на любой более поздней стадии, поочередно изменяя параметры модели;<br/><br/></p><p id="P035D_4" class="formattext topleveltext indenttext" align="justify">- продемонстрировать правильность и полноту всех определенных функций.<br/><br/></p><p id="P035D_5" class="formattext topleveltext indenttext" align="justify">Должна быть заархивирована база данных, хранящая:<br/><br/></p><p id="P035D_6" class="formattext topleveltext indenttext" align="justify">- средства моделирования, включающие полное программное обеспечение используемых инструментов, например, средства моделирования, синтеза с указанием версий и необходимой библиотеки моделирования;<br/><br/></p><p id="P035D_7" class="formattext topleveltext indenttext" align="justify">- файл с журналом моделирования, который включает полную информацию о времени моделирования, примененных инструментов с указанием версий и полный текст отчета о всей работе, если это необходимо;<br/><br/></p><p id="P035D_8" class="formattext topleveltext indenttext" align="justify">- все соответствующие результаты моделирования, включая последовательности сигналов, особенно в случае ручной проверки, и документацию полученных результатов.<br/><br/></p><p id="P035F" class="formattext topleveltext indenttext" align="justify"><b>Е.18 Проверка кода</b><br/><br/></p><p id="P035F_1" class="formattext topleveltext indenttext" align="justify">Примечание - См. С.5.14 &quot;Формальные проверки&quot;.<br/><br/><br/></p><p id="P035F_2" class="formattext topleveltext indenttext" align="justify">Цель. Анализ описания схемы.<br/><br/></p><p id="P035F_3" class="formattext topleveltext indenttext" align="justify">Описание. Анализ описания схемы должен быть выполнен в целях проверки:<br/><br/></p><p id="P035F_4" class="formattext topleveltext indenttext" align="justify">- стиля кодирования;<br/><br/></p><p id="P035F_5" class="formattext topleveltext indenttext" align="justify">- соответствия со спецификацией описанной функциональности;<br/><br/></p><p id="P035F_6" class="formattext topleveltext indenttext" align="justify">- кодирования с защитой, обработки ошибок и обработки исключений.<br/><br/></p><p id="P035F_7" class="formattext topleveltext indenttext" align="justify">Примечание - Если моделирование на языке (V)HDL не выполнено, у полноты проверки кода и достигнутых результатов должно быть эквивалентное качество, которое может быть достигнуто моделированием на языке (V)HDL.<br/><br/></p><p id="P0361" class="formattext topleveltext indenttext" align="justify"><b>Е.19 Сквозной контроль</b><br/><br/></p><p id="P0361_1" class="formattext topleveltext indenttext" align="justify">Примечание - См. С.5.15 &quot;Сквозной контроль&quot;.<br/><br/><br/></p><p id="P0361_2" class="formattext topleveltext indenttext" align="justify">Цель. Проверка описания схемы с помощью сквозного контроля.<br/><br/></p><p id="P0361_3" class="formattext topleveltext indenttext" align="justify">Описание. Сквозной контроль выполняется следующим образом: команда сквозного контроля выбирает небольшой набор тестовых примеров - представительные наборы входных и соответствующих ожидаемых выходных данных для программы. Затем вручную прослеживается прохождение тестовых данных через логику программы.<br/><br/></p><p id="P0361_4" class="formattext topleveltext indenttext" align="justify">Примечание - Как самостоятельное средство оно должно применяться только к схемам с очень низкой сложностью. В случае сбоя при моделировании на языке (V)HDL у полноты сквозного контроля и качества достигнутых результатов должно быть эквивалентное качество, которое будет достигнуто моделированием на языке (V)HDL.<br/><br/><br/></p><p id="P0361_5" class="formattext topleveltext indenttext" align="justify">Литература:<br/><br/></p><p id="P0361_6" class="formattext topleveltext indenttext" align="justify">IEC 61160:2005, Design review.<br/><br/></p><p id="P0363" class="formattext topleveltext indenttext" align="justify"><b>Е.20 Применение прошедших подтверждение соответствия программных блоков, специфицированных на языке описания аппаратных средств, для проектирования микросхем</b><br/><br/></p><p id="P0363_1" class="formattext topleveltext indenttext" align="justify">Цель. Предотвращение отказа в процессе эксплуатации программного блока применением прошедшего подтверждение соответствия программного блока.<br/><br/></p><p id="P0363_2" class="formattext topleveltext indenttext" align="justify">Описание. Если поставщик подтверждает соответствие программного блока, то должны быть выполнены следующие требования:<br/><br/></p><p id="P0363_3" class="formattext topleveltext indenttext" align="justify">- должно быть выполнено подтверждение соответствия программного блока для его использования в системе, связанной с безопасностью, и оно должно иметь по крайней мере эквивалентный или более высокий уровень полноты безопасности, чем планируемая система;<br/><br/></p><p id="P0363_4" class="formattext topleveltext indenttext" align="justify">- должны быть выполнены все предположения и ограничения, которые необходимы для подтверждения соответствия программного блока;<br/><br/></p><p id="P0363_5" class="formattext topleveltext indenttext" align="justify">- должны быть легко доступны все необходимые документы для подтверждения соответствия программного блока, см. также Е.17 &quot;Документальное оформление результатов моделирования&quot;;<br/><br/></p><p id="P0363_6" class="formattext topleveltext indenttext" align="justify">- должна строго соблюдаться каждая спецификация поставщика и доказательство соответствия должно быть документально оформлено.<br/><br/></p><p id="P0365" class="formattext topleveltext indenttext" align="justify"><b>Е.21 Подтверждение соответствия программных блоков, специфицированных на языке описания аппаратных средств, для проектирования микросхем</b><br/><br/></p><p id="P0365_1" class="formattext topleveltext indenttext" align="justify">Примечание - См. Е.6 &quot;Функциональное тестирование на уровне модулей&quot;.<br/><br/><br/></p><p id="P0365_2" class="formattext topleveltext indenttext" align="justify">Цель. Предотвращение отказа в процессе эксплуатации программного блока подтверждением соответствия программного блока в процессе его создания.<br/><br/></p><p id="P0365_3" class="formattext topleveltext indenttext" align="justify">Описание. Если программный блок не разработан конкретно для эксплуатации в системе, связанной с безопасностью, то для сгенерированного кода должно быть проведено подтверждение соответствия в тех же самых условиях, которые применяются для проведения подтверждения соответствия любого исходного кода. Это означает, что должны быть определены и выполнены все возможные тестовые примеры. Затем с помощью моделирования должна быть выполнена функциональная проверка.<br/><br/></p><p id="P0367" class="formattext topleveltext indenttext" align="justify"><b>Е.22 Моделирование логической схемы на основе списка соединений для проверки ограничений синхронизации</b><br/><br/></p><p id="P0367_1" class="formattext topleveltext indenttext" align="justify">Цель. Независимая проверка достигаемого ограничения синхронизации во время синтеза.<br/><br/></p><p id="P0367_2" class="formattext topleveltext indenttext" align="justify">Описание. Моделирование логической схемы на основе списка соединений, созданного на этапе синтеза, с учётом реальной длины соединений при расчёте времени задержки в линиях связи и задержек в логических элементах. Должны быть сформированы такие входные сигналы, с помощью которых будет охвачен высокий процент ограничений синхронизации и будут включены все наихудшие случаи для синхронизации. Вообще входные сигналы должны быть такими, чтобы выполнялся &quot;Функциональный тест на уровне модуля&quot; (Е.6) или &quot;Функциональный тест на верхнем уровне&quot; (Е.7), подходящие критерии для выбора которого обеспечены при условии, что во время функционального теста может требоваться достаточный тестовый охват. Схема должна быть протестирована при наилучших и наихудших условиях при указанной максимальной тактовой частоте.<br/><br/></p><p id="P0367_3" class="formattext topleveltext indenttext" align="justify">Проверка синхронизации может быть выполнена с помощью автоматической проверки времени установки и времени промежуточного хранения для элементов памяти (триггеров) целевой библиотеки, а также с помощью функциональной проверки схемы. Функциональная проверка в основном должна осуществляться с помощью анализа выходных сигналов микросхемы. Она может быть выполнена автоматически, путем сравнения выходных сигналов схемы с соответствующей эталонной моделью или с исходным кодом схемы на языке (V)HDL. Этот тест известен как &quot;регрессионный тест&quot; и его выполнение должно быть более предпочтительным по сравнению с ручной проверкой выходных сигналов.<br/><br/></p><p id="P0367_4" class="formattext topleveltext indenttext" align="justify">Примечание - Данный метод позволяет проверить работу системы синхронизации только для тех путей списка соединений логических элементов, которые фактически активны во время моделирования и поэтому такой специально формируемый метод не может обеспечить полный временной анализ схемы в общем случае.<br/><br/></p><p id="P0369" class="formattext topleveltext indenttext" align="justify"><b>Е.23 Статический анализ задержки распространения сигнала (STA)</b><br/><br/></p><p><img class="base64 sign" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZIAAAARCAMAAADAD9oKAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MTg4Q0U3ODQ0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MTg4Q0U3ODU0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoxODhDRTc4MjRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDoxODhDRTc4MzRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pos3t18AAAAzUExURfX19SQkJOrq6oeHh7y8vD8/P9/f31RUVMjIyLCwsHh4eJaWlmdnZ6Ojo9TU1AAAAP////kimdMAAAWSSURBVHja7FiJcuQoDAVzGcz1/1+7TwLRuDs9mZ2karZqQ1ViGz90PUngVv1nfMOo9fg2WarnNkf9FGxMHdDkf1jo3bXBg7o0YhIkfrXV0npvBfd48y94HQtV97XWZvBPfbpG29oikGfQ6oeRs4WLb4K2CGNq5wsltpX6B5TQYEa5/u6h9rdn31QdtXS0iKX1WZ360/o9Pl/3NmVq/ahk/cfwZ0X+bSL6T01Kxmq6Fj0MSDNPj+atGzF1+Y17z9IZMRfulHiH+ivMFvE7nm2ffQ26Q5+U0AKLatWUGFm63kU3SJycuwqNLgNJ1ONf6crorUNyEySMStQLlegNgSuSmiT5agizm0YyZwPNbEXLM64y2X0YcGgdN3ytU9FaLDCecHbCyFWVh0kjMvBEHK+rvx/tVIgOWSoTcZrRa+aVJxeOuLc5nG8Oj2cjCzdKDm1Uj9BCSFeO7sKBgKCxRWpXKNAiFtV2njBAGeqm2QBQaZKCjjDCA+vqnZJD802sAzu9q4EwRtde4djUG4kJeFObpsag4cXNNJKJejRY7pVO9EJiQf2XRJLlBEcW1Toooc48FcniBeN2nOALwwzMDXhDJv2CkoKENkS/NKzu0p74rRyOk0vcezgs0iXQhLDixE4J6YAALgUqoEq6VKpih0KosOuUUihxM+eGo6KIA3DEaTI8oJS7UZIybnhmOVX1wCiqLJSYmnr52WjShadTA7Obtsyl2lP22PquxG9kJ1VbSWN2gEXRfF4wlnri36xnTJBYC+R7ShyX17HNDIcXJSg8ddMqDi/p0+HOCGNfKclwPmdHBsVgp9mbHaemuwBMwtvmCK2pQqtwdpakiZIQg7pTAitwc+m6OVWyWFhnzQy9aMrcDZASSAJjgNlMo5R4UIJ1xbhnSsYr+p/LRslS1FfshQFIpb4v06WRvgBky4VfseOmPqy3zaKiZqp/SEmpOqhdqzi8pE+H6/2wu1PiCg9AkvOvlJi0r2ZbS7FooaMpdo8WYy6ixPFRZKcEE9Iz115irhdKWC/y1VquyIpWqU+i5GEapcRWJaGFFN9T4s7foyRQdqmNkqHvGJmn82AtUzed1s9vB63U6jj6ulOCnnbtWsXhJX06/J6S5LbDmKYuy/W11rgbobKpdRvmtNFKGpfS142SqEcL8CE99hIKV+ZmbDnr/NQL2Slx46wxoDSB2U27NS77eN4oGZaj91G6PChZiubzgo2+i9AKJbEd/S5yKA5ZAnCwLL6IcfYe2aHWb1rF4SV9OjwQ9XylZGwwORFSIeLUakYnHEVAgh6U0D7elY49C1OZNrM09pIC8EaJtnyjdHiIqE4qiY+K2YleProNrUcLhk8Lm2k3SgrF/KVKhuUQVUzfKFmK5vOCvVBytMSb69NeolwS66954oXTvnF2en3b3XmlIo3LPXF4SReHXZ5b3zMlCKcpAVse9z38XXh2kvo9htvuppy+LqeP0LgvBo/IpIJ+b/kQrGUDaM4XPvlBR9IPVq3mlkDldKIJ5k0vnGyzNh2myYvdtJ0S3wLtJeZOybT8uEabQ3kPSkSRUDRhs3HpI2uhKwKZKC8elADStJcASJOg7IcrF9BZvVBCPVi0bg6LdHF4IOqNkvmNaVM2iMWBHqoKLD9TvghAE92ecjdXxkxveb8tHElMxB7PblETZ1G2zDe1eNbBMkVEGdsDl4k3d709uAk86RPY3k2b5lZOIzbxnN2c5xk+LM9jv8PZaIBFkSwWBw9CRWwlLJ3fVZPTuYkUyLT+KPP7VBGAQmGev5tHTGMUrbvDU/pyeNn1oOQLQ74d6yeA51Hyfnn6FWDtmF8bueyXvzx+5XB/3d6/4rbfL+8Bz8Ne++X+s4z5pp/QLrtf/vJ47/B3U/L9Q/Fp4P87fn7R/c+NfwQYAFx9eFOvgdoSAAAAAElFTkSuQmCC"/></p><style>.base64.sign {display: none;}</style><p id="P0369_1" class="formattext topleveltext indenttext" align="justify">Цель. Независимая проверка ограничений синхронизации, осуществляемая во время синтеза.<br/><br/></p><p id="P0369_2" class="formattext topleveltext indenttext" align="justify">Описание. Статический временной анализ (STA) анализирует все пути списка соединений (схемы), полученного средствами синтеза, с учётом реальной длины соединений при расчёте времени задержки в линиях связи и задержек логических элементов, не выполняя реальное моделирование. Это позволяет в общем случае выполнить полный анализ ограничений синхронизации для всей схемы. Тестируемая схема должна быть проанализирована в наилучших и наихудших условиях эксплуатации, на максимально задаваемой тактовой частоте, с учетом возможной неустойчивости синхронизации и расфазировки ее рабочего цикла. Число путей, не соответствующих синхронизации, может быть ограничено определенным минимумом, в зависимости от используемого метода проектирования. Перед началом проектирования рекомендуется исследовать, анализировать и определять применяемый метод, который должен обеспечить легко читаемые результаты.<br/><br/></p><p id="P0369_3" class="formattext topleveltext indenttext" align="justify">Примечание - Можно предположить, что STA явно охватывает все существующие синхронизируемые пути, если:<br/><br/></p><p id="P036B" class="formattext topleveltext indenttext" align="justify">а) ограничения синхронизации должным образом определены;<br/><br/></p><p id="P036D" class="formattext topleveltext indenttext" align="justify">b) тестируемая схема содержит только такие синхронизируемые пути, которые могут быть проанализированы средствами STA, то есть в общем случае полностью синхронные схемы.<br/><br/></p><p id="P036F" class="formattext topleveltext indenttext" align="justify"><b>Е.24 Проверочное сравнение списка соединений логических элементов с эталонной моделью средствами моделирования</b><br/><br/></p><p id="P036F_1" class="formattext topleveltext indenttext" align="justify">Цель. Проверка функциональной эквивалентности синтезированного списка соединений логических элементов.<br/><br/></p><p id="P036F_2" class="formattext topleveltext indenttext" align="justify">Описание. Моделирование списка соединений логических элементов, сгенерированного средствами синтеза. Используемые входные сигналы для проверки схемы моделированием точно соответствуют входным сигналам, примененным в процессе выполнения &quot;Функционального тестирования на уровне модуля&quot; (Е.6) и &quot;Функционального тестирования на верхнем уровне&quot; (Е.7) для функциональной проверки на уровне модуля и на верхнем уровне соответственно. Функциональная проверка в основном должна осуществляться с помощью анализа выходных сигналов микросхемы. Она может быть выполнена автоматически, путем сравнения выходных сигналов схемы с соответствующей эталонной моделью или с исходным кодом схемы на языке (V)HDL. Этот тест известен как &quot;регрессионный тест&quot; и его выполнение должно быть более предпочтительным по сравнению с ручной проверкой выходных сигналов.<br/><br/></p><p id="P036F_3" class="formattext topleveltext indenttext" align="justify">Примечание - Данный метод позволяет проверить функциональное поведение только для тех путей списка соединений логических элементов, которые фактически активны во время моделирования. Поэтому тестовый охват может быть только таким же, как и во время исходного функционального тестирования на уровне модуля или на верхнем уровне соответственно. Можно дополнить этот метод формальным тестом на эквивалентность. Во всех случаях функциональная проверка исходного кода на языке (V)HDL должна выполняться с окончательным списком соединений, сгенерированным средствами синтеза.<br/><br/></p><p id="P0371" class="formattext topleveltext indenttext" align="justify"><b>Е.25 Сравнение списка соединений логических элементов с эталонной моделью (формальный тест на эквивалентность)</b><br/><br/></p><p id="P0371_1" class="formattext topleveltext indenttext" align="justify">Цель. Независимая от моделирования проверка функциональной эквивалентности.<br/><br/></p><p id="P0371_2" class="formattext topleveltext indenttext" align="justify">Описание. Сравнение функциональности схемы, описанной в исходных кодах языка (V)HDL с функциональностью схемы, описанной списком соединений логических элементов, сгенерированным средствами синтеза. Средства, в основе которых лежит принцип формальной эквивалентности, могут проверять функциональную эквивалентность схемы, описанной различными формами ее представления, например, на языке (V)HDL или в виде ее списка соединений. Если применяется этот метод, то нет необходимости в функциональном моделировании, но независимая функциональная проверка возможна. Успешное применение этого метода может быть гарантировано, если только используемый инструмент будет способен доказывать полную эквивалентность, а все сообщения о несоответствиях оцениваются автоматически или проверяются вручную.<br/><br/></p><p id="P0371_3" class="formattext topleveltext indenttext" align="justify">Примечание - Данный метод выгодно объединить с методом Е.24 &quot;Проверочное сравнение списка соединений логических элементов с эталонной моделью средствами моделирования&quot;. В любом случае функциональная проверка исходного кода на языке (V)HDL должна выполняться с окончательным списком соединений, сгенерированным средствами синтеза.<br/><br/></p><p id="P0373" class="formattext topleveltext indenttext" align="justify"><b>Е.26 Проверка требований и ограничений поставщика СИС</b><br/><br/></p><p id="P0373_1" class="formattext topleveltext indenttext" align="justify">Цель. Предотвращение отказов в процессе разработки проверкой требований поставщика.<br/><br/></p><p id="P0373_2" class="formattext topleveltext indenttext" align="justify">Описание. Тщательная проверка требований и ограничений поставщика (например минимальное и максимальное разветвление на входе и разветвление на выходе, максимальная длина соединения (задержка линии связи), максимальная скорость фронта выходных сигналов, расфазировка тактовых сигналов и т.д.) средствами синтеза улучшает надежность изделия. Требования поставщика к процессу разработки очень важны, поэтому их нарушение оказывает огромное влияние на обоснованность применяемых моделей, использующихся для моделирования. Поэтому любое нарушение требований и ограничений поставщика ведет к некорректным результатам моделирования, дающим нежелательную функциональность.<br/><br/></p><p id="P0375" class="formattext topleveltext indenttext" align="justify"><b>Е.27 Документальное оформление ограничений, результатов и средств синтеза</b><br/><br/></p><p id="P0375_1" class="formattext topleveltext indenttext" align="justify">Цель. Документальное оформление всех сформированных ограничений, которые необходимы для оптимального синтеза при генерации окончательного списка соединений логических элементов.<br/><br/></p><p id="P0375_2" class="formattext topleveltext indenttext" align="justify">Описание. Документальное оформление всех ограничений и результатов синтеза необходимо, чтобы:<br/><br/></p><p id="P0375_3" class="formattext topleveltext indenttext" align="justify">- воспроизвести синтез на любой более поздней стадии;<br/><br/></p><p id="P0375_4" class="formattext topleveltext indenttext" align="justify">- независимо генерировать результаты синтеза для проверки.<br/><br/></p><p id="P0375_5" class="formattext topleveltext indenttext" align="justify">Важными документами являются:<br/><br/></p><p id="P0375_6" class="formattext topleveltext indenttext" align="justify">- описание настроек синтеза, включая применяемые инструментальные средства и программное обеспечение синтеза с указанием фактических версий, используемые библиотеки синтеза и заданные ограничения и сценарии;<br/><br/></p><p id="P0375_7" class="formattext topleveltext indenttext" align="justify">- журнал выполнения синтеза (лог-файл) с указанием времени, используемого средства с указанием версии и полную документацию для синтеза;<br/><br/></p><p id="P0375_8" class="formattext topleveltext indenttext" align="justify">- сгенерированный список соединений с предполагаемыми задержками (файл в формате SDF).<br/><br/></p><p id="P0377" class="formattext topleveltext indenttext" align="justify"><b>Е.28 Применение проверенных в эксплуатации средств синтеза</b><br/><br/></p><p id="P0377_1" class="formattext topleveltext indenttext" align="justify">Цель. Применить средство, выполняющее преобразование описания схемы на языке (V)HDL в список соединений логических элементов.<br/><br/></p><p id="P0377_2" class="formattext topleveltext indenttext" align="justify">Описание. Средство, отображающее функциональность схемы, описанной на исходном коде языка (V)HDL, в соединения соответствущих логических элементов и примитивы схем из целевой библиотеки СИС. Выбор реализации из множества возможных реализаций, выполняющей требуемую функциональность, зависит от самого оптимального результата, который получен для ограничений синтеза, таких как синхронизация (тактовая частота) и площадь кристалла.<br/><br/></p><p id="P0379" class="formattext topleveltext indenttext" align="justify"><b>Е.29 Применение проверенной в эксплуатации целевой библиотеки</b><br/><br/></p><p id="P0379_1" class="formattext topleveltext indenttext" align="justify">Примечание - См. также Е.4 &quot;Средства, проверенные в эксплуатации&quot;.<br/><br/><br/></p><p id="P0379_2" class="formattext topleveltext indenttext" align="justify">Цель. Предотвращение систематических отказов, вызванных ошибками в целевой библиотеке.<br/><br/></p><p id="P0379_3" class="formattext topleveltext indenttext" align="justify">Описание. Целевые библиотеки синтеза и моделирования для разработки СИС формируются из общей базы данных и поэтому не являются независимыми. Типичными примерами систематических отказов являются:<br/><br/></p><p id="P0379_4" class="formattext topleveltext indenttext" align="justify">- неоднозначность между реальным и промоделированным поведением элементов схемы;<br/><br/></p><p id="P0379_5" class="formattext topleveltext indenttext" align="justify">- некорректное моделирование, например, времени установки и времени хранения.<br/><br/></p><p id="P0379_6" class="formattext topleveltext indenttext" align="justify">Поэтому при проектировании СИС, выполняющих функции безопасности, должны использоваться только &quot;проверенные в эксплуатации&quot; технологии и целевые библиотеки. Это означает:<br/><br/></p><p id="P0379_7" class="formattext topleveltext indenttext" align="justify">- применение целевых библиотек, использующихся в течение достаточно длительного времени в проектах с сопоставимой сложностью и тактовой частотой;<br/><br/></p><p id="P0379_8" class="formattext topleveltext indenttext" align="justify">- доступность технологии и соответствующей целевой библиотеки в течение достаточно длительного периода, поэтому можно считать, что библиотека обеспечивает достаточную точность моделирования.<br/><br/></p><p id="P037B" class="formattext topleveltext indenttext" align="justify"><b>Е.30 Процедуры, основанные на сценарии</b><br/><br/></p><p id="P037B_1" class="formattext topleveltext indenttext" align="justify">Цель. Воспроизводимость результатов и автоматизация циклов синтеза.<br/><br/></p><p id="P037B_2" class="formattext topleveltext indenttext" align="justify">Описание. Автоматическое и основанное на сценарии управление циклами синтеза, включая определение применяемых ограничений. Помимо точной документации на все ограничения синтеза, это помогает воспроизвести список соединений после изменения исходного кода на языке (V)HDL при идентичных условиях.<br/><br/></p><p id="P037D" class="formattext topleveltext indenttext" align="justify"><b>Е.31 Реализация тестовых структур</b><br/><br/></p><p id="P037D_1" class="formattext topleveltext indenttext" align="justify">Цель. Проектирование тестируемых СИС, гарантирующих заключительное испытание.<br/><br/></p><p id="P037D_2" class="formattext topleveltext indenttext" align="justify">Описание. Проектирование тестируемости с помощью создания различных тестовых структур обеспечивает создание схем, которые легко тестируются, например:<br/><br/></p><p id="P037D_3" class="formattext topleveltext indenttext" align="justify">- сканирование пути. В этом методе либо все (полное сканирование проекта) или часть триггеров (частичное сканирование проекта) соединены в единую цепь или несколько цепей, создающих цепочку сдвиговых регистров. Метод сканирования пути автоматически генерирует тестовый пример для всей логики схемы. Инструментальное средство, генерирующее тестовый пример, называют &quot;Автоматическим генератором тестового примера&quot; (ATPG). Реализация метода сканирования пути существенно улучшает тестируемость схемы и позволяет получить более 98% тестового охвата при разумных усилиях. Поэтому рекомендуется реализовывать полное сканирование, если это возможно;<br/><br/></p><p id="P037D_4" class="formattext topleveltext indenttext" align="justify">- НЕ-И-дерево. В НЕ-И-дереве все основные входы схемы соединены каскадно и создают цепочку. Применяя подходящий тестовый пример (&quot;блуждающий бит&quot;), можно протестировать поведение схемы при переключении (синхронизацию и уровень запуска). НЕ-И-дерево является средством, непосредственно характеризующим первичные входы. Его рекомендуется применять, если поведение схемы при переключении не может быть протестировано иначе;<br/><br/></p><p id="P037D_5" class="formattext topleveltext indenttext" align="justify">- встроенное самотестирование (BIST): Самотестирование схемы и в особенности самотестирование встроенной памяти может быть выполнено очень эффективно, если на кристалле реализовать генератор тестовых примеров. BIST выполняет автоматическую проверку структуры схемы, применяя псевдослучайные тестовые примеры и оценивая сигнатуру реализованной структуры схемы. BIST рекомендуется как дополнительная мера особенно для тестирования памяти. Тест &quot;Сканирующий путь&quot; может быть заменен на BIST;<br/><br/></p><p id="P037D_6" class="formattext topleveltext indenttext" align="justify">- тестирование статического тока потребления (IDDQ-тест). Статическая КМОП-схема потребляет ток, главным образом, в процессе переключения. Поэтому абсолютно исправная схема потребляет очень небольшую величину тока (ток утечки &lt; 1 мА) до тех пор, пока не запускается тестовый пример. IDDQ-тест очень эффективен и обеспечивает более, чем 50%-ный тестовый охват сразу же после применения нескольких тестов. IDDQ-тест может быть применен на функциональных тестовых примерах, так же, как и на синтезированных тестовых примерах, сгенерированных средствами ATPG. Этот метод тестирования на практике оказался самым полезным и обнаруживал отказы, которые другие тесты редко или даже совсем не могли выявить. Поэтому данный метод должен применяться дополнительно, вместе с регулярными испытаниями проекта;<br/><br/></p><p id="P037D_7" class="formattext topleveltext indenttext" align="justify">- периферийное сканирование. Тестовая архитектура для проверки соединений компонентов на печатной плате реализуется в соответствии со стандартом JTAG. Тот же самый подход может быть применен для проверки соединений модулей на уровне кристалла. Периферийное сканирование в основном рекомендуется для улучшения тестируемости печатных плат.<br/><br/></p><p id="P037F" class="formattext topleveltext indenttext" align="justify"><b>Е.32 Оценка тестового охвата моделированием</b><br/><br/></p><p id="P037F_1" class="formattext topleveltext indenttext" align="justify">Цель. Определение достигаемого тестового охвата, реализованного архитектурой тестов во время испытаний проекта.<br/><br/></p><p id="P037F_2" class="formattext topleveltext indenttext" align="justify">Описание. Тестовый охват, достигаемый тестом &quot;Сканирование пути&quot;, BIST, функциональным тестовым примером или любыми другими методами, может быть определен моделированием отказа. Во время моделирования отказа тестовый пример применяется к схеме, в которую включены отказы. Реакция схемы на отказ при запуске тестового примера соответствует включенным отказам и, таким образом, вносит вклад в тестовый охват. Моделирование отказа позволяет обнаружить константные отказы, &quot;константный 1&quot; и &quot;константный 0&quot;, а достигаемый тестовый охват представляет качество примененного тестового примера. Вообще моделирование отказа может использоваться очень эффективно для обнаружения отказов, связанных с логикой, которая не охватывается тестом &quot;Сканирование пути&quot;, например, в случае частичного сканирования.<br/><br/></p><p id="P0381" class="formattext topleveltext indenttext" align="justify"><b>Е.33 Оценка тестового охвата средствами ATPG</b><br/><br/></p><p id="P0381_1" class="formattext topleveltext indenttext" align="justify">Цель. Определение ожидаемого тестового охвата для синтезируемых тестовых примеров (&quot;Сканирование пути&quot;, BIST) в процессе испытаний проекта.<br/><br/></p><p id="P0381_2" class="formattext topleveltext indenttext" align="justify">Описание. В настоящее время существуют разные процедуры, которые генерируют псевдослучайные или алгоритмические тестовые примеры для схемы, реализованные в методе &quot;Сканирование пути&quot;. Средства синтеза, такие как ATPG, создают в процессе синтеза каталог невыявленных отказов. Таким способом можно оценить тестовый охват и определить нижний предел достигаемого тестового охвата для применяемого тестового примера. Важно заметить, что тестовый охват ограничен логикой схемы, которая охвачена методом &quot;Сканирование пути&quot;. Модули, такие как память, BIST или часть схем, которые оказались не охваченными методом &quot;Сканирование пути&quot;, не рассматривают при оценке тестового охвата.<br/><br/></p><p id="P0383" class="formattext topleveltext indenttext" align="justify"><b>Е.34 Обоснование проверкой в эксплуатации применяемых блоков СИС на физическом уровне реализации</b><br/><br/></p><p id="P0383_1" class="formattext topleveltext indenttext" align="justify">Цель. Предотвращение систематических отказов в применяемых блоках СИС на физическом уровне реализации.<br/><br/></p><p id="P0383_2" class="formattext topleveltext indenttext" align="justify">Описание. Блок СИС на физическом уровне реализации обычно рассматривается как &quot;черный ящик&quot;, который обеспечивает требуемую функциональность и составляет основные данные по размещению в заданной технологии, и который поддерживает необходимый компонент схемы. Возможный функциональный отказ может трактоваться по аналогии с дискретными компонентами, такими как стандартные микропроцессоры, память и т.д. Эксплуатация таких блоков без проверки корректности функционирования возможна, если для применяемой заданной технологии использование блока можно рассматривать как проверенный в эксплуатации компонент. В таком случае остальная часть схемы должна быть обязательно проверена.<br/><br/></p><p id="P0385" class="formattext topleveltext indenttext" align="justify"><b>Е.35 Применение блоков СИС (на физическом уровне реализации), прошедших подтверждение соответствия</b><br/><br/></p><p id="P0385_1" class="formattext topleveltext indenttext" align="justify">Примечание - См. также Е.6 &quot;Функциональное тестирование на уровне модуля&quot;.<br/><br/><br/></p><p id="P0385_2" class="formattext topleveltext indenttext" align="justify">Цель. Предотвращение систематических отказов в применяемых блоках СИС на физическом уровне реализации.<br/><br/></p><p id="P0385_3" class="formattext topleveltext indenttext" align="justify">Описание. Ввиду сложности блока СИС и принятых ограничений подтверждение соответствия блока СИС должно выполняться поставщиком на стадии проектирования с использованием исходного кода на языке (V)HDL. Подтверждение соответствия может быть обосновано только для конкретной конфигурации и заданной технологии применяемого компонента.<br/><br/></p><p id="P0387" class="formattext topleveltext indenttext" align="justify"><b>Е.36 Тестирование блоков СИС (на физическом уровне реализации) в неавтономном режиме</b><br/><br/></p><p id="P0387_1" class="formattext topleveltext indenttext" align="justify">Примечание - См. также Е.13 &quot;Охват сценариями верификации (испытательные стенды)&quot;.<br/><br/><br/></p><p id="P0387_2" class="formattext topleveltext indenttext" align="justify">Цель. Предотвращение систематических отказов в применяемых блоках СИС на физическом уровне реализации.<br/><br/></p><p id="P0387_3" class="formattext topleveltext indenttext" align="justify">Описание. Проверка тестами в режиме онлайн корректности функционирования и реализации используемых блоков СИС. Для применения этого средства требуется эффективная концепция испытания, а оценка применяемой концепции должна быть документально оформлена.<br/><br/></p><p id="P0389" class="formattext topleveltext indenttext" align="justify"><b>Е.37 Проверка правила проектирования (DRC)</b><br/><br/></p><p id="P0389_1" class="formattext topleveltext indenttext" align="justify">Цель. Проверка правил проектирования поставщика.<br/><br/></p><p id="P0389_2" class="formattext topleveltext indenttext" align="justify">Описание: Проверка сгенерированного размещения в соответствии с правилами проектирования поставщика, например, минимальные длины проводников, максимальные длины проводников и ряд правил, связанных с компоновкой размещаемых структур. Полное и корректное выполнение DRC должно быть подробно документально оформлено.<br/><br/></p><p id="P038B" class="formattext topleveltext indenttext" align="justify"><b>Е.38 Проверка соответствия топологии схеме (LVS)</b><br/><br/></p><p id="P038B_1" class="formattext topleveltext indenttext" align="justify">Цель. Независимая проверка размещения.<br/><br/></p><p id="P038B_2" class="formattext topleveltext indenttext" align="justify">Описание. LVS формирует функциональность схемы из данных о размещении и сравнивает полученные элементы схемы, включая соединения с входным списком соединений. Это гарантирует эквивалентность размещения схемы со списком соединений, определяющим функциональность схемы. Полное и корректное выполнение LVS должно быть подробно документально оформлено.<br/><br/></p><p id="P038D" class="formattext topleveltext indenttext" align="justify"><b>Е.39 Дополнительный резерв времени (&gt;20%) для технологических процессов, которые применяются менее трех лет</b><br/><br/></p><p id="P038D_1" class="formattext topleveltext indenttext" align="justify">Цель. Обеспечение устойчивости реализуемой функциональности схемы даже при серьезной флуктуации процесса и параметров.<br/><br/></p><p id="P038D_2" class="formattext topleveltext indenttext" align="justify">Описание. Реальное поведение схемы определено рядом одновременно влияющих на нее физических факторов, особенно на ее малые структуры (например менее 0,5 мк). Фактически, из-за отсутствия подробных знаний и необходимых упрощений, точную модель элементов схемы построить нельзя. С уменьшением геометрических размеров структур схемы задержки в соединениях играют все более важную роль. Задержки сигнала в соединениях между элементами и емкости перекрестных связей между проводниками растут нелинейно. Задержки сигнала в проводниках становятся сравнимыми с задержками в логических элементах. Оценки задержек в соединениях при уменьшении геометрических размеров структур указывают на увеличивающийся риск появления сбоев.<br/><br/></p><p id="P038D_3" class="formattext topleveltext indenttext" align="justify">Поэтому рекомендуется запланировать необходимый резерв времени (&gt;20%) относительно минимальных и максимальных ограничений синхронизации для схем, в разработке которых использовались процессы, опыт применения которых составляет менее трех лет, чтобы гарантировать корректное выполнение функциональности схемы в условиях серьезно изменяющихся производственных параметров или из-за отсутствия точного моделирования.<br/><br/></p><p><img class="base64 sign" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZIAAAARCAMAAADAD9oKAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MTg4Q0U3ODQ0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MTg4Q0U3ODU0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoxODhDRTc4MjRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDoxODhDRTc4MzRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pos3t18AAAAzUExURfX19SQkJOrq6oeHh7y8vD8/P9/f31RUVMjIyLCwsHh4eJaWlmdnZ6Ojo9TU1AAAAP////kimdMAAAWSSURBVHja7FiJcuQoDAVzGcz1/1+7TwLRuDs9mZ2karZqQ1ViGz90PUngVv1nfMOo9fg2WarnNkf9FGxMHdDkf1jo3bXBg7o0YhIkfrXV0npvBfd48y94HQtV97XWZvBPfbpG29oikGfQ6oeRs4WLb4K2CGNq5wsltpX6B5TQYEa5/u6h9rdn31QdtXS0iKX1WZ360/o9Pl/3NmVq/ahk/cfwZ0X+bSL6T01Kxmq6Fj0MSDNPj+atGzF1+Y17z9IZMRfulHiH+ivMFvE7nm2ffQ26Q5+U0AKLatWUGFm63kU3SJycuwqNLgNJ1ONf6crorUNyEySMStQLlegNgSuSmiT5agizm0YyZwPNbEXLM64y2X0YcGgdN3ytU9FaLDCecHbCyFWVh0kjMvBEHK+rvx/tVIgOWSoTcZrRa+aVJxeOuLc5nG8Oj2cjCzdKDm1Uj9BCSFeO7sKBgKCxRWpXKNAiFtV2njBAGeqm2QBQaZKCjjDCA+vqnZJD802sAzu9q4EwRtde4djUG4kJeFObpsag4cXNNJKJejRY7pVO9EJiQf2XRJLlBEcW1Toooc48FcniBeN2nOALwwzMDXhDJv2CkoKENkS/NKzu0p74rRyOk0vcezgs0iXQhLDixE4J6YAALgUqoEq6VKpih0KosOuUUihxM+eGo6KIA3DEaTI8oJS7UZIybnhmOVX1wCiqLJSYmnr52WjShadTA7Obtsyl2lP22PquxG9kJ1VbSWN2gEXRfF4wlnri36xnTJBYC+R7ShyX17HNDIcXJSg8ddMqDi/p0+HOCGNfKclwPmdHBsVgp9mbHaemuwBMwtvmCK2pQqtwdpakiZIQg7pTAitwc+m6OVWyWFhnzQy9aMrcDZASSAJjgNlMo5R4UIJ1xbhnSsYr+p/LRslS1FfshQFIpb4v06WRvgBky4VfseOmPqy3zaKiZqp/SEmpOqhdqzi8pE+H6/2wu1PiCg9AkvOvlJi0r2ZbS7FooaMpdo8WYy6ixPFRZKcEE9Iz115irhdKWC/y1VquyIpWqU+i5GEapcRWJaGFFN9T4s7foyRQdqmNkqHvGJmn82AtUzed1s9vB63U6jj6ulOCnnbtWsXhJX06/J6S5LbDmKYuy/W11rgbobKpdRvmtNFKGpfS142SqEcL8CE99hIKV+ZmbDnr/NQL2Slx46wxoDSB2U27NS77eN4oGZaj91G6PChZiubzgo2+i9AKJbEd/S5yKA5ZAnCwLL6IcfYe2aHWb1rF4SV9OjwQ9XylZGwwORFSIeLUakYnHEVAgh6U0D7elY49C1OZNrM09pIC8EaJtnyjdHiIqE4qiY+K2YleProNrUcLhk8Lm2k3SgrF/KVKhuUQVUzfKFmK5vOCvVBytMSb69NeolwS66954oXTvnF2en3b3XmlIo3LPXF4SReHXZ5b3zMlCKcpAVse9z38XXh2kvo9htvuppy+LqeP0LgvBo/IpIJ+b/kQrGUDaM4XPvlBR9IPVq3mlkDldKIJ5k0vnGyzNh2myYvdtJ0S3wLtJeZOybT8uEabQ3kPSkSRUDRhs3HpI2uhKwKZKC8elADStJcASJOg7IcrF9BZvVBCPVi0bg6LdHF4IOqNkvmNaVM2iMWBHqoKLD9TvghAE92ecjdXxkxveb8tHElMxB7PblETZ1G2zDe1eNbBMkVEGdsDl4k3d709uAk86RPY3k2b5lZOIzbxnN2c5xk+LM9jv8PZaIBFkSwWBw9CRWwlLJ3fVZPTuYkUyLT+KPP7VBGAQmGev5tHTGMUrbvDU/pyeNn1oOQLQ74d6yeA51Hyfnn6FWDtmF8bueyXvzx+5XB/3d6/4rbfL+8Bz8Ne++X+s4z5pp/QLrtf/vJ47/B3U/L9Q/Fp4P87fn7R/c+NfwQYAFx9eFOvgdoSAAAAAElFTkSuQmCC"/></p><style>.base64.sign {display: none;}</style><p id="P038F" class="formattext topleveltext indenttext" align="justify"><b>Е.40 Отбраковочное испытание</b><br/><br/></p><p id="P038F_1" class="formattext topleveltext indenttext" align="justify">Цель. Обеспечение живучести изготавливаемой микросхемы. Устранение отказов на ранних стадиях. Изделия с дефектами на кристалле не должны доказывать свою живучесть выжиганием дефектов, а должны, например, использовать стресс-методы на уровне пластины.<br/><br/></p><p id="P038F_2" class="formattext topleveltext indenttext" align="justify">Описание. Отбраковочное испытание должно быть выполнено при самой высокой приемлемой рабочей температуре (обычно 125°С). Продолжительность тестирования зависит от целевого УПБ или от заданных рекомендаций по выжиганию дефектов, например, производителем СИС. Выжигание дефектов может быть использовано, чтобы:<br/><br/></p><p id="P038F_3" class="formattext topleveltext indenttext" align="justify">- устранить отказы на ранних стадиях (уменьшение интенсивности отказов в начале ваннообразной кривой распределения отказов);<br/><br/></p><p id="P038F_4" class="formattext topleveltext indenttext" align="justify">- доказать, что отказы на ранних стадиях уже устранены в процессе производства и тестирования (то есть что устройства, вышедшие из производства, уже находятся в области постоянной интенсивности отказов ваннообразной кривой).<br/><br/></p><p id="P0391" class="formattext topleveltext indenttext" align="justify"><b>Е.41 Применение серийных устройств, проверенных в эксплуатации</b><br/><br/></p><p id="P0391_1" class="formattext topleveltext indenttext" align="justify">Цель. Обеспечение безотказности изготовленных кристаллов.<br/><br/></p><p id="P0391_2" class="formattext topleveltext indenttext" align="justify">Описание. У производителя системы безопасности должен быть достаточный опыт применения технологии программируемых устройств, а также средств разработки.<br/><br/></p><p id="P0393" class="formattext topleveltext indenttext" align="justify"><b>Е.42 Процесс производства, проверенный в эксплуатации</b><br/><br/></p><p id="P0393_1" class="formattext topleveltext indenttext" align="justify">Цель. Обеспечение безотказности изготовленных кристаллов.<br/><br/></p><p id="P0393_2" class="formattext topleveltext indenttext" align="justify">Описание. Проверенный в эксплуатации процесс производства характеризуется достаточно высоким качеством серийного производства.<br/><br/></p><p id="P0395" class="formattext topleveltext indenttext" align="justify"><b>Е.43 Контроль качества производственного процесса</b><br/><br/></p><p id="P0395_1" class="formattext topleveltext indenttext" align="justify">Меры качества и механизмы управления производственного процесса устройства гарантируют непрерывное управление процессом. Например, оптическое или электрическое управление тестовыми структурами, температурные испытания с изменением параметров влажности или циклический температурный тест (см. [14], [15] и т.д.).<br/><br/></p><p id="P0397" class="formattext topleveltext indenttext" align="justify"><b>Е.44 Передача качественно изготовленного устройства</b><br/><br/></p><p id="P0397_1" class="formattext topleveltext indenttext" align="justify">Качество устройства обеспечивается выполнением выбранной группы стресс-тестов, например, температурными испытаниями с изменением параметров влажности или тестами с изменением температуры (см. [14], [15] и т.д.). Производитель устройства предоставит такие доказательства.<br/><br/></p><p id="P0399" class="formattext topleveltext indenttext" align="justify"><b>Е.45 Передача качественно функционирующего устройства</b><br/><br/></p><p id="P0399_1" class="formattext topleveltext indenttext" align="justify">Все устройства будут функционально протестированы. Производитель устройства предоставит такие доказательства.<br/><br/></p><p id="P039B" class="formattext topleveltext indenttext" align="justify"><b>Е.46 Стандарты качества</b><br/><br/></p><p id="P039B_1" class="formattext topleveltext indenttext" align="justify">Производитель СИС должен предусмотреть достаточный уровень управления качеством, например, иметь оформленное &quot;Руководство по качеству и надежности&quot;, в котором документально подтверждено выполнение сертификации по ISO 9000 или оценки качества стандартного поставщика (SSQA - Standard Supplier Quality Assessment).<br/></p><p id="P039C" class="formattext topleveltext centertext" align="center"></p><h2 id="P039F" class="formattext topleveltext centertext" align="center" title-level="2">Приложение F<br/>(справочное)<br/></h2><p id="P03A0" class="headertext topleveltext centertext" align="center">Определение свойств стадий жизненного цикла программного обеспечения </p><p id="P03A1" class="formattext topleveltext indenttext" align="justify"><br/><br/></p><p id="P03A1_1" class="formattext topleveltext" align="justify">Таблица F.1 - Спецификация требований к программному обеспечению системы безопасности (см. МЭК 61508-3, подраздел 7.2 и таблица С.1)<br/></p><p id="X2260"></p><div element-type="table" class="table-container" id="X2261"><style type="text/css">#P03A2 .td1 {width: 3.85em}#P03A2 .td2 {width: 15.40em}#P03A2 .td3 {width: 28.49em}#P03A2 .td4 {width: 3.85em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }#P03A2 .td5 {width: 15.40em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }#P03A2 .td6 {width: 28.49em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }</style><table id="P03A2" class="wideTable"><tr height="1"><td class="td1"></td><td class="td2"></td><td class="td3"></td></tr><tr><td valign="top" class="td4"><p id="P03A20000" class="formattext" align="center"></p></td><td valign="top" class="td5"><p id="P03A20001" class="formattext" align="center">Свойство </p></td><td valign="top" class="td6"><p id="P03A20002" class="formattext" align="center">Определение<br/></p></td></tr><tr><td valign="top" class="td4"><p id="P03A20003" class="formattext">1.1 </p></td><td valign="top" class="td5"><p id="P03A20004" class="formattext">Полнота охвата потребностей безопасности программным обеспечением </p></td><td valign="top" class="td6"><p id="P03A20005" class="formattext">Спецификация требований к программному обеспечению системы безопасности охватывает все потребности и ограничения системы безопасности, появившиеся на более ранних стадиях жизненного цикла системы безопасности и определенные для программного обеспечения.<br/><br/> Потребности и ограничения системы безопасности обычно устанавливаются перед началом разработки спецификации требований к программному обеспечению системы безопасности. Они могут включать спецификацию того, что программное обеспечение не должно выполнять или должно избегать<br/></p></td></tr><tr><td valign="top" class="td4"><p id="P03A20006" class="formattext">1.2 </p></td><td valign="top" class="td5"><p id="P03A20007" class="formattext">Корректность охвата потребностей безопасности программным обеспечением </p></td><td valign="top" class="td6"><p id="P03A20008" class="formattext">Спецификация требований к программному обеспечению системы безопасности адекватно отвечает потребностям и ограничениям системы безопасности, которые были определены для программного обеспечения.<br/><br/>Целью является уверенность в том, что все, что определено в спецификации, действительно гарантирует безопасность для всех необходимых условий<br/></p></td></tr><tr><td valign="top" class="td4"><p id="P03A20009" class="formattext">1.3 </p></td><td valign="top" class="td5"><p id="P03A2000A" class="formattext">Отсутствие ошибок в самой спецификации, включая отсутствие неоднозначности </p></td><td valign="top" class="td6"><p id="P03A2000B" class="formattext">Внутренняя полнота и согласованность спецификации требований к программному обеспечению системы безопасности: предоставление всей необходимой информации для всех функций и ситуаций, которая должна быть получена из спецификации; отсутствие в ней противоречивых или несогласованных положений.<br/><br/>Противоречие полноте и согласованности потребностям системы безопасности, внутренней полноте и согласованности может быть оценено только на основе спецификации требований к программному обеспечению системы безопасности<br/></p></td></tr><tr><td valign="top" class="td4"><p id="P03A2000C" class="formattext">1.4 </p></td><td valign="top" class="td5"><p id="P03A2000D" class="formattext">Ясность требований к безопасности </p></td><td valign="top" class="td6"><p id="P03A2000E" class="formattext">Спецификация требований к программному обеспечению системы безопасности должна быть полностью понятна без излишних усилий тем специалистам, которые должны ее читать, даже если они не принимали участие в ее разработке, при условии, что эти специалисты обладают необходимыми знаниями.<br/><br/>Одна важная цель состоит в том, чтобы облегчить проверку и, возможно, модификации<br/></p></td></tr><tr><td valign="top" class="td4"><p id="P03A2000F" class="formattext">1.5 </p></td><td valign="top" class="td5"><p id="P03A20010" class="formattext">Отсутствие неблагоприятного взаимовлияния функций, не связанных с безопасностью, и функций безопасности, реализуемых программным обеспечением системы безопасности </p></td><td valign="top" class="td6"><p id="P03A20011" class="formattext">Спецификация требований к программному обеспечению системы безопасности не содержит требований, которые не нужны для обеспечения безопасности УО.<br/><br/>Цель состоит в том, чтобы не усложнять разработку и реализацию программного обеспечения и сократить риск отказов и функций, не связанных с безопасностью, но влияющих или создающих опасные условия для отказов и функций, важных для безопасности<br/></p></td></tr><tr><td valign="top" class="td4"><p id="P03A20012" class="formattext">1.6 </p></td><td valign="top" class="td5"><p id="P03A20013" class="formattext">Способность обеспечения проведения оценки и подтверждения соответствия </p></td><td valign="top" class="td6"><p id="P03A20014" class="formattext">Спецификация требований к программному обеспечению системы безопасности является первоисточником необходимой информации для выполнения тестов и исследований, которые в результате их выполнения формируют объективное подтверждение о том, что программное обеспечение удовлетворяет спецификации требований к программному обеспечению системы безопасности<br/></p></td></tr></table></div><p id="P03A3" class="formattext topleveltext indenttext" align="justify"><br/><br/></p><p id="P03A3_1" class="formattext topleveltext" align="justify">Таблица F.2 - Проектирование и разработка программного обеспечения - проектирование архитектуры программ (см. МЭК 61508-3, пункт 7.4.3 и таблица С.2)<br/></p><p id="X2264"></p><div element-type="table" class="table-container" id="X2265"><style type="text/css">#P03A4 .td1 {width: 3.85em}#P03A4 .td2 {width: 15.40em}#P03A4 .td3 {width: 28.49em}#P03A4 .td4 {width: 3.85em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }#P03A4 .td5 {width: 15.40em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }#P03A4 .td6 {width: 28.49em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }#P03A4 .td7 {width: 3.85em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px none black; border-right: 1px solid black; }#P03A4 .td8 {width: 15.40em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px none black; border-right: 1px solid black; }#P03A4 .td9 {width: 28.49em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px none black; border-right: 1px solid black; }#P03A4 .td10 {width: 3.85em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px none black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }#P03A4 .td11 {width: 15.40em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px none black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }#P03A4 .td12 {width: 28.49em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px none black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }</style><table id="P03A4" class="wideTable"><tr height="1"><td class="td1"></td><td class="td2"></td><td class="td3"></td></tr><tr><td valign="top" class="td4"><p id="P03A40000" class="formattext" align="center"></p></td><td valign="top" class="td5"><p id="P03A40001" class="formattext" align="center">Свойство<br/></p></td><td valign="top" class="td6"><p id="P03A40002" class="formattext" align="center">Определение </p></td></tr><tr><td valign="top" class="td4"><p id="P03A40003" class="formattext">2.1 </p></td><td valign="top" class="td5"><p id="P03A40004" class="formattext">Полнота спецификации требований к программному обеспечению системы безопасности </p></td><td valign="top" class="td6"><p id="P03A40005" class="formattext">Проект архитектуры программного обеспечения охватывает все потребности и ограничения системы безопасности, появившиеся в спецификации требований к программному обеспечению системы безопасности<br/></p></td></tr><tr><td valign="top" class="td4"><p id="P03A40006" class="formattext">2.2 </p></td><td valign="top" class="td5"><p id="P03A40007" class="formattext">Корректность спецификации требований к программному обеспечению системы безопасности<br/></p></td><td valign="top" class="td6"><p id="P03A40008" class="formattext">Проект архитектуры программного обеспечения адекватно соответствует спецификации требований к программному обеспечению системы безопасности </p></td></tr><tr><td valign="top" class="td4"><p id="P03A40009" class="formattext">2.3 </p></td><td valign="top" class="td5"><p id="P03A4000A" class="formattext">Отсутствие собственных ошибок проекта </p></td><td valign="top" class="td6"><p id="P03A4000B" class="formattext">Проект архитектуры программного обеспечения и проектная документация не имеют ошибок, которые могут быть идентифицированы, независимо от любого указанного требования к программному обеспечению системы безопасности.<br/><br/>Примеры: зависания, доступ к несанкционированным ресурсам, утечки ресурсов, внутренняя неполнота (то есть, ошибки при обращении ко всем ситуациям, которые устанавливаются непосредственно в проекте)<br/></p></td></tr><tr><td valign="top" class="td7"><p id="P03A4000C" class="formattext">2.4 </p></td><td valign="top" class="td8"><p id="P03A4000D" class="formattext">Простота и понятность<br/><br/></p></td><td valign="top" class="td9"><p id="P03A4000E" class="formattext">Проект архитектуры программного обеспечения, обеспечивающий корректный и точный прогноз функционирования программного обеспечения для всех указанных ситуаций.<br/><br/>В частности, эти ситуации включают ситуации с ошибками и с отказами.<br/></p></td></tr><tr><td valign="top" class="td10"><p id="P03A4000F" class="formattext"></p></td><td valign="top" class="td11"><p id="P03A40010" class="formattext">Предсказуемость поведения </p></td><td valign="top" class="td12"><p id="P03A40011" class="formattext">Предсказуемость подразумевает, в частности, что функционирование не зависит от элементов, неконтролируемых разработчиками или пользователями<br/></p></td></tr><tr><td valign="top" class="td4"><p id="P03A40012" class="formattext">2.5 </p></td><td valign="top" class="td5"><p id="P03A40013" class="formattext">Верифицируемость и тестируемость проекта </p></td><td valign="top" class="td6"><p id="P03A40014" class="formattext">Проект архитектуры программного обеспечения и проектная документация обеспечивают и облегчают формирование убедительного доказательства, что все заданные требования к программному обеспечению системы безопасности правильно учтены в проекте и что проект лишен внутренних ошибок.<br/><br/>Верифицируемость может подразумевать получение таких свойств, как простота, модульность, ясность, тестируемость, доказуемость и т.д., в зависимости от используемых методов верификации<br/></p></td></tr><tr><td valign="top" class="td4"><p id="P03A40015" class="formattext">2.6 </p></td><td valign="top" class="td5"><p id="P03A40016" class="formattext">Отказоустойчивость </p></td><td valign="top" class="td6"><p id="P03A40017" class="formattext">Проект архитектуры программного обеспечения дает уверенность, что программное обеспечение будет вести себя безопасно в присутствии ошибок (внутренних ошибок, ошибок операторов или внешних систем).<br/><br/>Можно спроектировать активную или пассивную защиту. Проекты активной защиты могут включать такие функции, как обнаружение, создание сообщений и локализацию ошибок, постепенный вывод из эксплуатации и освобождение от любых нежелательных побочных эффектов до возобновления нормального функционирования. Проекты пассивной защиты включают функции, которые гарантируют непроникновение определенных типов ошибок или определенных условий (лавинообразных потоков на входах, особенно дат и времени) без привлечения программного обеспечения<br/></p></td></tr><tr><td valign="top" class="td4"><p id="P03A40018" class="formattext">2.7 </p></td><td valign="top" class="td5"><p id="P03A40019" class="formattext">Защита от отказов по общей причине, вызванной внешним событием </p></td><td valign="top" class="td6"><p id="P03A4001A" class="formattext">Проект архитектуры программного обеспечения облегчает идентификацию видов отказов по общей причине и эффективных средств предостережения от отказов<br/></p></td></tr></table></div><p id="P03A5" class="formattext topleveltext indenttext" align="justify"><br/><br/></p><p id="P03A5_1" class="formattext topleveltext" align="justify">Таблица F.3 - Проектирование и разработка программного обеспечения: инструментальные средства поддержки и языки программирования (см. МЭК 61508-3, пункт 7.4.4 и таблица С.3)<br/></p><p id="X2268"></p><div element-type="table" class="table-container" id="X2269"><style type="text/css">#P03A6 .td1 {width: 3.85em}#P03A6 .td2 {width: 15.40em}#P03A6 .td3 {width: 28.49em}#P03A6 .td4 {width: 3.85em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }#P03A6 .td5 {width: 15.40em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }#P03A6 .td6 {width: 28.49em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }</style><table id="P03A6" class="wideTable"><tr height="1"><td class="td1"></td><td class="td2"></td><td class="td3"></td></tr><tr><td valign="top" class="td4"><p id="P03A60000" class="formattext"></p></td><td valign="top" class="td5"><p id="P03A60001" class="formattext" align="center">Свойство<br/></p></td><td valign="top" class="td6"><p id="P03A60002" class="formattext" align="center">Определение </p></td></tr><tr><td valign="top" class="td4"><p id="P03A60003" class="formattext">3.1 </p></td><td valign="top" class="td5"><p id="P03A60004" class="formattext">Поддержка разработки программного обеспечения с требуемыми свойствами программного обеспечения<br/></p></td><td valign="top" class="td6"><p id="P03A60005" class="formattext">Средства, обеспечивающие обнаружение ошибок или устранение подверженных ошибкам структур </p></td></tr><tr><td valign="top" class="td4"><p id="P03A60006" class="formattext">3.2 </p></td><td valign="top" class="td5"><p id="P03A60007" class="formattext">Четкость работы и функциональность инструментальных средств<br/></p></td><td valign="top" class="td6"><p id="P03A60008" class="formattext">Обеспечение всестороннего охвата и ответной реакции для всех аспектов работы инструментальных средств </p></td></tr><tr><td valign="top" class="td4"><p id="P03A60009" class="formattext">3.3 </p></td><td valign="top" class="td5"><p id="P03A6000A" class="formattext">Корректность и воспроизводимость результата </p></td><td valign="top" class="td6"><p id="P03A6000B" class="formattext">Непротиворечивость и точность результата работы инструментального средства для любого входного задания<br/></p></td></tr></table></div><p id="P03A7" class="formattext topleveltext indenttext" align="justify"><br/><br/></p><p id="P03A7_1" class="formattext topleveltext" align="justify">Таблица F.4 - Проектирование и разработка программного обеспечения: детальное проектирование (см. МЭК 61508-3, пункт 7.4.5 и таблица С.4)<br/></p><p id="X2272"></p><div element-type="table" class="table-container" id="X2273"><style type="text/css">#P03A8 .td1 {width: 3.85em}#P03A8 .td2 {width: 15.40em}#P03A8 .td3 {width: 28.49em}#P03A8 .td4 {width: 3.85em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }#P03A8 .td5 {width: 15.40em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }#P03A8 .td6 {width: 28.49em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }</style><table id="P03A8" class="wideTable"><tr height="1"><td class="td1"></td><td class="td2"></td><td class="td3"></td></tr><tr><td valign="top" class="td4"><p id="P03A80000" class="formattext" align="center"></p></td><td valign="top" class="td5"><p id="P03A80001" class="formattext" align="center">Свойство<br/></p></td><td valign="top" class="td6"><p id="P03A80002" class="formattext" align="center">Определение </p></td></tr><tr><td valign="top" class="td4"><p id="P03A80003" class="formattext">4.1 </p></td><td valign="top" class="td5"><p id="P03A80004" class="formattext">Полнота спецификации требований к программному обеспечению системы безопасности </p></td><td valign="top" class="td6"><p id="P03A80005" class="formattext">Приняты методы детального проектирования и разработки программного обеспечения, которые гарантируют, что получающееся программное обеспечение охватывает все потребности и ограничения системы безопасности, сформированные для программного обеспечения<br/></p></td></tr><tr><td valign="top" class="td4"><p id="P03A80006" class="formattext">4.2 </p></td><td valign="top" class="td5"><p id="P03A80007" class="formattext">Корректность спецификации требований к программному обеспечению системы безопасности </p></td><td valign="top" class="td6"><p id="P03A80008" class="formattext">Существует конкретное доказательство, позволяющее утверждать, что требования к системе безопасности, сформированные для программного обеспечения, выполняются разработанным программным обеспечением<br/></p></td></tr><tr><td valign="top" class="td4"><p id="P03A80009" class="formattext">4.3 </p></td><td valign="top" class="td5"><p id="P03A8000A" class="formattext">Отсутствие собственных ошибок проекта </p></td><td valign="top" class="td6"><p id="P03A8000B" class="formattext">Разработанное программное обеспечение лишено внутренних отказов. Примеры: зависания, доступ к несанкционированным ресурсам, утечки ресурсов<br/></p></td></tr><tr><td valign="top" class="td4"><p id="P03A8000C" class="formattext">4.4 </p></td><td valign="top" class="td5"><p id="P03A8000D" class="formattext">Простота и понятность. Предсказуемость поведения </p></td><td valign="top" class="td6"><p id="P03A8000E" class="formattext">Поведение разрабатываемого программного обеспечения предсказуемо объективным и убедительным тестированием и анализом<br/></p></td></tr><tr><td valign="top" class="td4"><p id="P03A8000F" class="formattext">4.5 </p></td><td valign="top" class="td5"><p id="P03A80010" class="formattext">Верифицируемость и тестируемость проекта </p></td><td valign="top" class="td6"><p id="P03A80011" class="formattext">Разработанное программное обеспечение является поддающимся проверке и тестируемым<br/></p></td></tr><tr><td valign="top" class="td4"><p id="P03A80012" class="formattext">4.6 </p></td><td valign="top" class="td5"><p id="P03A80013" class="formattext">Отказоустойчивость/<br/>Обнаружение неисправностей </p></td><td valign="top" class="td6"><p id="P03A80014" class="formattext">Методы и разработки дают гарантию, что разработанное программное обеспечение будет вести себя безопасно в присутствии ошибок<br/></p></td></tr><tr><td valign="top" class="td4"><p id="P03A80015" class="formattext">4.7 </p></td><td valign="top" class="td5"><p id="P03A80016" class="formattext">Отсутствие отказов по общей причине </p></td><td valign="top" class="td6"><p id="P03A80017" class="formattext">Методы и проекты идентифицируют виды отказа по общей причине и обеспечивают эффективные средства предостережения от отказов программного обеспечения<br/></p></td></tr></table></div><p id="P03A9" class="formattext topleveltext indenttext" align="justify"><br/><br/></p><p id="P03A9_1" class="formattext topleveltext" align="justify">Таблица F.5 - Проектирование и разработка программного обеспечения: тестирование и интеграция программных модулей (см. МЭК 61508-3, пункты 7.4.7, 7.4.8 и таблица С.5)<br/></p><p id="X2276"></p><div element-type="table" class="table-container" id="X2277"><style type="text/css">#P03AA .td1 {width: 3.85em}#P03AA .td2 {width: 15.40em}#P03AA .td3 {width: 28.49em}#P03AA .td4 {width: 3.85em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }#P03AA .td5 {width: 15.40em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }#P03AA .td6 {width: 28.49em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }</style><table id="P03AA" class="wideTable"><tr height="1"><td class="td1"></td><td class="td2"></td><td class="td3"></td></tr><tr><td valign="top" class="td4"><p id="P03AA0000" class="formattext" align="center"></p></td><td valign="top" class="td5"><p id="P03AA0001" class="formattext" align="center">Свойство<br/></p></td><td valign="top" class="td6"><p id="P03AA0002" class="formattext" align="center">Определение </p></td></tr><tr><td valign="top" class="td4"><p id="P03AA0003" class="formattext">5.1 </p></td><td valign="top" class="td5"><p id="P03AA0004" class="formattext">Полнота тестирования и интеграции в соответствии со спецификациями проекта программного обеспечения </p></td><td valign="top" class="td6"><p id="P03AA0005" class="formattext">Тестирование программного обеспечения исследует поведение программного обеспечения с достаточной полнотой, чтобы гарантировать, что все требования спецификации проектирования программного обеспечения были удовлетворены<br/></p></td></tr><tr><td valign="top" class="td4"><p id="P03AA0006" class="formattext">5.2 </p></td><td valign="top" class="td5"><p id="P03AA0007" class="formattext">Корректность тестирования и интеграции в соответствии со спецификациями проекта программного обеспечения (успешное выполнение)<br/></p></td><td valign="top" class="td6"><p id="P03AA0008" class="formattext">Если задача тестирования модуля завершена, то существует конкретное доказательство, позволяющее утверждать, что требования к системе безопасности были удовлетворены </p></td></tr><tr><td valign="top" class="td4"><p id="P03AA0009" class="formattext">5.3 </p></td><td valign="top" class="td5"><p id="P03AA000A" class="formattext">Воспроизводимость </p></td><td valign="top" class="td6"><p id="P03AA000B" class="formattext">К согласованным результатам приводит повторение отдельных оценок, выполняемых как часть тестирования и интеграции модуля<br/></p></td></tr><tr><td valign="top" class="td4"><p id="P03AA000C" class="formattext">5.4 </p></td><td valign="top" class="td5"><p id="P03AA000D" class="formattext">Точно определенная тестируемая конфигурация </p></td><td valign="top" class="td6"><p id="P03AA000E" class="formattext">Для надлежащих версий элементов и программного обеспечения выполняют тестирование и интеграцию модуля, полученный требуемый результат связывают с конкретной конфигурацией &quot;как - построено&quot; программного обеспечения<br/></p></td></tr></table></div><p id="P03AB" class="formattext topleveltext indenttext" align="justify"><br/><br/></p><p id="P03AB_1" class="formattext topleveltext" align="justify">Таблица F.6 - Интеграция программируемых электронных устройств (программное обеспечение и аппаратные средства) (см. МЭК 61508-3, подраздел 7.5 и таблица С.6)<br/></p><p id="X2280"></p><div element-type="table" class="table-container" id="X2281"><style type="text/css">#P03AC .td1 {width: 3.85em}#P03AC .td2 {width: 15.40em}#P03AC .td3 {width: 28.49em}#P03AC .td4 {width: 3.85em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }#P03AC .td5 {width: 15.40em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }#P03AC .td6 {width: 28.49em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }</style><table id="P03AC" class="wideTable"><tr height="1"><td class="td1"></td><td class="td2"></td><td class="td3"></td></tr><tr><td valign="top" class="td4"><p id="P03AC0000" class="formattext empty_line" align="justify"></p></td><td valign="top" class="td5"><p id="P03AC0001" class="formattext" align="center">Свойство<br/></p></td><td valign="top" class="td6"><p id="P03AC0002" class="formattext" align="center">Определение </p></td></tr><tr><td valign="top" class="td4"><p id="P03AC0003" class="formattext" align="justify">6.1 <br/><br/></p></td><td valign="top" class="td5"><p id="P03AC0004" class="formattext">Полнота интеграции в соответствии со спецификациями проекта </p></td><td valign="top" class="td6"><p id="P03AC0005" class="formattext">Интеграция обеспечивает соответствующую глубину и охват элементов системы, чтобы продемонстрировать, что система может выполнить функции, для которых она предназначена, и не выполняет непредусмотренные функции при всех возможных условиях эксплуатации и при отказе системы. Интеграция включает принципы, используемые для проверки, целевые уровни проекта и аспекты интеграции (например проверку полноты взаимодействия между модулями)<br/></p></td></tr><tr><td valign="top" class="td4"><p id="P03AC0006" class="formattext" align="justify">6.2 <br/><br/></p></td><td valign="top" class="td5"><p id="P03AC0007" class="formattext">Корректность интеграции в соответствии со спецификациями проекта (успешное выполнение)</p></td><td valign="top" class="td6"><p id="P03AC0008" class="formattext">Интеграция основана на корректных предположениях.<br/><br/>Например, правильность ожидаемых результатов, рассматриваемых условий использования, а также репрезентативность тестовых сред.<br/><br/>Если задача интеграции завершена, то существует конкретное доказательство, позволяющее утверждать, что требования к безопасности были удовлетворены<br/></p></td></tr><tr><td valign="top" class="td4"><p id="P03AC0009" class="formattext" align="justify">6.3 <br/><br/></p></td><td valign="top" class="td5"><p id="P03AC000A" class="formattext">Воспроизводимость </p></td><td valign="top" class="td6"><p id="P03AC000B" class="formattext">К согласованным результатам приводит повторение отдельных оценок, выполняемых, как часть интеграции модуля<br/></p></td></tr><tr><td valign="top" class="td4"><p id="P03AC000C" class="formattext" align="justify">6.4 <br/><br/></p></td><td valign="top" class="td5"><p id="P03AC000D" class="formattext">Точно определенная конфигурация интеграции </p></td><td valign="top" class="td6"><p id="P03AC000E" class="formattext">Интеграция дает соответствующую гарантию, что она была эффективно применена в соответствии с документами к правильной версии элементов и программного обеспечения, а полученный требуемый результат связывают с конкретной конфигурацией &quot;как - построено&quot; программного обеспечения<br/></p></td></tr></table></div><p id="P03AD" class="formattext topleveltext indenttext" align="justify"><br/><br/></p><p id="P03AD_1" class="formattext topleveltext" align="justify">Таблица F.7 - Подтверждение соответствия для аспектов программного обеспечения системы безопасности (см. МЭК 61508-3, подраздел 7.7 и таблица С.7)<br/></p><p id="X2284"></p><div element-type="table" class="table-container" id="X2285"><style type="text/css">#P03AE .td1 {width: 3.85em}#P03AE .td2 {width: 15.40em}#P03AE .td3 {width: 28.49em}#P03AE .td4 {width: 3.85em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }#P03AE .td5 {width: 15.40em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }#P03AE .td6 {width: 28.49em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }</style><table id="P03AE" class="wideTable"><tr height="1"><td class="td1"></td><td class="td2"></td><td class="td3"></td></tr><tr><td valign="top" class="td4"><p id="P03AE0000" class="formattext empty_line" align="justify"></p></td><td valign="top" class="td5"><p id="P03AE0001" class="formattext" align="center">Свойство<br/></p></td><td valign="top" class="td6"><p id="P03AE0002" class="formattext" align="center">Определение </p></td></tr><tr><td valign="top" class="td4"><p id="P03AE0003" class="formattext" align="justify">7.1 <br/><br/></p></td><td valign="top" class="td5"><p id="P03AE0004" class="formattext">Полнота подтверждения соответствия в соответствии со спецификацией проекта программного обеспечения<br/></p></td><td valign="top" class="td6"><p id="P03AE0005" class="formattext">Подтверждение соответствия программного обеспечения охватывает все требования спецификации проектирования программного обеспечения </p></td></tr><tr><td valign="top" class="td4"><p id="P03AE0006" class="formattext" align="justify">7.2 <br/><br/></p></td><td valign="top" class="td5"><p id="P03AE0007" class="formattext">Корректность подтверждения соответствия в соответствии со спецификацией проекта программного обеспечения (успешное выполнение)<br/></p></td><td valign="top" class="td6"><p id="P03AE0008" class="formattext">Если задача подтверждения соответствия программного обеспечения выполнена, то существует конкретное доказательство, позволяющее утверждать, что требования к безопасности были удовлетворены </p></td></tr><tr><td valign="top" class="td4"><p id="P03AE0009" class="formattext" align="justify">7.3 <br/><br/></p></td><td valign="top" class="td5"><p id="P03AE000A" class="formattext">Воспроизводимость </p></td><td valign="top" class="td6"><p id="P03AE000B" class="formattext">К согласованным результатам приводит повторение отдельных оценок, выполняемых как часть подтверждения соответствия программного обеспечения<br/></p></td></tr><tr><td valign="top" class="td4"><p id="P03AE000C" class="formattext" align="justify">7.4 <br/><br/></p></td><td valign="top" class="td5"><p id="P03AE000D" class="formattext">Подтверждение соответствия точно определенной конфигурации </p></td><td valign="top" class="td6"><p id="P03AE000E" class="formattext">Четкое и краткое определение:<br/><br/>- системы,<br/><br/>- требований,<br/><br/>- окружающей среды<br/></p></td></tr></table></div><p id="P03AF" class="formattext topleveltext indenttext" align="justify"><br/><br/></p><p id="P03AF_1" class="formattext topleveltext" align="justify">Таблица F.8 - Модификация программного обеспечения (см. МЭК 61508-3, подраздел 7.8 и таблица С.8)<br/></p><p id="X2288"></p><div element-type="table" class="table-container" id="X2289"><style type="text/css">#P03B0 .td1 {width: 3.85em}#P03B0 .td2 {width: 15.40em}#P03B0 .td3 {width: 28.49em}#P03B0 .td4 {width: 3.85em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }#P03B0 .td5 {width: 15.40em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }#P03B0 .td6 {width: 28.49em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }</style><table id="P03B0" class="wideTable"><tr height="1"><td class="td1"></td><td class="td2"></td><td class="td3"></td></tr><tr><td valign="top" class="td4"><p id="P03B00000" class="formattext empty_line" align="justify"></p></td><td valign="top" class="td5"><p id="P03B00001" class="formattext" align="center">Свойство<br/></p></td><td valign="top" class="td6"><p id="P03B00002" class="formattext" align="center">Определение </p></td></tr><tr><td valign="top" class="td4"><p id="P03B00003" class="formattext" align="justify">8.1 <br/><br/></p></td><td valign="top" class="td5"><p id="P03B00004" class="formattext">Полнота модификации в соответствии с требованиями к модификации </p></td><td valign="top" class="td6"><p id="P03B00005" class="formattext">Модификация была должным образом одобрена авторизованным персоналом, с соответствующим пониманием ее функционала, последствий для системы безопасности, а также технических и эксплуатационных последствий<br/></p></td></tr><tr><td valign="top" class="td4"><p id="P03B00006" class="formattext" align="justify">8.2 <br/><br/></p></td><td valign="top" class="td5"><p id="P03B00007" class="formattext">Корректность модификации в соответствии с требованиями к модификации<br/></p></td><td valign="top" class="td6"><p id="P03B00008" class="formattext">Модификация достигает своих заданных целей </p></td></tr><tr><td valign="top" class="td4"><p id="P03B00009" class="formattext" align="justify">8.3 <br/><br/></p></td><td valign="top" class="td5"><p id="P03B0000A" class="formattext">Отсутствие собственных ошибок проекта </p></td><td valign="top" class="td6"><p id="P03B0000B" class="formattext">Модификация не вносит новые систематические ошибки. <br/><br/>Примеры: деление на ноль, выход индексов или указателей за границы своих значений, использование неинициализированных переменных<br/></p></td></tr><tr><td valign="top" class="td4"><p id="P03B0000C" class="formattext" align="justify">8.4 <br/><br/></p></td><td valign="top" class="td5"><p id="P03B0000D" class="formattext">Предотвращение нежелательного поведения </p></td><td valign="top" class="td6"><p id="P03B0000E" class="formattext">Модификация не вносит какое-либо поведение, которое, согласно ограничениям, установленным в спецификации требований к программному обеспечению системы безопасности, должно быть предотвращено<br/></p></td></tr><tr><td valign="top" class="td4"><p id="P03B0000F" class="formattext" align="justify">8.5 <br/><br/></p></td><td valign="top" class="td5"><p id="P03B00010" class="formattext">Верифицируемость и тестируемость проекта </p></td><td valign="top" class="td6"><p id="P03B00011" class="formattext">Проект программного обеспечения является таким, что влияние модификации полностью и всесторонне оценивается<br/></p></td></tr><tr><td valign="top" class="td4"><p id="P03B00012" class="formattext" align="justify">8.6 <br/><br/></p></td><td valign="top" class="td5"><p id="P03B00013" class="formattext">Регрессионное тестирование и охват проверкой </p></td><td valign="top" class="td6"><p id="P03B00014" class="formattext">Проект программного обеспечения является таким, что эффективное и полное регрессионное тестирование позволяет продемонстрировать, что программное обеспечение после модификации продолжает удовлетворять спецификации требований к программному обеспечению системы безопасности<br/></p></td></tr></table></div><p id="P03B1" class="formattext topleveltext indenttext" align="justify"><br/><br/></p><p id="P03B1_1" class="formattext topleveltext" align="justify">Таблица F.9 - Верификация программного обеспечения системы (см. МЭК 61508-3, подраздел 7.9 и таблица С.9)<br/></p><p><img class="base64 sign" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZIAAAARCAMAAADAD9oKAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MTg4Q0U3ODQ0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MTg4Q0U3ODU0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoxODhDRTc4MjRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDoxODhDRTc4MzRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pos3t18AAAAzUExURfX19SQkJOrq6oeHh7y8vD8/P9/f31RUVMjIyLCwsHh4eJaWlmdnZ6Ojo9TU1AAAAP////kimdMAAAWSSURBVHja7FiJcuQoDAVzGcz1/1+7TwLRuDs9mZ2karZqQ1ViGz90PUngVv1nfMOo9fg2WarnNkf9FGxMHdDkf1jo3bXBg7o0YhIkfrXV0npvBfd48y94HQtV97XWZvBPfbpG29oikGfQ6oeRs4WLb4K2CGNq5wsltpX6B5TQYEa5/u6h9rdn31QdtXS0iKX1WZ360/o9Pl/3NmVq/ahk/cfwZ0X+bSL6T01Kxmq6Fj0MSDNPj+atGzF1+Y17z9IZMRfulHiH+ivMFvE7nm2ffQ26Q5+U0AKLatWUGFm63kU3SJycuwqNLgNJ1ONf6crorUNyEySMStQLlegNgSuSmiT5agizm0YyZwPNbEXLM64y2X0YcGgdN3ytU9FaLDCecHbCyFWVh0kjMvBEHK+rvx/tVIgOWSoTcZrRa+aVJxeOuLc5nG8Oj2cjCzdKDm1Uj9BCSFeO7sKBgKCxRWpXKNAiFtV2njBAGeqm2QBQaZKCjjDCA+vqnZJD802sAzu9q4EwRtde4djUG4kJeFObpsag4cXNNJKJejRY7pVO9EJiQf2XRJLlBEcW1Toooc48FcniBeN2nOALwwzMDXhDJv2CkoKENkS/NKzu0p74rRyOk0vcezgs0iXQhLDixE4J6YAALgUqoEq6VKpih0KosOuUUihxM+eGo6KIA3DEaTI8oJS7UZIybnhmOVX1wCiqLJSYmnr52WjShadTA7Obtsyl2lP22PquxG9kJ1VbSWN2gEXRfF4wlnri36xnTJBYC+R7ShyX17HNDIcXJSg8ddMqDi/p0+HOCGNfKclwPmdHBsVgp9mbHaemuwBMwtvmCK2pQqtwdpakiZIQg7pTAitwc+m6OVWyWFhnzQy9aMrcDZASSAJjgNlMo5R4UIJ1xbhnSsYr+p/LRslS1FfshQFIpb4v06WRvgBky4VfseOmPqy3zaKiZqp/SEmpOqhdqzi8pE+H6/2wu1PiCg9AkvOvlJi0r2ZbS7FooaMpdo8WYy6ixPFRZKcEE9Iz115irhdKWC/y1VquyIpWqU+i5GEapcRWJaGFFN9T4s7foyRQdqmNkqHvGJmn82AtUzed1s9vB63U6jj6ulOCnnbtWsXhJX06/J6S5LbDmKYuy/W11rgbobKpdRvmtNFKGpfS142SqEcL8CE99hIKV+ZmbDnr/NQL2Slx46wxoDSB2U27NS77eN4oGZaj91G6PChZiubzgo2+i9AKJbEd/S5yKA5ZAnCwLL6IcfYe2aHWb1rF4SV9OjwQ9XylZGwwORFSIeLUakYnHEVAgh6U0D7elY49C1OZNrM09pIC8EaJtnyjdHiIqE4qiY+K2YleProNrUcLhk8Lm2k3SgrF/KVKhuUQVUzfKFmK5vOCvVBytMSb69NeolwS66954oXTvnF2en3b3XmlIo3LPXF4SReHXZ5b3zMlCKcpAVse9z38XXh2kvo9htvuppy+LqeP0LgvBo/IpIJ+b/kQrGUDaM4XPvlBR9IPVq3mlkDldKIJ5k0vnGyzNh2myYvdtJ0S3wLtJeZOybT8uEabQ3kPSkSRUDRhs3HpI2uhKwKZKC8elADStJcASJOg7IcrF9BZvVBCPVi0bg6LdHF4IOqNkvmNaVM2iMWBHqoKLD9TvghAE92ecjdXxkxveb8tHElMxB7PblETZ1G2zDe1eNbBMkVEGdsDl4k3d709uAk86RPY3k2b5lZOIzbxnN2c5xk+LM9jv8PZaIBFkSwWBw9CRWwlLJ3fVZPTuYkUyLT+KPP7VBGAQmGev5tHTGMUrbvDU/pyeNn1oOQLQ74d6yeA51Hyfnn6FWDtmF8bueyXvzx+5XB/3d6/4rbfL+8Bz8Ne++X+s4z5pp/QLrtf/vJ47/B3U/L9Q/Fp4P87fn7R/c+NfwQYAFx9eFOvgdoSAAAAAElFTkSuQmCC"/></p><style>.base64.sign {display: none;}</style><p id="X2292"></p><div element-type="table" class="table-container" id="X2293"><style type="text/css">#P03B2 .td1 {width: 3.85em}#P03B2 .td2 {width: 15.40em}#P03B2 .td3 {width: 28.49em}#P03B2 .td4 {width: 3.85em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }#P03B2 .td5 {width: 15.40em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }#P03B2 .td6 {width: 28.49em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }</style><table id="P03B2" class="wideTable"><tr height="1"><td class="td1"></td><td class="td2"></td><td class="td3"></td></tr><tr><td valign="top" class="td4"><p id="P03B20000" class="formattext empty_line" align="justify"></p></td><td valign="top" class="td5"><p id="P03B20001" class="formattext" align="center">Свойство<br/></p></td><td valign="top" class="td6"><p id="P03B20002" class="formattext" align="center">Определение </p></td></tr><tr><td valign="top" class="td4"><p id="P03B20003" class="formattext" align="justify">9.1 <br/><br/></p></td><td valign="top" class="td5"><p id="P03B20004" class="formattext">Полнота верификации в соответствии с предыдущей стадией </p></td><td valign="top" class="td6"><p id="P03B20005" class="formattext">Верификация способна установить, что программное обеспечение удовлетворяет всем соответствующим требованиям спецификации требований к программному обеспечению системы безопасности<br/></p></td></tr><tr><td valign="top" class="td4"><p id="P03B20006" class="formattext" align="justify">9.2 <br/><br/></p></td><td valign="top" class="td5"><p id="P03B20007" class="formattext">Корректность верификации в соответствии с предыдущей стадией (успешное выполнение)</p></td><td valign="top" class="td6"><p id="P03B20008" class="formattext">Если задача верификации программного обеспечения завершена, то существует конкретное доказательство, позволяющее утверждать, что требования к системе безопасности были удовлетворены<br/></p></td></tr><tr><td valign="top" class="td4"><p id="P03B20009" class="formattext" align="justify">9.3 <br/><br/></p></td><td valign="top" class="td5"><p id="P03B2000A" class="formattext">Воспроизводимость </p></td><td valign="top" class="td6"><p id="P03B2000B" class="formattext">К согласованным результатам приводит повторение отдельных оценок, выполняемых как часть верификации<br/></p></td></tr><tr><td valign="top" class="td4"><p id="P03B2000C" class="formattext" align="justify">9.4 <br/><br/></p></td><td valign="top" class="td5"><p id="P03B2000D" class="formattext">Верификация точно определенной конфигурации </p></td><td valign="top" class="td6"><p id="P03B2000E" class="formattext">Для надлежащих версий элементов и программного обеспечения выполняют верификацию, полученный требуемый результат связывают с конкретной конфигурацией &quot;как - построено&quot; программного обеспечения<br/></p></td></tr></table></div><p id="P03B3" class="formattext topleveltext indenttext" align="justify"><br/><br/></p><p id="P03B3_1" class="formattext topleveltext" align="justify">Таблица F.10 - Оценка функциональной безопасности (см. МЭК 61508-3, раздел 8 и таблица С.10)<br/></p><p id="X2296"></p><div element-type="table" class="table-container" id="X2297"><style type="text/css">#P03B4 .td1 {width: 3.85em}#P03B4 .td2 {width: 15.40em}#P03B4 .td3 {width: 28.49em}#P03B4 .td4 {width: 3.85em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }#P03B4 .td5 {width: 15.40em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }#P03B4 .td6 {width: 28.49em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }</style><table id="P03B4" class="wideTable"><tr height="1"><td class="td1"></td><td class="td2"></td><td class="td3"></td></tr><tr><td valign="top" class="td4"><p id="P03B40000" class="formattext empty_line" align="justify"></p></td><td valign="top" class="td5"><p id="P03B40001" class="formattext" align="center">Свойство<br/></p></td><td valign="top" class="td6"><p id="P03B40002" class="formattext" align="center">Определение </p></td></tr><tr><td valign="top" class="td4"><p id="P03B40003" class="formattext" align="justify">10.1 <br/><br/></p></td><td valign="top" class="td5"><p id="P03B40004" class="formattext">Полнота оценки функциональной безопасности в соответствии с настоящим стандартом </p></td><td valign="top" class="td6"><p id="P03B40005" class="formattext">Оценка функциональной безопасности программного обеспечения формирует ясное утверждение о степени найденного соответствия, сделанных обоснованиях, мерах по устранению недостатков с рекомендуемыми сроками их устранения, полученные выводы и рекомендации по их принятию, квалифицированному принятию, или отклонению с указанием любых временных ограничений для этих рекомендаций<br/></p></td></tr><tr><td valign="top" class="td4"><p id="P03B40006" class="formattext" align="justify">10.2 <br/><br/></p></td><td valign="top" class="td5"><p id="P03B40007" class="formattext">Корректность оценки функциональной безопасности в соответствии с проектными спецификациями (успешное выполнение)<br/></p></td><td valign="top" class="td6"><p id="P03B40008" class="formattext">Задача оценки функциональной безопасности программного обеспечения завершена, и существует конкретное доказательство, позволяющее утверждать, что требования к системе безопасности были удовлетворены </p></td></tr><tr><td valign="top" class="td4"><p id="P03B40009" class="formattext" align="justify">10.3 <br/><br/></p></td><td valign="top" class="td5"><p id="P03B4000A" class="formattext">Доступное для анализа решение всех выявленных проблем </p></td><td valign="top" class="td6"><p id="P03B4000B" class="formattext">Существует ясное утверждение о том, в каком объеме были рассмотрены проблемы, возникающие во время оценки функциональной безопасности программного обеспечения.<br/></p></td></tr><tr><td valign="top" class="td4"><p id="P03B4000C" class="formattext" align="justify">10.4 <br/><br/></p></td><td valign="top" class="td5"><p id="P03B4000D" class="formattext">Возможность модификации оценки функциональной безопасности после изменения проекта без необходимости проведения серьезной переработки оценки </p></td><td valign="top" class="td6"><p id="P03B4000E" class="formattext">Результаты оценки функциональной безопасности программного обеспечения могут быть перерассчитаны, причем при повторной оценке функциональной безопасности частей программного обеспечения после их изменения не выполняется повторная оценка функциональной безопасности всего программного обеспечения, она лишь корректируется с учетом измененных частей<br/></p></td></tr><tr><td valign="top" class="td4"><p id="P03B4000F" class="formattext" align="justify">10.5 <br/><br/></p></td><td valign="top" class="td5"><p id="P03B40010" class="formattext">Воспроизводимость </p></td><td valign="top" class="td6"><p id="P03B40011" class="formattext">Оценка функциональной безопасности выполняется как согласованный, запланированный и открытый процесс с конкретными персоналом и документами, который реализует рассмотрение основания для выполнения оценок и решения, которые выполняют все те, на которых влияют эти решения, включая поставщиков системы, пользователей, специалистов по обслуживанию и руководство<br/><br/>Оценка функциональной безопасности позволяет независимому компетентному персоналу повторять отдельные оценки, выполненные как часть всей оценки<br/></p></td></tr><tr><td valign="top" class="td4"><p id="P03B40012" class="formattext" align="justify">10.6 <br/><br/></p></td><td valign="top" class="td5"><p id="P03B40013" class="formattext">Своевременность </p></td><td valign="top" class="td6"><p id="P03B40014" class="formattext">Оценка функциональной безопасности выполняется с соответствующей частотой, связанной со стадиями жизненного цикла программного обеспечения системы безопасности и по крайней мере до определения существующих опасностей. Также она обеспечивает своевременное создание отчетов о несоответствиях<br/><br/>Результаты тестов, проверок, исследований и т.д. фактически доступны, если они требуются в качестве входной информации для формирования решения об оценке<br/></p></td></tr><tr><td valign="top" class="td4"><p id="P03B40015" class="formattext" align="justify">10.7 <br/><br/></p></td><td valign="top" class="td5"><p id="P03B40016" class="formattext">Точно определенная конфигурация </p></td><td valign="top" class="td6"><p id="P03B40017" class="formattext">Результаты оценки функциональной безопасности программного обеспечения связывают с конкретной конфигурацией системы, для которой результаты оценки функциональной безопасности должны быть обоснованы<br/></p></td></tr></table></div><p id="P03B5" class="formattext topleveltext centertext" align="center"><br/></p><h2 id="P03B8" class="formattext topleveltext centertext" align="center" title-level="2">Приложение G<br/>(справочное)<br/></h2><p id="P03B9" class="headertext topleveltext centertext" align="center">Руководство по разработке связанного с безопасностью объектно-ориентированного программного обеспечения </p><p id="P03BA" class="formattext topleveltext indenttext" align="justify"><br/></p><p id="P03BA_1" class="formattext topleveltext indenttext" align="justify">Все рекомендации настоящего стандарта по проектированию программного обеспечения применяются к объектно-ориентированному программному обеспечению. Поскольку объектно-ориентированный подход представляет информацию в отличие от процедурных или функциональных подходов по-другому, то далее даны рекомендации, для конкретного рассмотрения которых необходимо:<br/><br/></p><p id="P03BA_2" class="formattext topleveltext indenttext" align="justify">- понимание иерархий классов и идентификации функции(й) программного обеспечения, которые будут выполняться при вызове заданного метода (включая существующую библиотеку классов, если она используется);<br/><br/></p><p id="P03BA_3" class="formattext topleveltext indenttext" align="justify">- структурное тестирование (МЭК 61508-3, таблица В.2 и МЭК 61508-7, подраздел С.5.8).<br/><br/></p><p id="P03BA_4" class="formattext topleveltext indenttext" align="justify">Таблицы G.1 и G.2 содержат справочные руководящие указания по использованию объектно-ориентированного программного обеспечения, которые дополняют более общие нормативные руководящие указания, представленные в МЭК 61508-3, таблицы 2 и 4.<br/><br/><br/></p><p id="P03BA_5" class="formattext topleveltext" align="justify">Таблица G.1 - Архитектура объектно-ориентированного программного обеспечения<br/></p><p id="X2307"></p><div element-type="table" class="table-container" id="X2308"><style type="text/css">#P03BB .td1 {width: 3.85em}#P03BB .td2 {width: 19.25em}#P03BB .td3 {width: 6.93em}#P03BB .td4 {width: 4.62em}#P03BB .td5 {width: 3.85em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }#P03BB .td6 {width: 19.25em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }#P03BB .td7 {width: 6.93em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }#P03BB .td8 {width: 4.62em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }#P03BB .td9 {width: 47.74em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }</style><table id="P03BB" class="wideTable"><tr height="1"><td class="td1"></td><td class="td2"></td><td class="td3"></td><td class="td4"></td><td class="td1"></td><td class="td4"></td><td class="td4"></td></tr><tr><td valign="top" class="td5"><p id="P03BB0000" class="formattext" align="center"></p></td><td valign="top" class="td6"><p id="P03BB0001" class="formattext" align="center">Рекомендации<br/><br/></p></td><td valign="top" class="td7"><p id="P03BB0002" class="formattext" align="center">Подроб-<br/>ности </p></td><td valign="top" class="td8"><p id="P03BB0003" class="formattext" align="center">УПБ1 </p></td><td valign="top" class="td5"><p id="P03BB0004" class="formattext" align="center">УПБ2 </p></td><td valign="top" class="td8"><p id="P03BB0005" class="formattext" align="center">УПБ3 </p></td><td valign="top" class="td8"><p id="P03BB0006" class="formattext" align="center">УПБ4 </p></td></tr><tr><td valign="top" class="td5"><p id="P03BB0007" class="formattext" align="center">G1.1 </p></td><td valign="top" class="td6"><p id="P03BB0008" class="formattext">Прослеживаемость понятия прикладной области с классами архитектуры<br/></p></td><td valign="top" class="td7"><p id="P03BB0009" class="formattext" align="center">Примечание 1 </p></td><td valign="top" class="td8"><p id="P03BB000A" class="formattext" align="center">R </p></td><td valign="top" class="td5"><p id="P03BB000B" class="formattext" align="center">HR </p></td><td valign="top" class="td8"><p id="P03BB000C" class="formattext" align="center">HR </p></td><td valign="top" class="td8"><p id="P03BB000D" class="formattext" align="center">HR </p></td></tr><tr><td valign="top" class="td5"><p id="P03BB000E" class="formattext" align="center">G1.2 </p></td><td valign="top" class="td6"><p id="P03BB000F" class="formattext">Использование подходящих фреймов, общеиспользуемых комбинаций классов и шаблонов проектирования<br/><br/>Примечание - При использовании существующих фреймов и шаблонов проектирования к ним применяются требования, как и к предварительно разработанному программному обеспечению<br/><br/></p></td><td valign="top" class="td7"><p id="P03BB0010" class="formattext" align="center">Примечание 2 </p></td><td valign="top" class="td8"><p id="P03BB0011" class="formattext" align="center">R </p></td><td valign="top" class="td5"><p id="P03BB0012" class="formattext" align="center">HR </p></td><td valign="top" class="td8"><p id="P03BB0013" class="formattext" align="center">HR </p></td><td valign="top" class="td8"><p id="P03BB0014" class="formattext" align="center">HR </p></td></tr><tr><td colspan="7" valign="top" class="td9"><p id="P03BB0015" class="formattext indenttext" align="justify">Примечания:<br/><br/></p><p id="P03BB0015_1" class="formattext indenttext" align="justify">1 Прослеживаемость прикладной области с архитектурой класса менее важна.<br/><br/></p><p id="P03BB0015_2" class="formattext indenttext" align="justify">2 <b><i>Примеры<br/>     <br/>     1 Для некоторой части, предназначенной для проекта, связанного с безопасностью, может существовать фрейм из проекта, не связанного с безопасностью, который успешно решает подобную задачу, и это хорошо известно участникам проекта. В этом случае рекомендуется использовать такой фрейм.<br/>     <br/>     2 Могут понадобиться различные алгоритмы для решения тесно связанных подзадач проекта, связанного с безопасностью. Поэтому может быть выбран шаблон стратегии доступа к алгоритмам.<br/>     <br/>     3 Часть проекта, связанного с безопасностью, может состоять из выдачи надлежащих предупреждений внутренним и внешним заинтересованным сторонам. Для организации этих предупреждений может быть выбран шаблон наблюдателя. Это требование не применяется для библиотек.</i></b><br/><br/></p><p id="P03BB0015_3" class="formattext indenttext" align="justify">3 Как правило, абстрактный базовый класс обеспечивает доступ к производным конкретным классам.<br/><br/></p></td></tr></table></div><p id="P03BC" class="formattext topleveltext indenttext" align="justify"><br/><br/></p><p id="P03BC_1" class="formattext topleveltext" align="justify">Таблица G.2 - Объектно-ориентированный рабочий проект<br/></p><p id="X2311"></p><div element-type="table" class="table-container" id="X2312"><style type="text/css">#P03BD .td1 {width: 3.85em}#P03BD .td2 {width: 26.18em}#P03BD .td3 {width: 4.62em}#P03BD .td4 {width: 3.85em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }#P03BD .td5 {width: 26.18em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }#P03BD .td6 {width: 4.62em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }#P03BD .td7 {width: 47.74em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }</style><table id="P03BD" class="wideTable"><tr height="1"><td class="td1"></td><td class="td2"></td><td class="td3"></td><td class="td1"></td><td class="td3"></td><td class="td3"></td></tr><tr><td valign="top" class="td4"><p id="P03BD0000" class="formattext" align="center"></p></td><td valign="top" class="td5"><p id="P03BD0001" class="formattext" align="center">Рекомендации<br/><br/></p></td><td valign="top" class="td6"><p id="P03BD0002" class="formattext" align="center">УПБ1 </p></td><td valign="top" class="td4"><p id="P03BD0003" class="formattext" align="center">УПБ2 </p></td><td valign="top" class="td6"><p id="P03BD0004" class="formattext" align="center">УПБ3 </p></td><td valign="top" class="td6"><p id="P03BD0005" class="formattext" align="center">УПБ4 </p></td></tr><tr><td valign="top" class="td4"><p id="P03BD0006" class="formattext" align="center">G2.1 </p></td><td valign="top" class="td5"><p id="P03BD0007" class="formattext">Классы должны иметь только одну цель<br/></p></td><td valign="top" class="td6"><p id="P03BD0008" class="formattext" align="center">R </p></td><td valign="top" class="td4"><p id="P03BD0009" class="formattext" align="center">R </p></td><td valign="top" class="td6"><p id="P03BD000A" class="formattext" align="center">HR </p></td><td valign="top" class="td6"><p id="P03BD000B" class="formattext" align="center">HR </p></td></tr><tr><td valign="top" class="td4"><p id="P03BD000C" class="formattext" align="center">G2.2 </p></td><td valign="top" class="td5"><p id="P03BD000D" class="formattext">Наследование используется, только если производный класс является уточнением своего основного класса<br/></p></td><td valign="top" class="td6"><p id="P03BD000E" class="formattext" align="center">HR </p></td><td valign="top" class="td4"><p id="P03BD000F" class="formattext" align="center">HR </p></td><td valign="top" class="td6"><p id="P03BD0010" class="formattext" align="center">HR </p></td><td valign="top" class="td6"><p id="P03BD0011" class="formattext" align="center">HR </p></td></tr><tr><td valign="top" class="td4"><p id="P03BD0012" class="formattext" align="center">G2.3 </p></td><td valign="top" class="td5"><p id="P03BD0013" class="formattext">Глубина наследования ограничена стандартами кодирования<br/></p></td><td valign="top" class="td6"><p id="P03BD0014" class="formattext" align="center">R </p></td><td valign="top" class="td4"><p id="P03BD0015" class="formattext" align="center">R </p></td><td valign="top" class="td6"><p id="P03BD0016" class="formattext" align="center">HR </p></td><td valign="top" class="td6"><p id="P03BD0017" class="formattext" align="center">HR </p></td></tr><tr><td valign="top" class="td4"><p id="P03BD0018" class="formattext" align="center">G2.4 </p></td><td valign="top" class="td5"><p id="P03BD0019" class="formattext">Переопределение операций (методов) строго контролируется<br/></p></td><td valign="top" class="td6"><p id="P03BD001A" class="formattext" align="center">R </p></td><td valign="top" class="td4"><p id="P03BD001B" class="formattext" align="center">HR </p></td><td valign="top" class="td6"><p id="P03BD001C" class="formattext" align="center">HR </p></td><td valign="top" class="td6"><p id="P03BD001D" class="formattext" align="center">HR </p></td></tr><tr><td valign="top" class="td4"><p id="P03BD001E" class="formattext" align="center">G2.5 </p></td><td valign="top" class="td5"><p id="P03BD001F" class="formattext">Множественное наследование используется только для интерфейсных классов<br/></p></td><td valign="top" class="td6"><p id="P03BD0020" class="formattext" align="center">HR </p></td><td valign="top" class="td4"><p id="P03BD0021" class="formattext" align="center">HR </p></td><td valign="top" class="td6"><p id="P03BD0022" class="formattext" align="center">HR </p></td><td valign="top" class="td6"><p id="P03BD0023" class="formattext" align="center">HR </p></td></tr><tr><td valign="top" class="td4"><p id="P03BD0024" class="formattext" align="center">G2.6 </p></td><td valign="top" class="td5"><p id="P03BD0025" class="formattext">Наследование от неизвестных классов<br/></p></td><td valign="top" class="td6"><p id="P03BD0026" class="formattext" align="center">-</p></td><td valign="top" class="td4"><p id="P03BD0027" class="formattext" align="center">-</p></td><td valign="top" class="td6"><p id="P03BD0028" class="formattext" align="center">NR </p></td><td valign="top" class="td6"><p id="P03BD0029" class="formattext" align="center">NR </p></td></tr><tr><td valign="top" class="td4"><p id="P03BD002A" class="formattext" align="center">G2.7 </p></td><td valign="top" class="td5"><p id="P03BD002B" class="formattext">Подтверждение того, что повторно используемые объектно-ориентированные библиотеки отвечают рекомендациям данной таблицы<br/></p></td><td valign="top" class="td6"><p id="P03BD002C" class="formattext" align="center">HR </p></td><td valign="top" class="td4"><p id="P03BD002D" class="formattext" align="center">HR </p></td><td valign="top" class="td6"><p id="P03BD002E" class="formattext" align="center">HR </p></td><td valign="top" class="td6"><p id="P03BD002F" class="formattext" align="center">HR </p></td></tr><tr><td colspan="6" valign="top" class="td7"><p id="P03BD0030" class="formattext indenttext" align="justify">Примечания:<br/><br/></p><p id="P03BD0030_1" class="formattext indenttext" align="justify">1 Один класс характеризуется наличием одной ответственности - необходимо быть внимательным при описании тесно связанных данных и операций над этими данными.<br/><br/></p><p id="P03BD0030_2" class="formattext indenttext" align="justify">2 Необходимо внимательно следить за тем, чтобы не допустить циклических зависимостей между объектами.<br/><br/></p></td></tr></table></div><p id="P03BE" class="formattext topleveltext" align="justify">          <br/></p><p id="P03BE_1" class="formattext topleveltext indenttext" align="justify">Далее неоформально определены термины, использованные выше.<br/><br/><br/></p><p id="P03BE_2" class="formattext topleveltext" align="justify">Таблица G.3 - Некоторые объектно-ориентированные термины<br/></p><p id="X2316"></p><div element-type="table" class="table-container" id="X2317"><style type="text/css">#P03BF .td1 {width: 11.55em}#P03BF .td2 {width: 35.42em}#P03BF .td3 {width: 11.55em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }#P03BF .td4 {width: 35.42em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }</style><table id="P03BF" class="wideTable"><tr height="1"><td class="td1"></td><td class="td2"></td></tr><tr><td valign="top" class="td3"><p id="P03BF0000" class="formattext" align="center">Термин<br/></p></td><td valign="top" class="td4"><p id="P03BF0001" class="formattext" align="center">Неформальное определение </p></td></tr><tr><td valign="top" class="td3"><p id="P03BF0002" class="formattext">Основной класс </p></td><td valign="top" class="td4"><p id="P03BF0003" class="formattext">Класс, у которого есть производные классы. Основной класс иногда называют надклассом, или родительским классом<br/></p></td></tr><tr><td valign="top" class="td3"><p id="P03BF0004" class="formattext">Производный класс </p></td><td valign="top" class="td4"><p id="P03BF0005" class="formattext">Класс (совокупность атрибутов и операций), который наследовал атрибуты и/или операции от другого класса (основного класса). Производный класс иногда называют подклассом, или дочерним классом<br/></p></td></tr><tr><td valign="top" class="td3"><p id="P03BF0006" class="formattext">Фрэйм </p></td><td valign="top" class="td4"><p id="P03BF0007" class="formattext">Структура программы, как правило, предварительно разработана для заполнения данными конкретного применения<br/></p></td></tr><tr><td valign="top" class="td3"><p id="P03BF0008" class="formattext">Переопределение </p></td><td valign="top" class="td4"><p id="P03BF0009" class="formattext">Замена операции (метода, подпрограммы) другой операцией (методом, подпрограммой) с той же самой сигнатурой и иерархией наследования во время выполнения; свойство объектно-ориентированных языков или программ, реализующее полиморфизм<br/></p></td></tr><tr><td valign="top" class="td3"><p id="P03BF000A" class="formattext">Сигнатура операции </p></td><td valign="top" class="td4"><p id="P03BF000B" class="formattext">Имя операции (подпрограммы, метода) вместе с ее параметрами (аргументами) и их типы, иногда также их возвращаемые типы. Две сигнатуры равны, если у них одни и те же имена, число и типы параметров; в некоторых языках должны быть одинаковыми также возвращаемые типы<br/></p></td></tr></table></div><p id="P03C0" class="formattext topleveltext centertext" align="center"><br/></p><h2 id="P03C3" class="formattext topleveltext centertext" align="center" title-level="2">Приложение ДА<br/>(справочное)<br/></h2><p id="P03C4" class="headertext topleveltext centertext" align="center">Сведения о соответствии ссылочных международных стандартов национальным стандартам </p><p id="P03C5" class="formattext topleveltext indenttext" align="justify"><br/><br/></p><p id="P03C5_1" class="formattext topleveltext" align="justify">Таблица ДА.1<br/></p><p id="X2323"></p><div element-type="table" class="table-container" id="X2324"><style type="text/css">#P03C6 .td1 {width: 14.63em}#P03C6 .td2 {width: 6.16em}#P03C6 .td3 {width: 26.95em}#P03C6 .td4 {width: 14.63em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }#P03C6 .td5 {width: 6.16em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }#P03C6 .td6 {width: 26.95em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }#P03C6 .td7 {width: 47.74em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px solid black; border-bottom: 1px solid black; border-right: 1px solid black; }</style><table id="P03C6" class="wideTable"><tr height="1"><td class="td1"></td><td class="td2"></td><td class="td3"></td></tr><tr><td valign="top" class="td4"><p id="P03C60000" class="formattext" align="center">Обозначение ссылочного международного стандарта<br/></p></td><td valign="top" class="td5"><p id="P03C60001" class="formattext" align="center">Степень соответствия </p></td><td valign="top" class="td6"><p id="P03C60002" class="formattext" align="center">Обозначение и наименование соответствующего национального стандарта </p></td></tr><tr><td valign="top" class="td4"><p id="P03C60003" class="formattext">IEC Guide 104:1997<br/></p></td><td valign="top" class="td5"><p id="P03C60004" class="formattext" align="center">-</p></td><td valign="top" class="td6"><p id="P03C60005" class="formattext" align="center">*</p></td></tr><tr><td valign="top" class="td4"><p id="P03C60006" class="formattext">ISO/IEC Guide 51:1990 </p></td><td valign="top" class="td5"><p id="P03C60007" class="formattext" align="center">IDT </p></td><td valign="top" class="td6"><p id="P03C60008" class="formattext"><a class="document" href="/document/1200030314#7D20K3" nd="1200030314" context="7D20K3">ГОСТ Р 51898-2002</a> &quot;Аспекты безопасности. Правила включения в стандарты&quot;<br/></p></td></tr><tr><td valign="top" class="td4"><p id="P03C60009" class="formattext">IEC 61508-4:2010 </p></td><td valign="top" class="td5"><p id="P03C6000A" class="formattext" align="center">IDT </p></td><td valign="top" class="td6"><p id="P03C6000B" class="formattext"><a class="document" href="/document/1200102418#7D20K3" nd="1200102418" context="7D20K3">ГОСТ Р МЭК 61508-4-2012</a> &quot;Функциональная безопасность систем электрических, электронных, программируемых электронных, связанных с безопасностью. Часть 4. Термины и определения&quot;<br/></p></td></tr><tr><td colspan="3" valign="top" class="td7"><p id="P03C6000C" class="formattext indenttext" align="justify">* Соответствующий национальный стандарт отсутствует. До его принятия рекомендуется использовать перевод на русский язык данного международного стандарта.<br/><br/></p><p id="P03C6000C_1" class="formattext indenttext" align="justify">Примечание - В настоящей таблице использовано следующее условное обозначение степени соответствия стандартов:<br/><br/></p><p id="P03C6000C_2" class="formattext indenttext" align="justify">- IDT - идентичные стандарты.<br/><br/></p></td></tr></table></div><p id="P03C7" class="formattext topleveltext empty_line" align="justify"></p><p id="P03C8" class="headertext topleveltext centertext" align="center">     </p><h2 id="P03CB" class="headertext topleveltext centertext" align="center" title-level="2">Библиография </h2><p id="P03CC" class="formattext topleveltext empty_line" align="justify"></p><p id="X2329"></p><div element-type="table" class="table-container" id="X2330"><style type="text/css">#P03CD .td1 {width: 2.31em}#P03CD .td2 {width: 11.55em}#P03CD .td3 {width: 33.11em}#P03CD .td4 {width: 0.77em}#P03CD .td5 {width: 2.31em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px none black; border-left: 1px none black; border-bottom: 1px none black; border-right: 1px none black; }#P03CD .td6 {width: 11.55em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px none black; border-left: 1px none black; border-bottom: 1px none black; border-right: 1px none black; }#P03CD .td7 {width: 33.88em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px none black; border-left: 1px none black; border-bottom: 1px none black; border-right: 1px none black; }#P03CD .td8 {width: 47.74em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px none black; border-left: 1px none black; border-bottom: 1px none black; border-right: 1px none black; }#P03CD .td9 {width: 45.43em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px none black; border-left: 1px none black; border-bottom: 1px none black; border-right: 1px none black; }#P03CD .td10 {width: 33.11em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px none black; border-left: 1px none black; border-bottom: 1px none black; border-right: 1px none black; }</style><table id="P03CD" class="wideTable"><tr height="1"><td class="td1"></td><td class="td2"></td><td class="td3"></td><td class="td4"></td></tr><tr><td valign="top" class="td5"><p id="P03CD0000" class="formattext" align="justify">[1]<br/><br/></p></td><td valign="top" class="td6"><p id="P03CD0001" class="formattext" align="justify">IEC 61511 (all parts)<br/><br/></p></td><td colspan="2" valign="top" class="td7"><p id="P03CD0002" class="formattext" align="justify">Functional safety - Safety instrumented systems for the process industry sector<br/><br/></p></td></tr><tr><td valign="top" class="td5"><p id="P03CD0003" class="formattext" align="justify">[2]<br/><br/></p></td><td valign="top" class="td6"><p id="P03CD0004" class="formattext" align="justify">IEC 62061:2005 <br/><br/></p></td><td colspan="2" valign="top" class="td7"><p id="P03CD0005" class="formattext" align="justify">Safety of machinery - Functional safety of safety-related electrical, electronic and programmable electronic control systems<br/><br/></p></td></tr><tr><td valign="top" class="td5"><p id="P03CD0006" class="formattext" align="justify">[3]<br/><br/></p></td><td valign="top" class="td6"><p id="P03CD0007" class="formattext" align="justify">IEC 61800-5-2 <br/><br/></p></td><td colspan="2" valign="top" class="td7"><p id="P03CD0008" class="formattext" align="justify"> Electromagnetic compatibility (EMC) - Part 5: Installation and mitigation guidelines - Section 2: Earthing and cabling<br/><br/></p></td></tr><tr><td valign="top" class="td5"><p id="P03CD0009" class="formattext" align="justify">[4]<br/><br/></p></td><td valign="top" class="td6"><p id="P03CD000A" class="formattext" align="justify">IEC 60601 (all parts)<br/><br/></p></td><td colspan="2" valign="top" class="td7"><p id="P03CD000B" class="formattext" align="justify"> Medical electrical equipment<br/><br/></p></td></tr><tr><td valign="top" class="td5"><p id="P03CD000C" class="formattext" align="justify">[5]<br/><br/></p></td><td valign="top" class="td6"><p id="P03CD000D" class="formattext" align="justify">IEC 61326-3-1:2008<img class="base64" src="data:image;base64,R0lGODdhDQAXAIABAAAAAP///ywAAAAADQAXAAACIIyPqcvtcKAC0lR0b0w66P5NnIhx1OZ4aZe27gvHclIAADs=" width="13" height="23"/><br/><br/></p></td><td colspan="2" valign="top" class="td7"><p id="P03CD000E" class="formattext" align="justify">Electrical equipment for measurement, control and laboratory use - EMC requirements - Part 3-1: Immunity requirements for safety-related systems and for equipment intended to perform safety-related functions (functional safety) - General industrial applications <br/><br/></p></td></tr><tr><td colspan="4" valign="top" class="td8"><p id="P03CD000F" class="formattext" align="justify">________________<br/></p><p id="P03CD000F_1" class="formattext indenttext" align="justify"><img class="base64" src="data:image;base64,R0lGODdhDQAXAIABAAAAAP///ywAAAAADQAXAAACIIyPqcvtcKAC0lR0b0w66P5NnIhx1OZ4aZe27gvHclIAADs=" width="13" height="23"/> Заменен на IEC 61326-3-1:2017.</p><p id="P03CD0010" class="formattext"></p><p id="P03CD0011" class="formattext"></p></td></tr><tr><td valign="top" class="td5"><p id="P03CD0012" class="formattext" align="justify">[6]<br/><br/></p></td><td valign="top" class="td6"><p id="P03CD0013" class="formattext" align="justify">IEC 61326-3-2:2008<img class="base64" src="data:image;base64,R0lGODdhEAAXAIABAAAAAP///ywAAAAAEAAXAAACJYyPqcvtb4CMDRwbsMO63qd1SiciYkll3yhNKpRCKEzX9o3ndQEAOw==" width="16" height="23"/><br/><br/></p></td><td colspan="2" valign="top" class="td7"><p id="P03CD0014" class="formattext" align="justify">Electrical equipment for measurement, control and laboratory use - EMC requirements - Part 3-2: Immunity requirements for safety-related systems and for equipment intended to perform safety-related functions (functional safety) - Industrial applications with specified electromagnetic environment <br/><br/></p></td></tr><tr><td colspan="4" valign="top" class="td8"><p id="P03CD0015" class="formattext" align="justify">________________<br/></p><p id="P03CD0015_1" class="formattext indenttext" align="justify"><img class="base64" src="data:image;base64,R0lGODdhEAAXAIABAAAAAP///ywAAAAAEAAXAAACJYyPqcvtb4CMDRwbsMO63qd1SiciYkll3yhNKpRCKEzX9o3ndQEAOw==" width="16" height="23"/> Заменен на IEC 61326-3-2:2017.</p><p id="P03CD0016" class="formattext"></p><p id="P03CD0017" class="formattext"></p></td></tr><tr><td valign="top" class="td5"><p id="P03CD0018" class="formattext" align="justify">[7]<br/><br/></p></td><td valign="top" class="td6"><p id="P03CD0019" class="formattext" align="justify">IEC 61131-3:2003<img class="base64" src="data:image;base64,R0lGODdhDwAXAIABAAAAAP///ywAAAAADwAXAAACI4yPqcvtDOIBixobcJ1N5+p5iCZy5nZeEfmkXQvH8kzXdlAAADs=" width="15" height="23"/><br/><br/></p></td><td colspan="2" valign="top" class="td7"><p id="P03CD001A" class="formattext" align="justify">Programmable controllers - Part 3: Programming languages <br/><br/></p></td></tr><tr><td colspan="4" valign="top" class="td8"><p id="P03CD001B" class="formattext" align="justify">________________<br/></p><p id="P03CD001B_1" class="formattext indenttext" align="justify"><img class="base64" src="data:image;base64,R0lGODdhDwAXAIABAAAAAP///ywAAAAADwAXAAACI4yPqcvtDOIBixobcJ1N5+p5iCZy5nZeEfmkXQvH8kzXdlAAADs=" width="15" height="23"/> Заменен на IEC 61131-3:2013.</p><p id="P03CD001C" class="formattext"></p><p id="P03CD001D" class="formattext"></p></td></tr><tr><td valign="top" class="td5"><p id="P03CD001E" class="formattext" align="justify">[8]<br/><br/></p></td><td valign="top" class="td6"><p id="P03CD001F" class="formattext" align="justify">IEC 60812:2006<img class="base64" src="data:image;base64,R0lGODdhEAAXAIABAAAAAP///ywAAAAAEAAXAAACJIyPqcvtn0CQD1DK5HX64Ghgn0eGi4VuXNmo0PTC8UzX9o3HBQA7" width="16" height="23"/><br/><br/></p></td><td colspan="2" valign="top" class="td7"><p id="P03CD0020" class="formattext" align="justify"> Analysis techniques for system reliability - Procedure for failure mode and effects analysis (FMEA)<br/><br/></p></td></tr><tr><td colspan="4" valign="top" class="td8"><p id="P03CD0021" class="formattext" align="justify">________________<br/></p><p id="P03CD0021_1" class="formattext indenttext" align="justify"><img class="base64" src="data:image;base64,R0lGODdhEAAXAIABAAAAAP///ywAAAAAEAAXAAACJIyPqcvtn0CQD1DK5HX64Ghgn0eGi4VuXNmo0PTC8UzX9o3HBQA7" width="16" height="23"/> Заменен на IEC 60812:2018.</p><p id="P03CD0022" class="formattext"></p><p id="P03CD0023" class="formattext"></p></td></tr><tr><td valign="top" class="td5"><p id="P03CD0024" class="formattext" align="justify">[9]<br/><br/></p></td><td valign="top" class="td6"><p id="P03CD0025" class="formattext" align="justify">IEEE 352:1987 <br/><br/></p></td><td colspan="2" valign="top" class="td7"><p id="P03CD0026" class="formattext" align="justify"> IEEE Guide for general principles of reliability analysis of nuclear power generating station safety systems <br/><br/></p></td></tr><tr><td colspan="4" valign="top" class="td8"><p id="P03CD0027" class="formattext" align="justify">________________<br/></p><p id="P03CD0027_1" class="formattext indenttext" align="justify"><img class="base64" src="data:image;base64,R0lGODdhDwAXAIABAAAAAP///ywAAAAADwAXAAACIoyPqcvtDWIAMNElz2V7ut0p4KdVpZUZofmszwvH8kzXSAEAOw==" width="15" height="23"/> Заменен на IEEE 352:2016.</p><p id="P03CD0028" class="formattext"></p><p id="P03CD0029" class="formattext"></p></td></tr><tr><td valign="top" class="td5"><p id="P03CD002A" class="formattext" align="justify">[10]<br/><br/></p></td><td valign="top" class="td6"><p id="P03CD002B" class="formattext" align="justify">IEC 61164:2004 <br/><br/></p></td><td colspan="2" valign="top" class="td7"><p id="P03CD002C" class="formattext" align="justify"> Reliability growth - Statistical test and estimation methods<br/><br/></p></td></tr><tr><td valign="top" class="td5"><p id="P03CD002D" class="formattext" align="justify">[11]<br/><br/></p></td><td colspan="3" valign="top" class="td9"><p id="P03CD002E" class="formattext" align="justify">Verification and Validation of Real-Time Software, Chapter 5. W.J. Quirk (ed.). Springer Verlag, 1985, ISBN 3-540-15102-8.<br/><br/></p></td></tr><tr><td valign="top" class="td5"><p id="P03CD002F" class="formattext" align="justify">[12]<br/><br/></p></td><td colspan="3" valign="top" class="td9"><p id="P03CD0030" class="formattext" align="justify">Combining Probabilistic and Deterministic Verification Efforts. W.D. Ehrenberger, SAFECOMP 92, Pergamon Press, ISBN 0-08-041893-7.<br/><br/></p></td></tr><tr><td valign="top" class="td5"><p id="P03CD0031" class="formattext" align="justify">[13]<br/><br/></p></td><td colspan="3" valign="top" class="td9"><p id="P03CD0032" class="formattext" align="justify">Ingenieurstatistik. Heinhold/Gaede, Oldenburg, 1972, ISBN 3-486-31743-1.<br/><br/></p></td></tr><tr><td valign="top" class="td5"><p id="P03CD0033" class="formattext" align="justify">[14]<br/><br/></p></td><td valign="top" class="td6"><p id="P03CD0034" class="formattext" align="justify">IEC 60068-2-1 <br/><br/></p></td><td colspan="2" valign="top" class="td7"><p id="P03CD0035" class="formattext" align="justify">Environmental testing - Part 2-1: Tests - Test A: Cold<br/><br/></p></td></tr><tr><td valign="top" class="td5"><p id="P03CD0036" class="formattext" align="justify">[15]<br/><br/></p></td><td valign="top" class="td6"><p id="P03CD0037" class="formattext" align="justify">IEC 60068-2-2 <br/><br/></p></td><td colspan="2" valign="top" class="td7"><p id="P03CD0038" class="formattext" align="justify"> Environmental testing - Part 2-2: Tests - Test B: Dry heat <br/><br/></p></td></tr><tr><td valign="top" class="td5"><p id="P03CD0039" class="formattext">[16] </p></td><td valign="top" class="td6"><p id="P03CD003A" class="formattext">IEC 61508-1:2010 </p></td><td valign="top" class="td10"><p id="P03CD003B" class="formattext" align="justify">Functional safety of electrical/electronic/programmable electronic safety-related systems - Part 1: General requirements<br/><br/></p></td><td class="td4"></td></tr><tr><td valign="top" class="td5"><p id="P03CD003C" class="formattext">[17] </p></td><td valign="top" class="td6"><p id="P03CD003D" class="formattext">IEC 61508-2 </p></td><td valign="top" class="td10"><p id="P03CD003E" class="formattext" align="justify">Functional safety of electrical/electronic/programmable electronic safety-related systems - Part 2: Requirements for electrical/electronic/programmable electronic safety-related systems<br/><br/></p></td><td colspan="2" class="td4"></td></tr><tr><td valign="top" class="td5"><p id="P03CD003F" class="formattext">[18] </p></td><td valign="top" class="td6"><p id="P03CD0040" class="formattext">IEC 61508-3:2010 </p></td><td valign="top" class="td10"><p id="P03CD0041" class="formattext" align="justify">Functional safety of electrical/electronic/programmable electronic safety-related systems - Part 3: Software requirements<br/><br/></p></td><td colspan="2" class="td4"></td></tr><tr><td valign="top" class="td5"><p id="P03CD0042" class="formattext">[19] </p></td><td valign="top" class="td6"><p id="P03CD0043" class="formattext">IEC 61508-6:2010 </p></td><td valign="top" class="td10"><p id="P03CD0044" class="formattext" align="justify">Functional safety of electrical/electronic/programmable electronic safety-related systems - Part 6: Guidelines on the application of IEC 61508-2 and IEC 61508-3 <br/><br/></p></td><td colspan="2" class="td4"></td></tr></table></div><p id="P03CE" class="formattext topleveltext indenttext" align="justify"><br/></p><p id="X2332"></p><div element-type="table" class="table-container" id="X2333"><style type="text/css">#P03CF .td1 {width: 23.87em}#P03CF .td2 {width: 22.33em}#P03CF .td3 {width: 23.87em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px none black; border-bottom: 1px none black; border-right: 1px none black; }#P03CF .td4 {width: 22.33em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px solid black; border-left: 1px none black; border-bottom: 1px none black; border-right: 1px none black; }#P03CF .td5 {width: 23.87em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px none black; border-left: 1px none black; border-bottom: 1px none black; border-right: 1px none black; }#P03CF .td6 {width: 22.33em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px none black; border-left: 1px none black; border-bottom: 1px none black; border-right: 1px none black; }#P03CF .td7 {width: 46.20em;padding-left: 0.62em; padding-right: 0.62em;border-top: 1px none black; border-left: 1px none black; border-bottom: 1px solid black; border-right: 1px none black; }</style><table id="P03CF"><tr height="1"><td class="td1"></td><td class="td2"></td></tr><tr><td valign="top" class="td3"><p id="P03CF0000" class="formattext" align="justify">УДК 62-783:614.8:331.454:006.354 <br/><br/></p></td><td valign="top" class="td4"><p id="P03CF0001" class="formattext" align="right">ОКС 25.040.40 </p></td></tr><tr><td valign="top" class="td5"><p id="P03CF0002" class="formattext"></p></td><td valign="top" class="td6"><p id="P03CF0003" class="formattext" align="right">35.240.50 </p></td></tr><tr><td valign="top" class="td5"><p id="P03CF0004" class="formattext"></p></td><td valign="top" class="td6"><p id="P03CF0005" class="formattext"></p></td></tr><tr><td colspan="2" valign="top" class="td7"><p id="P03CF0006" class="formattext indenttext" align="justify">Ключевые слова: функциональная безопасность, жизненный цикл систем, электрические компоненты, электронные компоненты, программируемые электронные компоненты и системы, системы, связанные с безопасностью, случайные отказы оборудования, систематические отказы, планирование функциональной безопасности, методы и средства, полнота безопасности <br/><br/></p></td></tr></table></div><p id="P03D0" class="formattext topleveltext" align="justify"><br/><br/><br/></p><p id="P03D0_1" class="formattext topleveltext" align="justify">Электронный текст документа<br/></p><p id="P03D0_2" class="formattext topleveltext" align="justify">подготовлен АО &quot;Кодекс&quot; и сверен по:<br/></p><p id="P03D0_3" class="formattext topleveltext" align="justify">официальное издание<br/></p><p id="P03D0_4" class="formattext topleveltext" align="justify">М.: Стандартинформ, 2020 <br/><br/></p><p><img class="base64 sign" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZIAAAARCAMAAADAD9oKAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MTg4Q0U3ODQ0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MTg4Q0U3ODU0Q0JBMTFFRUIzMzY4MEMzRDY4OTQzODkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoxODhDRTc4MjRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDoxODhDRTc4MzRDQkExMUVFQjMzNjgwQzNENjg5NDM4OSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pos3t18AAAAzUExURfX19SQkJOrq6oeHh7y8vD8/P9/f31RUVMjIyLCwsHh4eJaWlmdnZ6Ojo9TU1AAAAP////kimdMAAAWSSURBVHja7FiJcuQoDAVzGcz1/1+7TwLRuDs9mZ2karZqQ1ViGz90PUngVv1nfMOo9fg2WarnNkf9FGxMHdDkf1jo3bXBg7o0YhIkfrXV0npvBfd48y94HQtV97XWZvBPfbpG29oikGfQ6oeRs4WLb4K2CGNq5wsltpX6B5TQYEa5/u6h9rdn31QdtXS0iKX1WZ360/o9Pl/3NmVq/ahk/cfwZ0X+bSL6T01Kxmq6Fj0MSDNPj+atGzF1+Y17z9IZMRfulHiH+ivMFvE7nm2ffQ26Q5+U0AKLatWUGFm63kU3SJycuwqNLgNJ1ONf6crorUNyEySMStQLlegNgSuSmiT5agizm0YyZwPNbEXLM64y2X0YcGgdN3ytU9FaLDCecHbCyFWVh0kjMvBEHK+rvx/tVIgOWSoTcZrRa+aVJxeOuLc5nG8Oj2cjCzdKDm1Uj9BCSFeO7sKBgKCxRWpXKNAiFtV2njBAGeqm2QBQaZKCjjDCA+vqnZJD802sAzu9q4EwRtde4djUG4kJeFObpsag4cXNNJKJejRY7pVO9EJiQf2XRJLlBEcW1Toooc48FcniBeN2nOALwwzMDXhDJv2CkoKENkS/NKzu0p74rRyOk0vcezgs0iXQhLDixE4J6YAALgUqoEq6VKpih0KosOuUUihxM+eGo6KIA3DEaTI8oJS7UZIybnhmOVX1wCiqLJSYmnr52WjShadTA7Obtsyl2lP22PquxG9kJ1VbSWN2gEXRfF4wlnri36xnTJBYC+R7ShyX17HNDIcXJSg8ddMqDi/p0+HOCGNfKclwPmdHBsVgp9mbHaemuwBMwtvmCK2pQqtwdpakiZIQg7pTAitwc+m6OVWyWFhnzQy9aMrcDZASSAJjgNlMo5R4UIJ1xbhnSsYr+p/LRslS1FfshQFIpb4v06WRvgBky4VfseOmPqy3zaKiZqp/SEmpOqhdqzi8pE+H6/2wu1PiCg9AkvOvlJi0r2ZbS7FooaMpdo8WYy6ixPFRZKcEE9Iz115irhdKWC/y1VquyIpWqU+i5GEapcRWJaGFFN9T4s7foyRQdqmNkqHvGJmn82AtUzed1s9vB63U6jj6ulOCnnbtWsXhJX06/J6S5LbDmKYuy/W11rgbobKpdRvmtNFKGpfS142SqEcL8CE99hIKV+ZmbDnr/NQL2Slx46wxoDSB2U27NS77eN4oGZaj91G6PChZiubzgo2+i9AKJbEd/S5yKA5ZAnCwLL6IcfYe2aHWb1rF4SV9OjwQ9XylZGwwORFSIeLUakYnHEVAgh6U0D7elY49C1OZNrM09pIC8EaJtnyjdHiIqE4qiY+K2YleProNrUcLhk8Lm2k3SgrF/KVKhuUQVUzfKFmK5vOCvVBytMSb69NeolwS66954oXTvnF2en3b3XmlIo3LPXF4SReHXZ5b3zMlCKcpAVse9z38XXh2kvo9htvuppy+LqeP0LgvBo/IpIJ+b/kQrGUDaM4XPvlBR9IPVq3mlkDldKIJ5k0vnGyzNh2myYvdtJ0S3wLtJeZOybT8uEabQ3kPSkSRUDRhs3HpI2uhKwKZKC8elADStJcASJOg7IcrF9BZvVBCPVi0bg6LdHF4IOqNkvmNaVM2iMWBHqoKLD9TvghAE92ecjdXxkxveb8tHElMxB7PblETZ1G2zDe1eNbBMkVEGdsDl4k3d709uAk86RPY3k2b5lZOIzbxnN2c5xk+LM9jv8PZaIBFkSwWBw9CRWwlLJ3fVZPTuYkUyLT+KPP7VBGAQmGev5tHTGMUrbvDU/pyeNn1oOQLQ74d6yeA51Hyfnn6FWDtmF8bueyXvzx+5XB/3d6/4rbfL+8Bz8Ne++X+s4z5pp/QLrtf/vJ47/B3U/L9Q/Fp4P87fn7R/c+NfwQYAFx9eFOvgdoSAAAAAElFTkSuQmCC"/></p>